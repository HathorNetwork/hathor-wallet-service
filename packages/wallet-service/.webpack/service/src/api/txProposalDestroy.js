/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/api/errors.ts":
/*!***************************!*\
  !*** ./src/api/errors.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ApiError = void 0;\nvar ApiError;\n(function (ApiError) {\n    ApiError[\"MISSING_PARAMETER\"] = \"missing-parameter\";\n    ApiError[\"INVALID_BODY\"] = \"invalid-body\";\n    ApiError[\"INVALID_TX_WEIGHT\"] = \"invalid-tx-weight\";\n    ApiError[\"INVALID_SELECTION_ALGORITHM\"] = \"invalid-selection-algorithm\";\n    ApiError[\"UNKNOWN_ERROR\"] = \"unknown-error\";\n    ApiError[\"INPUTS_NOT_FOUND\"] = \"inputs-not-found\";\n    ApiError[\"INPUTS_ALREADY_USED\"] = \"inputs-already-used\";\n    ApiError[\"INPUTS_NOT_IN_WALLET\"] = \"inputs-not-in-wallet\";\n    ApiError[\"INSUFFICIENT_FUNDS\"] = \"insufficient-funds\";\n    ApiError[\"INSUFFICIENT_INPUTS\"] = \"insufficient-inputs\";\n    ApiError[\"INVALID_PARAMETER\"] = \"invalid-parameter\";\n    ApiError[\"AUTH_INVALID_SIGNATURE\"] = \"invalid-auth-signature\";\n    ApiError[\"INVALID_PAYLOAD\"] = \"invalid-payload\";\n    ApiError[\"TOO_MANY_INPUTS\"] = \"too-many-inputs\";\n    ApiError[\"TOO_MANY_OUTPUTS\"] = \"too-many-outputs\";\n    ApiError[\"TX_PROPOSAL_NOT_FOUND\"] = \"tx-proposal-not-found\";\n    ApiError[\"TX_PROPOSAL_NOT_OPEN\"] = \"tx-proposal-not-open\";\n    ApiError[\"TX_PROPOSAL_SEND_ERROR\"] = \"tx-proposal-send-error\";\n    ApiError[\"TX_PROPOSAL_NO_MATCH\"] = \"tx-proposal-no-match\";\n    ApiError[\"WALLET_NOT_FOUND\"] = \"wallet-not-found\";\n    ApiError[\"WALLET_NOT_READY\"] = \"wallet-not-ready\";\n    ApiError[\"WALLET_ALREADY_LOADED\"] = \"wallet-already-loaded\";\n    ApiError[\"WALLET_MAX_RETRIES\"] = \"wallet-max-retries\";\n    ApiError[\"ADDRESS_NOT_IN_WALLET\"] = \"address-not-in-wallet\";\n    ApiError[\"ADDRESS_NOT_FOUND\"] = \"address-not-found\";\n    ApiError[\"TX_OUTPUT_NOT_IN_WALLET\"] = \"tx-output-not-in-wallet\";\n    ApiError[\"TOKEN_NOT_FOUND\"] = \"token-not-found\";\n    ApiError[\"FORBIDDEN\"] = \"forbidden\";\n    ApiError[\"UNAUTHORIZED\"] = \"unauthorized\";\n    ApiError[\"DEVICE_NOT_FOUND\"] = \"device-not-found\";\n    ApiError[\"TX_NOT_FOUND\"] = \"tx-not-found\";\n})(ApiError = exports.ApiError || (exports.ApiError = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2Vycm9ycy50cyIsIm1hcHBpbmdzIjoiOzs7QUFPQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1zZXJ2aWNlLy4vc3JjL2FwaS9lcnJvcnMudHM/ZTAxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgSGF0aG9yIExhYnMgYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmV4cG9ydCBlbnVtIEFwaUVycm9yIHtcbiAgTUlTU0lOR19QQVJBTUVURVIgPSAnbWlzc2luZy1wYXJhbWV0ZXInLFxuICBJTlZBTElEX0JPRFkgPSAnaW52YWxpZC1ib2R5JyxcbiAgSU5WQUxJRF9UWF9XRUlHSFQgPSAnaW52YWxpZC10eC13ZWlnaHQnLFxuICBJTlZBTElEX1NFTEVDVElPTl9BTEdPUklUSE0gPSAnaW52YWxpZC1zZWxlY3Rpb24tYWxnb3JpdGhtJyxcbiAgVU5LTk9XTl9FUlJPUiA9ICd1bmtub3duLWVycm9yJyxcbiAgSU5QVVRTX05PVF9GT1VORCA9ICdpbnB1dHMtbm90LWZvdW5kJyxcbiAgSU5QVVRTX0FMUkVBRFlfVVNFRCA9ICdpbnB1dHMtYWxyZWFkeS11c2VkJyxcbiAgSU5QVVRTX05PVF9JTl9XQUxMRVQgPSAnaW5wdXRzLW5vdC1pbi13YWxsZXQnLFxuICBJTlNVRkZJQ0lFTlRfRlVORFMgPSAnaW5zdWZmaWNpZW50LWZ1bmRzJyxcbiAgSU5TVUZGSUNJRU5UX0lOUFVUUyA9ICdpbnN1ZmZpY2llbnQtaW5wdXRzJyxcbiAgSU5WQUxJRF9QQVJBTUVURVIgPSAnaW52YWxpZC1wYXJhbWV0ZXInLFxuICBBVVRIX0lOVkFMSURfU0lHTkFUVVJFID0gJ2ludmFsaWQtYXV0aC1zaWduYXR1cmUnLFxuICBJTlZBTElEX1BBWUxPQUQgPSAnaW52YWxpZC1wYXlsb2FkJyxcbiAgVE9PX01BTllfSU5QVVRTID0gJ3Rvby1tYW55LWlucHV0cycsXG4gIFRPT19NQU5ZX09VVFBVVFMgPSAndG9vLW1hbnktb3V0cHV0cycsXG4gIFRYX1BST1BPU0FMX05PVF9GT1VORCA9ICd0eC1wcm9wb3NhbC1ub3QtZm91bmQnLFxuICBUWF9QUk9QT1NBTF9OT1RfT1BFTiA9ICd0eC1wcm9wb3NhbC1ub3Qtb3BlbicsXG4gIFRYX1BST1BPU0FMX1NFTkRfRVJST1IgPSAndHgtcHJvcG9zYWwtc2VuZC1lcnJvcicsXG4gIFRYX1BST1BPU0FMX05PX01BVENIID0gJ3R4LXByb3Bvc2FsLW5vLW1hdGNoJyxcbiAgV0FMTEVUX05PVF9GT1VORCA9ICd3YWxsZXQtbm90LWZvdW5kJyxcbiAgV0FMTEVUX05PVF9SRUFEWSA9ICd3YWxsZXQtbm90LXJlYWR5JyxcbiAgV0FMTEVUX0FMUkVBRFlfTE9BREVEID0gJ3dhbGxldC1hbHJlYWR5LWxvYWRlZCcsXG4gIFdBTExFVF9NQVhfUkVUUklFUyA9ICd3YWxsZXQtbWF4LXJldHJpZXMnLFxuICBBRERSRVNTX05PVF9JTl9XQUxMRVQgPSAnYWRkcmVzcy1ub3QtaW4td2FsbGV0JyxcbiAgQUREUkVTU19OT1RfRk9VTkQgPSAnYWRkcmVzcy1ub3QtZm91bmQnLFxuICBUWF9PVVRQVVRfTk9UX0lOX1dBTExFVCA9ICd0eC1vdXRwdXQtbm90LWluLXdhbGxldCcsXG4gIFRPS0VOX05PVF9GT1VORCA9ICd0b2tlbi1ub3QtZm91bmQnLFxuICBGT1JCSURERU4gPSAnZm9yYmlkZGVuJyxcbiAgVU5BVVRIT1JJWkVEID0gJ3VuYXV0aG9yaXplZCcsXG4gIERFVklDRV9OT1RfRk9VTkQgPSAnZGV2aWNlLW5vdC1mb3VuZCcsXG4gIFRYX05PVF9GT1VORCA9ICd0eC1ub3QtZm91bmQnLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/errors.ts\n");

/***/ }),

/***/ "./src/api/txProposalDestroy.ts":
/*!**************************************!*\
  !*** ./src/api/txProposalDestroy.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.destroy = void 0;\n__webpack_require__(/*! source-map-support/register */ \"source-map-support/register\");\nconst errors_1 = __webpack_require__(/*! @src/api/errors */ \"./src/api/errors.ts\");\nconst db_1 = __webpack_require__(/*! @src/db */ \"./src/db/index.ts\");\nconst commons_1 = __webpack_require__(/*! @src/commons */ \"./src/commons.ts\");\nconst types_1 = __webpack_require__(/*! @src/types */ \"./src/types.ts\");\nconst utils_1 = __webpack_require__(/*! @src/utils */ \"./src/utils.ts\");\nconst utils_2 = __webpack_require__(/*! @src/api/utils */ \"./src/api/utils.ts\");\nconst core_1 = __importDefault(__webpack_require__(/*! @middy/core */ \"@middy/core\"));\nconst http_cors_1 = __importDefault(__webpack_require__(/*! @middy/http-cors */ \"@middy/http-cors\"));\nconst mysql = (0, utils_1.getDbConnection)();\nexports.destroy = (0, core_1.default)((0, commons_1.walletIdProxyHandler)(async (walletId, event) => {\n    const params = event.pathParameters;\n    let txProposalId;\n    if (params && params.txProposalId) {\n        txProposalId = params.txProposalId;\n    }\n    else {\n        return (0, utils_2.closeDbAndGetError)(mysql, errors_1.ApiError.MISSING_PARAMETER, { parameter: 'txProposalId' });\n    }\n    const txProposal = await (0, db_1.getTxProposal)(mysql, txProposalId);\n    if (txProposal === null) {\n        return (0, utils_2.closeDbAndGetError)(mysql, errors_1.ApiError.TX_PROPOSAL_NOT_FOUND);\n    }\n    if (txProposal.walletId !== walletId) {\n        return (0, utils_2.closeDbAndGetError)(mysql, errors_1.ApiError.FORBIDDEN);\n    }\n    if (txProposal.status !== types_1.TxProposalStatus.OPEN && txProposal.status !== types_1.TxProposalStatus.SEND_ERROR) {\n        return (0, utils_2.closeDbAndGetError)(mysql, errors_1.ApiError.TX_PROPOSAL_NOT_OPEN);\n    }\n    const now = (0, utils_1.getUnixTimestamp)();\n    await (0, db_1.updateTxProposal)(mysql, [txProposalId], now, types_1.TxProposalStatus.CANCELLED);\n    await (0, db_1.releaseTxProposalUtxos)(mysql, [txProposalId]);\n    await (0, utils_1.closeDbConnection)(mysql);\n    return {\n        statusCode: 200,\n        body: JSON.stringify({\n            success: true,\n            txProposalId,\n        }),\n    };\n})).use((0, http_cors_1.default)());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3R4UHJvcG9zYWxEZXN0cm95LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUVBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBUUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93YWxsZXQtc2VydmljZS8uL3NyYy9hcGkvdHhQcm9wb3NhbERlc3Ryb3kudHM/YzlkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBUElHYXRld2F5UHJveHlIYW5kbGVyIH0gZnJvbSAnYXdzLWxhbWJkYSc7XG5cbmltcG9ydCAnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJztcblxuaW1wb3J0IHsgQXBpRXJyb3IgfSBmcm9tICdAc3JjL2FwaS9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgZ2V0VHhQcm9wb3NhbCxcbiAgdXBkYXRlVHhQcm9wb3NhbCxcbiAgcmVsZWFzZVR4UHJvcG9zYWxVdHhvcyxcbn0gZnJvbSAnQHNyYy9kYic7XG5pbXBvcnQgeyB3YWxsZXRJZFByb3h5SGFuZGxlciB9IGZyb20gJ0BzcmMvY29tbW9ucyc7XG5pbXBvcnQgeyBUeFByb3Bvc2FsU3RhdHVzIH0gZnJvbSAnQHNyYy90eXBlcyc7XG5pbXBvcnQgeyBjbG9zZURiQ29ubmVjdGlvbiwgZ2V0RGJDb25uZWN0aW9uLCBnZXRVbml4VGltZXN0YW1wIH0gZnJvbSAnQHNyYy91dGlscyc7XG5pbXBvcnQgeyBjbG9zZURiQW5kR2V0RXJyb3IgfSBmcm9tICdAc3JjL2FwaS91dGlscyc7XG5pbXBvcnQgbWlkZHkgZnJvbSAnQG1pZGR5L2NvcmUnO1xuaW1wb3J0IGNvcnMgZnJvbSAnQG1pZGR5L2h0dHAtY29ycyc7XG5cbmNvbnN0IG15c3FsID0gZ2V0RGJDb25uZWN0aW9uKCk7XG5cbi8qXG4gKiBEZXN0cm95IGEgdHhQcm9wb3NhbC5cbiAqXG4gKiBUaGlzIGxhbWJkYSBpcyBjYWxsZWQgYnkgQVBJIEdhdGV3YXkgb24gREVMRVRFIC90eHByb3Bvc2Fscy97cHJvcG9zYWxJZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlc3Ryb3k6IEFQSUdhdGV3YXlQcm94eUhhbmRsZXIgPSBtaWRkeSh3YWxsZXRJZFByb3h5SGFuZGxlcihhc3luYyAod2FsbGV0SWQsIGV2ZW50KSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IGV2ZW50LnBhdGhQYXJhbWV0ZXJzO1xuICBsZXQgdHhQcm9wb3NhbElkOiBzdHJpbmc7XG5cbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudHhQcm9wb3NhbElkKSB7XG4gICAgdHhQcm9wb3NhbElkID0gcGFyYW1zLnR4UHJvcG9zYWxJZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2xvc2VEYkFuZEdldEVycm9yKG15c3FsLCBBcGlFcnJvci5NSVNTSU5HX1BBUkFNRVRFUiwgeyBwYXJhbWV0ZXI6ICd0eFByb3Bvc2FsSWQnIH0pO1xuICB9XG5cbiAgY29uc3QgdHhQcm9wb3NhbCA9IGF3YWl0IGdldFR4UHJvcG9zYWwobXlzcWwsIHR4UHJvcG9zYWxJZCk7XG5cbiAgaWYgKHR4UHJvcG9zYWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY2xvc2VEYkFuZEdldEVycm9yKG15c3FsLCBBcGlFcnJvci5UWF9QUk9QT1NBTF9OT1RfRk9VTkQpO1xuICB9XG5cbiAgaWYgKHR4UHJvcG9zYWwud2FsbGV0SWQgIT09IHdhbGxldElkKSB7XG4gICAgcmV0dXJuIGNsb3NlRGJBbmRHZXRFcnJvcihteXNxbCwgQXBpRXJyb3IuRk9SQklEREVOKTtcbiAgfVxuXG4gIGlmICh0eFByb3Bvc2FsLnN0YXR1cyAhPT0gVHhQcm9wb3NhbFN0YXR1cy5PUEVOICYmIHR4UHJvcG9zYWwuc3RhdHVzICE9PSBUeFByb3Bvc2FsU3RhdHVzLlNFTkRfRVJST1IpIHtcbiAgICByZXR1cm4gY2xvc2VEYkFuZEdldEVycm9yKG15c3FsLCBBcGlFcnJvci5UWF9QUk9QT1NBTF9OT1RfT1BFTik7XG4gIH1cblxuICBjb25zdCBub3cgPSBnZXRVbml4VGltZXN0YW1wKCk7XG5cbiAgYXdhaXQgdXBkYXRlVHhQcm9wb3NhbChcbiAgICBteXNxbCxcbiAgICBbdHhQcm9wb3NhbElkXSxcbiAgICBub3csXG4gICAgVHhQcm9wb3NhbFN0YXR1cy5DQU5DRUxMRUQsXG4gICk7XG5cbiAgLy8gUmVtb3ZlIHR4X3Byb3Bvc2FsX2lkIGFuZCB0eF9wcm9wb3NhbF9pbmRleCBmcm9tIHV0eG8gdGFibGVcbiAgYXdhaXQgcmVsZWFzZVR4UHJvcG9zYWxVdHhvcyhteXNxbCwgW3R4UHJvcG9zYWxJZF0pO1xuXG4gIGF3YWl0IGNsb3NlRGJDb25uZWN0aW9uKG15c3FsKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdHhQcm9wb3NhbElkLFxuICAgIH0pLFxuICB9O1xufSkpLnVzZShjb3JzKCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/txProposalDestroy.ts\n");

/***/ }),

/***/ "./src/api/utils.ts":
/*!**************************!*\
  !*** ./src/api/utils.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.txIdJoiValidator = exports.validateParams = exports.pushProviderRegexPattern = exports.warmupMiddleware = exports.closeDbAndGetError = exports.STATUS_CODE_TABLE = void 0;\nconst joi_1 = __importDefault(__webpack_require__(/*! joi */ \"joi\"));\nconst errors_1 = __webpack_require__(/*! @src/api/errors */ \"./src/api/errors.ts\");\nconst types_1 = __webpack_require__(/*! @src/types */ \"./src/types.ts\");\nconst utils_1 = __webpack_require__(/*! @src/utils */ \"./src/utils.ts\");\nexports.STATUS_CODE_TABLE = {\n    [errors_1.ApiError.MISSING_PARAMETER]: 400,\n    [errors_1.ApiError.INVALID_BODY]: 400,\n    [errors_1.ApiError.INVALID_TX_WEIGHT]: 400,\n    [errors_1.ApiError.INVALID_SELECTION_ALGORITHM]: 400,\n    [errors_1.ApiError.UNKNOWN_ERROR]: 500,\n    [errors_1.ApiError.INPUTS_NOT_FOUND]: 400,\n    [errors_1.ApiError.INPUTS_ALREADY_USED]: 400,\n    [errors_1.ApiError.INSUFFICIENT_FUNDS]: 400,\n    [errors_1.ApiError.INSUFFICIENT_INPUTS]: 400,\n    [errors_1.ApiError.INVALID_PARAMETER]: 400,\n    [errors_1.ApiError.AUTH_INVALID_SIGNATURE]: 400,\n    [errors_1.ApiError.INVALID_PAYLOAD]: 400,\n    [errors_1.ApiError.TOO_MANY_INPUTS]: 400,\n    [errors_1.ApiError.TOO_MANY_OUTPUTS]: 400,\n    [errors_1.ApiError.TX_PROPOSAL_NOT_FOUND]: 404,\n    [errors_1.ApiError.TX_PROPOSAL_NOT_OPEN]: 400,\n    [errors_1.ApiError.TX_PROPOSAL_SEND_ERROR]: 400,\n    [errors_1.ApiError.TX_PROPOSAL_NO_MATCH]: 400,\n    [errors_1.ApiError.WALLET_NOT_FOUND]: 404,\n    [errors_1.ApiError.WALLET_NOT_READY]: 400,\n    [errors_1.ApiError.WALLET_ALREADY_LOADED]: 400,\n    [errors_1.ApiError.FORBIDDEN]: 403,\n    [errors_1.ApiError.UNAUTHORIZED]: 401,\n    [errors_1.ApiError.INPUTS_NOT_IN_WALLET]: 400,\n    [errors_1.ApiError.TX_OUTPUT_NOT_IN_WALLET]: 403,\n    [errors_1.ApiError.ADDRESS_NOT_IN_WALLET]: 400,\n    [errors_1.ApiError.WALLET_MAX_RETRIES]: 400,\n    [errors_1.ApiError.TOKEN_NOT_FOUND]: 404,\n    [errors_1.ApiError.DEVICE_NOT_FOUND]: 404,\n    [errors_1.ApiError.TX_NOT_FOUND]: 404,\n    [errors_1.ApiError.ADDRESS_NOT_FOUND]: 404,\n};\nconst closeDbAndGetError = async (mysql, error, extra) => {\n    await (0, utils_1.closeDbConnection)(mysql);\n    const body = Object.assign({ success: false, error }, extra);\n    return {\n        statusCode: exports.STATUS_CODE_TABLE[error],\n        body: JSON.stringify(body),\n    };\n};\nexports.closeDbAndGetError = closeDbAndGetError;\nconst warmupMiddleware = () => {\n    const warmupBefore = (request) => {\n        if (request.event.source === 'serverless-plugin-warmup') {\n            return {\n                statusCode: 200,\n                body: 'OK',\n            };\n        }\n        return undefined;\n    };\n    return {\n        before: warmupBefore,\n    };\n};\nexports.warmupMiddleware = warmupMiddleware;\nconst pushProviderRegexPattern = () => {\n    const entries = Object.values(types_1.PushProvider);\n    const options = entries.join('|');\n    return new RegExp(`^(?:${options})$`);\n};\nexports.pushProviderRegexPattern = pushProviderRegexPattern;\nconst validateParams = (validator, params, validatorOptions = {\n    abortEarly: false,\n    convert: false,\n}) => {\n    const result = validator.validate(params, validatorOptions);\n    const { error, value } = result;\n    if (error) {\n        const details = error.details.map((err) => ({\n            message: err.message,\n            path: err.path,\n        }));\n        return {\n            error: true,\n            details,\n        };\n    }\n    return {\n        error: false,\n        value,\n    };\n};\nexports.validateParams = validateParams;\nexports.txIdJoiValidator = joi_1.default.string().alphanum().min(64).max(64);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3V0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQVVBO0FBTUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUFpQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93YWxsZXQtc2VydmljZS8uL3NyYy9hcGkvdXRpbHMudHM/MjkyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgSGF0aG9yIExhYnMgYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IEFQSUdhdGV3YXlQcm94eVJlc3VsdCwgQVBJR2F0ZXdheVByb3h5RXZlbnQgfSBmcm9tICdhd3MtbGFtYmRhJztcbmltcG9ydCB7IFNlcnZlcmxlc3NNeXNxbCB9IGZyb20gJ3NlcnZlcmxlc3MtbXlzcWwnO1xuaW1wb3J0IG1pZGR5IGZyb20gJ0BtaWRkeS9jb3JlJztcbmltcG9ydCBKb2ksIHtcbiAgU2NoZW1hLFxuICBWYWxpZGF0aW9uT3B0aW9ucyxcbiAgVmFsaWRhdGlvblJlc3VsdCxcbn0gZnJvbSAnam9pJztcblxuaW1wb3J0IHsgQXBpRXJyb3IgfSBmcm9tICdAc3JjL2FwaS9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgUHVzaFByb3ZpZGVyLFxuICBTdHJpbmdNYXAsXG4gIFBhcmFtVmFsaWRhdGlvblJlc3VsdCxcbn0gZnJvbSAnQHNyYy90eXBlcyc7XG5pbXBvcnQgeyBjbG9zZURiQ29ubmVjdGlvbiB9IGZyb20gJ0BzcmMvdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgU1RBVFVTX0NPREVfVEFCTEUgPSB7XG4gIFtBcGlFcnJvci5NSVNTSU5HX1BBUkFNRVRFUl06IDQwMCxcbiAgW0FwaUVycm9yLklOVkFMSURfQk9EWV06IDQwMCxcbiAgW0FwaUVycm9yLklOVkFMSURfVFhfV0VJR0hUXTogNDAwLFxuICBbQXBpRXJyb3IuSU5WQUxJRF9TRUxFQ1RJT05fQUxHT1JJVEhNXTogNDAwLFxuICBbQXBpRXJyb3IuVU5LTk9XTl9FUlJPUl06IDUwMCxcbiAgW0FwaUVycm9yLklOUFVUU19OT1RfRk9VTkRdOiA0MDAsXG4gIFtBcGlFcnJvci5JTlBVVFNfQUxSRUFEWV9VU0VEXTogNDAwLFxuICBbQXBpRXJyb3IuSU5TVUZGSUNJRU5UX0ZVTkRTXTogNDAwLFxuICBbQXBpRXJyb3IuSU5TVUZGSUNJRU5UX0lOUFVUU106IDQwMCxcbiAgW0FwaUVycm9yLklOVkFMSURfUEFSQU1FVEVSXTogNDAwLFxuICBbQXBpRXJyb3IuQVVUSF9JTlZBTElEX1NJR05BVFVSRV06IDQwMCxcbiAgW0FwaUVycm9yLklOVkFMSURfUEFZTE9BRF06IDQwMCxcbiAgW0FwaUVycm9yLlRPT19NQU5ZX0lOUFVUU106IDQwMCxcbiAgW0FwaUVycm9yLlRPT19NQU5ZX09VVFBVVFNdOiA0MDAsXG4gIFtBcGlFcnJvci5UWF9QUk9QT1NBTF9OT1RfRk9VTkRdOiA0MDQsXG4gIFtBcGlFcnJvci5UWF9QUk9QT1NBTF9OT1RfT1BFTl06IDQwMCxcbiAgW0FwaUVycm9yLlRYX1BST1BPU0FMX1NFTkRfRVJST1JdOiA0MDAsXG4gIFtBcGlFcnJvci5UWF9QUk9QT1NBTF9OT19NQVRDSF06IDQwMCxcbiAgW0FwaUVycm9yLldBTExFVF9OT1RfRk9VTkRdOiA0MDQsXG4gIFtBcGlFcnJvci5XQUxMRVRfTk9UX1JFQURZXTogNDAwLFxuICBbQXBpRXJyb3IuV0FMTEVUX0FMUkVBRFlfTE9BREVEXTogNDAwLFxuICBbQXBpRXJyb3IuRk9SQklEREVOXTogNDAzLFxuICBbQXBpRXJyb3IuVU5BVVRIT1JJWkVEXTogNDAxLFxuICBbQXBpRXJyb3IuSU5QVVRTX05PVF9JTl9XQUxMRVRdOiA0MDAsXG4gIFtBcGlFcnJvci5UWF9PVVRQVVRfTk9UX0lOX1dBTExFVF06IDQwMyxcbiAgW0FwaUVycm9yLkFERFJFU1NfTk9UX0lOX1dBTExFVF06IDQwMCxcbiAgW0FwaUVycm9yLldBTExFVF9NQVhfUkVUUklFU106IDQwMCxcbiAgW0FwaUVycm9yLlRPS0VOX05PVF9GT1VORF06IDQwNCxcbiAgW0FwaUVycm9yLkRFVklDRV9OT1RfRk9VTkRdOiA0MDQsXG4gIFtBcGlFcnJvci5UWF9OT1RfRk9VTkRdOiA0MDQsXG4gIFtBcGlFcnJvci5BRERSRVNTX05PVF9GT1VORF06IDQwNCxcbn07XG5cbi8qKlxuICogQ2xvc2UgZGF0YWJhc2UgY29ubmVjdGlvbiBhbmQgZ2V0IGVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBUaGUgZGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGVycm9yIC0gQXBpRXJyb3IgcmV0dXJuIGNvZGVcbiAqIEBwYXJhbSBleHRyYSAtIEV4dHJhIGRhdGEgdG8gYmUgc2VudCBvbiB0aGUgYm9keSBvZiB0aGUgZXJyb3Igb2JqZWN0XG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCBjbG9zZURiQW5kR2V0RXJyb3IgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIGVycm9yOiBBcGlFcnJvcixcbiAgZXh0cmE/OiBTdHJpbmdNYXA8dW5rbm93bj4sXG4pOiBQcm9taXNlPEFQSUdhdGV3YXlQcm94eVJlc3VsdD4gPT4ge1xuICBhd2FpdCBjbG9zZURiQ29ubmVjdGlvbihteXNxbCk7XG4gIGNvbnN0IGJvZHkgPSB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvciwgLi4uZXh0cmEgfTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNDb2RlOiBTVEFUVVNfQ09ERV9UQUJMRVtlcnJvcl0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gIH07XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGVhcmx5IGlmIHRoZSByZXF1ZXN0IGlzIGEgd2FrZS11cCBjYWxsIGZyb20gc2VydmVybGVzcy1wbHVnaW4td2FybXVwXG4gKi9cbmV4cG9ydCBjb25zdCB3YXJtdXBNaWRkbGV3YXJlID0gKCk6IG1pZGR5Lk1pZGRsZXdhcmVPYmo8QVBJR2F0ZXdheVByb3h5RXZlbnQsIEFQSUdhdGV3YXlQcm94eVJlc3VsdD4gPT4ge1xuICBjb25zdCB3YXJtdXBCZWZvcmUgPSAocmVxdWVzdDogbWlkZHkuUmVxdWVzdCk6IEFQSUdhdGV3YXlQcm94eVJlc3VsdCB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKHJlcXVlc3QuZXZlbnQuc291cmNlID09PSAnc2VydmVybGVzcy1wbHVnaW4td2FybXVwJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBib2R5OiAnT0snLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYmVmb3JlOiB3YXJtdXBCZWZvcmUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcHVzaFByb3ZpZGVyUmVnZXhQYXR0ZXJuID0gKCk6IFJlZ0V4cCA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QudmFsdWVzKFB1c2hQcm92aWRlcik7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbnRyaWVzLmpvaW4oJ3wnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oPzoke29wdGlvbnN9KSRgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVBhcmFtcyA9IDxSZXN1bHRUeXBlPihcbiAgdmFsaWRhdG9yOiBTY2hlbWEsXG4gIHBhcmFtczogdW5rbm93bixcbiAgdmFsaWRhdG9yT3B0aW9uczogVmFsaWRhdGlvbk9wdGlvbnMgPSB7XG4gICAgYWJvcnRFYXJseTogZmFsc2UsXG4gICAgY29udmVydDogZmFsc2UsXG4gIH0sXG4pOiBQYXJhbVZhbGlkYXRpb25SZXN1bHQ8UmVzdWx0VHlwZT4gPT4ge1xuICBjb25zdCByZXN1bHQ6IFZhbGlkYXRpb25SZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGUocGFyYW1zLCB2YWxpZGF0b3JPcHRpb25zKTtcblxuICBjb25zdCB7IGVycm9yLCB2YWx1ZSB9ID0gcmVzdWx0O1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnN0IGRldGFpbHMgPSBlcnJvci5kZXRhaWxzLm1hcCgoZXJyKSA9PiAoe1xuICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICBwYXRoOiBlcnIucGF0aCxcbiAgICB9KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHRydWUsXG4gICAgICBkZXRhaWxzLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVycm9yOiBmYWxzZSxcbiAgICB2YWx1ZSxcbiAgfTtcbn07XG5cbi8qKlxuICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbnNpZGUgYSBKb2kgdmFsaWRhdG9yIG9iamVjdFxuICovXG5leHBvcnQgY29uc3QgdHhJZEpvaVZhbGlkYXRvciA9IEpvaS5zdHJpbmcoKS5hbHBoYW51bSgpLm1pbig2NCkubWF4KDY0KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/utils.ts\n");

/***/ }),

/***/ "./src/commons.ts":
/*!************************!*\
  !*** ./src/commons.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWalletBalancesForTx = exports.prepareOutputs = exports.walletIdProxyHandler = exports.handleReorg = exports.validateAddressBalances = exports.handleVoided = exports.handleVoidedTxList = exports.searchForLatestValidBlock = exports.maybeRefreshWalletConstants = exports.getWalletBalances = exports.getWalletBalanceMap = exports.getTokenListFromInputsAndOutputs = exports.getAddressBalanceMap = exports.markLockedOutputs = exports.unlockTimelockedUtxos = exports.unlockUtxos = void 0;\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst db_1 = __webpack_require__(/*! @src/db */ \"./src/db/index.ts\");\nconst types_1 = __webpack_require__(/*! @src/types */ \"./src/types.ts\");\nconst alerting_utils_1 = __webpack_require__(/*! @src/utils/alerting.utils */ \"./src/utils/alerting.utils.ts\");\nconst utils_1 = __webpack_require__(/*! @src/utils */ \"./src/utils.ts\");\nconst wallet_lib_1 = __importDefault(__webpack_require__(/*! @hathor/wallet-lib */ \"@hathor/wallet-lib\"));\nconst utils_2 = __webpack_require__(/*! @src/db/utils */ \"./src/db/utils.ts\");\nconst VERSION_CHECK_MAX_DIFF = 60 * 60 * 1000;\nconst WARN_MAX_REORG_SIZE = parseInt(process.env.WARN_MAX_REORG_SIZE || '100', 10);\nconst unlockUtxos = async (mysql, utxos, updateTimelocks) => {\n    if (utxos.length === 0)\n        return;\n    const outputs = utxos.map((utxo) => {\n        const decoded = {\n            type: 'P2PKH',\n            address: utxo.address,\n            timelock: utxo.timelock,\n        };\n        return {\n            value: utxo.authorities > 0 ? utxo.authorities : utxo.value,\n            token: utxo.tokenId,\n            decoded,\n            locked: false,\n            token_data: utxo.authorities > 0 ? wallet_lib_1.default.constants.TOKEN_AUTHORITY_MASK : 0,\n            spent_by: null,\n            script: '',\n        };\n    });\n    await (0, db_1.unlockUtxos)(mysql, utxos);\n    const addressBalanceMap = (0, exports.getAddressBalanceMap)([], outputs);\n    await (0, db_1.updateAddressLockedBalance)(mysql, addressBalanceMap, updateTimelocks);\n    const addressWalletMap = await (0, db_1.getAddressWalletInfo)(mysql, Object.keys(addressBalanceMap));\n    const walletBalanceMap = (0, exports.getWalletBalanceMap)(addressWalletMap, addressBalanceMap);\n    await (0, db_1.updateWalletLockedBalance)(mysql, walletBalanceMap, updateTimelocks);\n};\nexports.unlockUtxos = unlockUtxos;\nconst unlockTimelockedUtxos = async (mysql, now) => {\n    const utxos = await (0, db_1.getExpiredTimelocksUtxos)(mysql, now);\n    await (0, exports.unlockUtxos)(mysql, utxos, true);\n};\nexports.unlockTimelockedUtxos = unlockTimelockedUtxos;\nconst markLockedOutputs = (outputs, now, hasHeightLock = false) => {\n    for (const output of outputs) {\n        output.locked = false;\n        if (hasHeightLock || output.decoded.timelock > now) {\n            output.locked = true;\n        }\n    }\n};\nexports.markLockedOutputs = markLockedOutputs;\nconst getAddressBalanceMap = (inputs, outputs) => {\n    const addressBalanceMap = {};\n    for (const input of inputs) {\n        const address = input.decoded.address;\n        const tokenBalanceMap = types_1.TokenBalanceMap.fromTxInput(input);\n        addressBalanceMap[address] = types_1.TokenBalanceMap.merge(addressBalanceMap[address], tokenBalanceMap);\n    }\n    for (const output of outputs) {\n        const address = output.decoded.address;\n        const tokenBalanceMap = types_1.TokenBalanceMap.fromTxOutput(output);\n        addressBalanceMap[address] = types_1.TokenBalanceMap.merge(addressBalanceMap[address], tokenBalanceMap);\n    }\n    return addressBalanceMap;\n};\nexports.getAddressBalanceMap = getAddressBalanceMap;\nconst getTokenListFromInputsAndOutputs = (inputs, outputs) => {\n    const tokenIds = new Set([]);\n    for (const input of inputs) {\n        tokenIds.add(input.token);\n    }\n    for (const output of outputs) {\n        tokenIds.add(output.token);\n    }\n    return [...tokenIds];\n};\nexports.getTokenListFromInputsAndOutputs = getTokenListFromInputsAndOutputs;\nconst getWalletBalanceMap = (addressWalletMap, addressBalanceMap) => {\n    const walletBalanceMap = {};\n    for (const [address, balanceMap] of Object.entries(addressBalanceMap)) {\n        const wallet = addressWalletMap[address];\n        const walletId = wallet && wallet.walletId;\n        if (!walletId)\n            continue;\n        walletBalanceMap[walletId] = types_1.TokenBalanceMap.merge(walletBalanceMap[walletId], balanceMap);\n    }\n    return walletBalanceMap;\n};\nexports.getWalletBalanceMap = getWalletBalanceMap;\nconst getWalletBalances = async (mysql, now, walletId, tokenIds = []) => {\n    let balances = await (0, db_1.getWalletBalances)(mysql, walletId, tokenIds);\n    const refreshBalances = balances.some((tb) => {\n        if (tb.balance.lockExpires && tb.balance.lockExpires <= now) {\n            return true;\n        }\n        return false;\n    });\n    if (refreshBalances) {\n        const currentHeight = await (0, db_1.getLatestHeight)(mysql);\n        const utxos = await (0, db_1.getWalletUnlockedUtxos)(mysql, walletId, now, currentHeight);\n        await (0, exports.unlockUtxos)(mysql, utxos, true);\n        balances = await (0, db_1.getWalletBalances)(mysql, walletId, tokenIds);\n    }\n    return balances;\n};\nexports.getWalletBalances = getWalletBalances;\nconst maybeRefreshWalletConstants = async (mysql) => {\n    const lastVersionData = await (0, db_1.getVersionData)(mysql);\n    const now = (0, utils_1.getUnixTimestamp)();\n    if (!lastVersionData || now - lastVersionData.timestamp > VERSION_CHECK_MAX_DIFF) {\n        const apiResponse = await wallet_lib_1.default.version.checkApiVersion();\n        const versionData = {\n            timestamp: now,\n            version: apiResponse.version,\n            network: apiResponse.network,\n            minWeight: apiResponse.min_weight,\n            minTxWeight: apiResponse.min_tx_weight,\n            minTxWeightCoefficient: apiResponse.min_tx_weight_coefficient,\n            minTxWeightK: apiResponse.min_tx_weight_k,\n            tokenDepositPercentage: apiResponse.token_deposit_percentage,\n            rewardSpendMinBlocks: apiResponse.reward_spend_min_blocks,\n            maxNumberInputs: apiResponse.max_number_inputs,\n            maxNumberOutputs: apiResponse.max_number_outputs,\n        };\n        await (0, db_1.updateVersionData)(mysql, versionData);\n    }\n    else {\n        wallet_lib_1.default.transaction.updateTransactionWeightConstants(lastVersionData.minTxWeight, lastVersionData.minTxWeightCoefficient, lastVersionData.minTxWeightK);\n        wallet_lib_1.default.tokens.updateDepositPercentage(lastVersionData.tokenDepositPercentage);\n        wallet_lib_1.default.transaction.updateMaxInputsConstant(lastVersionData.maxNumberInputs);\n        wallet_lib_1.default.transaction.updateMaxOutputsConstant(lastVersionData.maxNumberOutputs);\n        wallet_lib_1.default.wallet.updateRewardLockConstant(lastVersionData.rewardSpendMinBlocks);\n    }\n};\nexports.maybeRefreshWalletConstants = maybeRefreshWalletConstants;\nconst searchForLatestValidBlock = async (mysql) => {\n    const latestHeight = await (0, db_1.getLatestHeight)(mysql);\n    const bestBlock = await (0, db_1.getBlockByHeight)(mysql, latestHeight);\n    let start = 0;\n    let end = bestBlock.height;\n    let latestValidBlock = bestBlock;\n    while (start <= end) {\n        const midHeight = Math.floor((start + end) / 2);\n        const middleBlock = await (0, db_1.getBlockByHeight)(mysql, midHeight);\n        const [isVoided] = await (0, utils_1.isTxVoided)(middleBlock.txId);\n        if (!isVoided) {\n            latestValidBlock = middleBlock;\n            start = midHeight + 1;\n        }\n        else {\n            end = midHeight - 1;\n        }\n    }\n    return latestValidBlock;\n};\nexports.searchForLatestValidBlock = searchForLatestValidBlock;\nconst handleVoidedTxList = async (mysql, logger, txs) => {\n    logger.debug(`Setting ${txs.length} transactions as voided.`, {\n        transactions: txs,\n    });\n    await (0, db_1.markTxsAsVoided)(mysql, txs);\n    logger.debug(`Setting WalletTxHistory as voided from ${txs.length} transactions.`);\n    await (0, db_1.markWalletTxHistoryAsVoided)(mysql, txs);\n    logger.debug(`Setting AddressTxHistory as voided from ${txs.length} transactions.`);\n    await (0, db_1.markAddressTxHistoryAsVoided)(mysql, txs);\n    const txOutputs = await (0, db_1.getTxOutputs)(mysql, txs);\n    logger.debug(`Fetched ${txOutputs.length} utxos from the voided transaction list`, {\n        txOutputs,\n    });\n    const txOutputsTxIds = txOutputs.reduce((acc, txOutput) => acc.add(txOutput.txId), new Set());\n    const spentOutputs = await (0, db_1.getTxOutputsBySpent)(mysql, [...txOutputsTxIds]);\n    if (spentOutputs.length > 0) {\n        logger.debug(`Unspending ${spentOutputs.length} tx_outputs.`, {\n            txOutputs: spentOutputs,\n        });\n        await (0, db_1.unspendUtxos)(mysql, [...spentOutputs]);\n    }\n    const affectedUtxoList = [...txOutputs, ...spentOutputs];\n    logger.debug(`Setting ${txOutputs.length} tx_outputs as voided.`, {\n        txOutputs,\n    });\n    await (0, db_1.markUtxosAsVoided)(mysql, txOutputs);\n    const txIds = txOutputs.reduce((acc, utxo) => {\n        if (utxo.spentBy) {\n            acc.add(utxo.spentBy);\n        }\n        return acc;\n    }, new Set());\n    const newTxs = await (0, db_1.getTransactionsById)(mysql, [...txIds]);\n    logger.debug(`Fetched ${newTxs.length} transactions that spend the voided tx outputs list`, {\n        transactions: newTxs,\n    });\n    return [newTxs, affectedUtxoList];\n};\nexports.handleVoidedTxList = handleVoidedTxList;\nconst handleVoided = async (mysql, logger, tx) => {\n    let txs = [tx];\n    let affectedUtxoList = [];\n    while (txs.length > 0) {\n        const [newTxs, newAffectedUtxoList] = await (0, exports.handleVoidedTxList)(mysql, logger, txs);\n        txs = newTxs;\n        affectedUtxoList = [...affectedUtxoList, ...newAffectedUtxoList];\n    }\n    const [affectedAddresses, affectedTxIds] = affectedUtxoList.reduce((acc, utxo) => {\n        acc[0].add(utxo.address);\n        acc[1].add(utxo.txId);\n        return acc;\n    }, [new Set(), new Set()]);\n    if (affectedAddresses.size > 0) {\n        const addresses = [...affectedAddresses];\n        logger.debug(`Rebuilding balances for ${addresses.length} addresses.`, {\n            addresses,\n        });\n        logger.debug(`Rebuilding tx count from ${affectedTxIds.size} transactions`, {\n            affectedTxIds,\n        });\n        await (0, db_1.rebuildAddressBalancesFromUtxos)(mysql, addresses, [...affectedTxIds]);\n        await (0, exports.validateAddressBalances)(mysql, addresses);\n    }\n    logger.debug('Handle voided tx is done.');\n};\nexports.handleVoided = handleVoided;\nconst validateAddressBalances = async (mysql, addresses) => {\n    const addressBalances = await (0, db_1.fetchAddressBalance)(mysql, addresses);\n    const addressTxHistorySums = await (0, db_1.fetchAddressTxHistorySum)(mysql, addresses);\n    for (let i = 0; i < addressTxHistorySums.length; i++) {\n        const addressBalance = addressBalances[i];\n        const addressTxHistorySum = addressTxHistorySums[i];\n        assert_1.strict.strictEqual(addressBalance.tokenId, addressTxHistorySum.tokenId);\n        assert_1.strict.strictEqual(addressBalance.unlockedBalance + addressBalance.lockedBalance, addressTxHistorySum.balance);\n    }\n};\nexports.validateAddressBalances = validateAddressBalances;\nconst handleReorg = async (mysql, logger) => {\n    const { height } = await (0, exports.searchForLatestValidBlock)(mysql);\n    const currentHeight = await (0, db_1.getLatestHeight)(mysql);\n    logger.debug(`Handling reorg. Our latest valid block is ${height} and our highest block height is ${currentHeight}`, {\n        height,\n        currentHeight,\n    });\n    if ((currentHeight - height) > WARN_MAX_REORG_SIZE) {\n        logger.error(`A reorg with ${currentHeight - height} blocks has been detected`);\n        await (0, alerting_utils_1.addAlert)('Big reorg detected', `A reorg with ${currentHeight - height} blocks has been detected`, types_1.Severity.MINOR, { walletServiceHeight: currentHeight, fullNodeHeight: height });\n    }\n    const allTxsAfterHeight = await (0, db_1.getTxsAfterHeight)(mysql, height);\n    let txs = allTxsAfterHeight.filter((tx) => [\n        wallet_lib_1.default.constants.BLOCK_VERSION,\n        wallet_lib_1.default.constants.MERGED_MINED_BLOCK_VERSION,\n    ].indexOf(tx.version) > -1);\n    await (0, db_1.deleteBlocksAfterHeight)(mysql, height);\n    logger.debug('Removing transactions', txs.map((tx) => tx.txId));\n    let affectedUtxoList = [];\n    while (txs.length > 0) {\n        const [newTxs, newAffectedUtxoList] = await (0, exports.handleVoidedTxList)(mysql, logger, txs);\n        txs = newTxs;\n        affectedUtxoList = [...affectedUtxoList, ...newAffectedUtxoList];\n    }\n    const remainingTxs = await (0, db_1.getTxsAfterHeight)(mysql, height);\n    if (remainingTxs.length > 0) {\n        logger.debug(`Setting ${remainingTxs.length} unconfirmed transactions to the mempool (height = NULL).`, {\n            remainingTxs,\n        });\n        await (0, db_1.removeTxsHeight)(mysql, remainingTxs);\n    }\n    const [affectedAddresses, affectedTxIds] = affectedUtxoList.reduce((acc, utxo) => {\n        acc[0].add(utxo.address);\n        acc[1].add(utxo.txId);\n        return acc;\n    }, [new Set(), new Set()]);\n    if (affectedAddresses.size > 0) {\n        const addresses = [...affectedAddresses];\n        logger.debug(`Rebuilding balances for ${addresses.length} addresses.`, {\n            addresses,\n        });\n        logger.debug(`Rebuilding tx count from ${affectedTxIds.size} transactions`, {\n            affectedTxIds,\n        });\n        await (0, db_1.rebuildAddressBalancesFromUtxos)(mysql, addresses, [...affectedTxIds]);\n        await (0, exports.validateAddressBalances)(mysql, addresses);\n    }\n    logger.debug('Reorg is done.');\n    return height;\n};\nexports.handleReorg = handleReorg;\nconst walletIdProxyHandler = (handler) => (async (event, context) => {\n    let walletId;\n    try {\n        walletId = event.requestContext.authorizer.principalId;\n    }\n    catch (e) {\n        return {\n            statusCode: 401,\n            body: 'Unauthorized',\n        };\n    }\n    return handler(walletId, event, context);\n});\nexports.walletIdProxyHandler = walletIdProxyHandler;\nconst prepareOutputs = (outputs, txId, logger) => {\n    const preparedOutputs = outputs.reduce(([currIndex, newOutputs], output) => {\n        if (!output.decoded\n            || output.decoded.type === null\n            || output.decoded.type === undefined) {\n            logger.warn(`Ignoring tx output with index ${currIndex} from tx ${txId} as script couldn't be decoded.`);\n            return [currIndex + 1, newOutputs];\n        }\n        return [\n            currIndex + 1,\n            [\n                ...newOutputs,\n                Object.assign(Object.assign({}, output), { index: currIndex }),\n            ],\n        ];\n    }, [0, []]);\n    return preparedOutputs[1];\n};\nexports.prepareOutputs = prepareOutputs;\nconst getWalletBalancesForTx = async (mysql, tx) => {\n    const addressBalanceMap = (0, exports.getAddressBalanceMap)(tx.inputs, tx.outputs);\n    const addressWalletMap = await (0, db_1.getAddressWalletInfo)(mysql, Object.keys(addressBalanceMap));\n    const walletsMap = {};\n    const tokenIdAccumulation = [];\n    const addressWalletEntries = (0, utils_2.stringMapIterator)(addressWalletMap);\n    for (const [address, wallet] of addressWalletEntries) {\n        if (!walletsMap[wallet.walletId]) {\n            walletsMap[wallet.walletId] = {\n                txId: tx.tx_id,\n                walletId: wallet.walletId,\n                addresses: [],\n                walletBalanceForTx: new types_1.TokenBalanceMap(),\n            };\n        }\n        const walletData = walletsMap[wallet.walletId];\n        walletData.addresses.push(address);\n        const mergedBalance = types_1.TokenBalanceMap.merge(walletData.walletBalanceForTx, addressBalanceMap[address]);\n        walletData.walletBalanceForTx = mergedBalance;\n        const tokenIdList = Object.keys(mergedBalance.map);\n        tokenIdAccumulation.push(tokenIdList);\n    }\n    const tokenIdSet = new Set(tokenIdAccumulation.reduce((prev, eachGroup) => [...prev, ...eachGroup], []));\n    const tokenSymbolsMap = await (0, db_1.getTokenSymbols)(mysql, Array.from(tokenIdSet.values()));\n    return utils_2.WalletBalanceMapConverter.toValue(walletsMap, tokenSymbolsMap);\n};\nexports.getWalletBalancesForTx = getWalletBalancesForTx;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9ucy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFVQTtBQUVBO0FBNEJBO0FBc0JBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFwQ0E7QUE2Q0E7QUFDQTtBQUVBO0FBQ0E7QUFKQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUF5QkE7QUFJQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQTFCQTtBQW1DQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVpBO0FBa0NBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQTRCQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQThCQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQTBDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBM0JBO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUEzREE7QUFvRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQW5DQTtBQXFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQWJBO0FBdUJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFsRkE7QUFvRkE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWdCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUF6QkE7QUFrQ0E7QUFDQTtBQUVBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQXhDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1zZXJ2aWNlLy4vc3JjL2NvbW1vbnMudHM/ZTY3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgSGF0aG9yIExhYnMgYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IEFQSUdhdGV3YXlQcm94eUhhbmRsZXIgfSBmcm9tICdhd3MtbGFtYmRhJztcblxuaW1wb3J0IHsgU2VydmVybGVzc015c3FsIH0gZnJvbSAnc2VydmVybGVzcy1teXNxbCc7XG5pbXBvcnQgeyBzdHJpY3QgYXMgYXNzZXJ0IH0gZnJvbSAnYXNzZXJ0JztcblxuaW1wb3J0IHtcbiAgZ2V0QWRkcmVzc1dhbGxldEluZm8sXG4gIGdldExhdGVzdEhlaWdodCxcbiAgZ2V0V2FsbGV0QmFsYW5jZXMgYXMgZGJHZXRXYWxsZXRCYWxhbmNlcyxcbiAgZ2V0V2FsbGV0VW5sb2NrZWRVdHhvcyxcbiAgZ2V0RXhwaXJlZFRpbWVsb2Nrc1V0eG9zLFxuICB1bmxvY2tVdHhvcyBhcyBkYlVubG9ja1V0eG9zLFxuICB1cGRhdGVBZGRyZXNzTG9ja2VkQmFsYW5jZSxcbiAgdXBkYXRlV2FsbGV0TG9ja2VkQmFsYW5jZSxcbiAgZ2V0VmVyc2lvbkRhdGEsXG4gIHVwZGF0ZVZlcnNpb25EYXRhLFxuICBnZXRCbG9ja0J5SGVpZ2h0LFxuICBnZXRUeHNBZnRlckhlaWdodCxcbiAgbWFya1R4c0FzVm9pZGVkLFxuICBnZXRUeE91dHB1dHMsXG4gIGdldFR4T3V0cHV0c0J5U3BlbnQsXG4gIHJlbW92ZVR4c0hlaWdodCxcbiAgdW5zcGVuZFV0eG9zLFxuICBtYXJrVXR4b3NBc1ZvaWRlZCxcbiAgZ2V0VHJhbnNhY3Rpb25zQnlJZCxcbiAgZGVsZXRlQmxvY2tzQWZ0ZXJIZWlnaHQsXG4gIG1hcmtXYWxsZXRUeEhpc3RvcnlBc1ZvaWRlZCxcbiAgbWFya0FkZHJlc3NUeEhpc3RvcnlBc1ZvaWRlZCxcbiAgcmVidWlsZEFkZHJlc3NCYWxhbmNlc0Zyb21VdHhvcyxcbiAgZmV0Y2hBZGRyZXNzQmFsYW5jZSxcbiAgZmV0Y2hBZGRyZXNzVHhIaXN0b3J5U3VtLFxuICBnZXRUb2tlblN5bWJvbHMsXG59IGZyb20gJ0BzcmMvZGInO1xuaW1wb3J0IHtcbiAgRGVjb2RlZE91dHB1dCxcbiAgU3RyaW5nTWFwLFxuICBUb2tlbkJhbGFuY2VNYXAsXG4gIFR4SW5wdXQsXG4gIFR4T3V0cHV0LFxuICBUeE91dHB1dFdpdGhJbmRleCxcbiAgRGJUeE91dHB1dCxcbiAgVHgsXG4gIFdhbGxldCxcbiAgQmxvY2ssXG4gIFdhbGxldFRva2VuQmFsYW5jZSxcbiAgRnVsbE5vZGVWZXJzaW9uRGF0YSxcbiAgQWRkcmVzc0JhbGFuY2UsXG4gIEFkZHJlc3NUb3RhbEJhbGFuY2UsXG4gIFdhbGxldFByb3h5SGFuZGxlcixcbiAgV2FsbGV0QmFsYW5jZSxcbiAgVHJhbnNhY3Rpb24sXG4gIFdhbGxldEJhbGFuY2VWYWx1ZSxcbiAgU2V2ZXJpdHksXG59IGZyb20gJ0BzcmMvdHlwZXMnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnd2luc3Rvbic7XG5pbXBvcnQgeyBhZGRBbGVydCB9IGZyb20gJ0BzcmMvdXRpbHMvYWxlcnRpbmcudXRpbHMnO1xuXG5pbXBvcnQge1xuICBnZXRVbml4VGltZXN0YW1wLFxuICBpc1R4Vm9pZGVkLFxufSBmcm9tICdAc3JjL3V0aWxzJztcblxuaW1wb3J0IGhhdGhvckxpYiBmcm9tICdAaGF0aG9yL3dhbGxldC1saWInO1xuaW1wb3J0IHsgc3RyaW5nTWFwSXRlcmF0b3IsIFdhbGxldEJhbGFuY2VNYXBDb252ZXJ0ZXIgfSBmcm9tICdAc3JjL2RiL3V0aWxzJztcblxuY29uc3QgVkVSU0lPTl9DSEVDS19NQVhfRElGRiA9IDYwICogNjAgKiAxMDAwOyAvLyAxIGhvdXJcbmNvbnN0IFdBUk5fTUFYX1JFT1JHX1NJWkUgPSBwYXJzZUludChwcm9jZXNzLmVudi5XQVJOX01BWF9SRU9SR19TSVpFIHx8ICcxMDAnLCAxMCk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSB1bmxvY2tlZC9sb2NrZWQgYmFsYW5jZXMgZm9yIGFkZHJlc3NlcyBhbmQgd2FsbGV0cyBjb25uZWN0ZWQgdG8gdGhlIGdpdmVuIFVUWE9zLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB1dHhvcyAtIExpc3Qgb2YgVVRYT3MgdGhhdCBhcmUgdW5sb2NrZWQgYnkgaGVpZ2h0XG4gKiBAcGFyYW0gdXBkYXRlVGltZWxvY2tzIC0gSWYgdGhpcyB1cGRhdGUgaXMgdHJpZ2dlcmVkIGJ5IGEgdGltZWxvY2sgZXhwaXJpbmcsIHVwZGF0ZSB0aGUgbmV4dCBsb2NrIGV4cGlyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHVubG9ja1V0eG9zID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIHV0eG9zOiBEYlR4T3V0cHV0W10sIHVwZGF0ZVRpbWVsb2NrczogYm9vbGVhbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAodXR4b3MubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgY29uc3Qgb3V0cHV0czogVHhPdXRwdXRbXSA9IHV0eG9zLm1hcCgodXR4bykgPT4ge1xuICAgIGNvbnN0IGRlY29kZWQ6IERlY29kZWRPdXRwdXQgPSB7XG4gICAgICB0eXBlOiAnUDJQS0gnLFxuICAgICAgYWRkcmVzczogdXR4by5hZGRyZXNzLFxuICAgICAgdGltZWxvY2s6IHV0eG8udGltZWxvY2ssXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdXR4by5hdXRob3JpdGllcyA+IDAgPyB1dHhvLmF1dGhvcml0aWVzIDogdXR4by52YWx1ZSxcbiAgICAgIHRva2VuOiB1dHhvLnRva2VuSWQsXG4gICAgICBkZWNvZGVkLFxuICAgICAgbG9ja2VkOiBmYWxzZSxcbiAgICAgIC8vIHNldCBhdXRob3JpdHkgYml0IGlmIG5lY2Vzc2FyeVxuICAgICAgdG9rZW5fZGF0YTogdXR4by5hdXRob3JpdGllcyA+IDAgPyBoYXRob3JMaWIuY29uc3RhbnRzLlRPS0VOX0FVVEhPUklUWV9NQVNLIDogMCxcbiAgICAgIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgc3BlbnRfYnkgYW5kIHNjcmlwdFxuICAgICAgc3BlbnRfYnk6IG51bGwsXG4gICAgICBzY3JpcHQ6ICcnLFxuICAgIH07XG4gIH0pO1xuXG4gIC8vIG1hcmsgYXMgdW5sb2NrZWQgaW4gZGF0YWJhc2UgKHRoaXMganVzdCBjaGFuZ2VzIHRoZSAnbG9ja2VkJyBmbGFnKVxuICBhd2FpdCBkYlVubG9ja1V0eG9zKG15c3FsLCB1dHhvcyk7XG5cbiAgY29uc3QgYWRkcmVzc0JhbGFuY2VNYXA6IFN0cmluZ01hcDxUb2tlbkJhbGFuY2VNYXA+ID0gZ2V0QWRkcmVzc0JhbGFuY2VNYXAoW10sIG91dHB1dHMpO1xuICAvLyB1cGRhdGUgYWRkcmVzc19iYWxhbmNlIHRhYmxlXG4gIGF3YWl0IHVwZGF0ZUFkZHJlc3NMb2NrZWRCYWxhbmNlKG15c3FsLCBhZGRyZXNzQmFsYW5jZU1hcCwgdXBkYXRlVGltZWxvY2tzKTtcblxuICAvLyBjaGVjayBpZiBhZGRyZXNzZXMgYmVsb25nIHRvIGFueSBzdGFydGVkIHdhbGxldFxuICBjb25zdCBhZGRyZXNzV2FsbGV0TWFwOiBTdHJpbmdNYXA8V2FsbGV0PiA9IGF3YWl0IGdldEFkZHJlc3NXYWxsZXRJbmZvKG15c3FsLCBPYmplY3Qua2V5cyhhZGRyZXNzQmFsYW5jZU1hcCkpO1xuXG4gIC8vIHVwZGF0ZSB3YWxsZXRfYmFsYW5jZSB0YWJsZVxuICBjb25zdCB3YWxsZXRCYWxhbmNlTWFwOiBTdHJpbmdNYXA8VG9rZW5CYWxhbmNlTWFwPiA9IGdldFdhbGxldEJhbGFuY2VNYXAoYWRkcmVzc1dhbGxldE1hcCwgYWRkcmVzc0JhbGFuY2VNYXApO1xuICBhd2FpdCB1cGRhdGVXYWxsZXRMb2NrZWRCYWxhbmNlKG15c3FsLCB3YWxsZXRCYWxhbmNlTWFwLCB1cGRhdGVUaW1lbG9ja3MpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHVubG9ja2VkL2xvY2tlZCBiYWxhbmNlcyBmb3IgYWRkcmVzc2VzIGFuZCB3YWxsZXRzIGNvbm5lY3RlZCB0byB0aGUgVVRYT3MgdGhhdCB3ZXJlIHVubG9ja2VkXG4gKiBiZWNhdXNlIG9mIHRoZWlyIHRpbWVsb2NrcyBleHBpcmluZ1xuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBub3cgLSBDdXJyZW50IHRpbWVzdGFtcFxuICovXG5leHBvcnQgY29uc3QgdW5sb2NrVGltZWxvY2tlZFV0eG9zID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIG5vdzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IHV0eG9zOiBEYlR4T3V0cHV0W10gPSBhd2FpdCBnZXRFeHBpcmVkVGltZWxvY2tzVXR4b3MobXlzcWwsIG5vdyk7XG5cbiAgYXdhaXQgdW5sb2NrVXR4b3MobXlzcWwsIHV0eG9zLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTWFyayBhIHRyYW5zYWN0aW9uJ3Mgb3V0cHV0cyB0aGF0IGFyZSBsb2NrZWQuIE1vZGlmaWVzIHRoZSBvdXRwdXRzIGluIHBsYWNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgdGltZXN0YW1wIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGVhY2ggb3V0cHV0IGlzIGxvY2tlZCBieSB0aW1lLiBPbiB0aGUgb3RoZXIgaGFuZCwgYGhhc0hlaWdodExvY2tgXG4gKiBhcHBsaWVzIHRvIGFsbCBvdXRwdXRzLlxuICpcbiAqIFRoZSBpZGVhIGlzIHRoYXQgYGhhc0hlaWdodExvY2sgPSB0cnVlYCBzaG91bGQgYmUgdXNlZCBmb3IgYmxvY2tzLCB3aG9zZSBvdXRwdXRzIGFyZSBsb2NrZWQgYnlcbiAqIGhlaWdodC4gVGltZWxvY2tzIGFyZSBoYW5kbGVkIGJ5IHRoZSBgbm93YCBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIG91dHB1dHMgLSBUaGUgdHJhbnNhY3Rpb24gb3V0cHV0c1xuICogQHBhcmFtIG5vdyAtIEN1cnJlbnQgdGltZXN0YW1wXG4gKiBAcGFyYW0gaGFzSGVpZ2h0TG9jayAtIEZsYWcgdGhhdCB0ZWxscyBpZiBvdXRwdXRzIGFyZSBsb2NrZWQgYnkgaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBtYXJrTG9ja2VkT3V0cHV0cyA9IChvdXRwdXRzOiBUeE91dHB1dFdpdGhJbmRleFtdLCBub3c6IG51bWJlciwgaGFzSGVpZ2h0TG9jayA9IGZhbHNlKTogdm9pZCA9PiB7XG4gIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICBvdXRwdXQubG9ja2VkID0gZmFsc2U7XG4gICAgaWYgKGhhc0hlaWdodExvY2sgfHwgb3V0cHV0LmRlY29kZWQudGltZWxvY2sgPiBub3cpIHtcbiAgICAgIG91dHB1dC5sb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1hcCBvZiB0b2tlbiBiYWxhbmNlcyBmb3IgZWFjaCBhZGRyZXNzIGluIHRoZSB0cmFuc2FjdGlvbiBpbnB1dHMgYW5kIG91dHB1dHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIFJldHVybiBtYXAgaGFzIHRoaXMgZm9ybWF0OlxuICogYGBgXG4gKiB7XG4gKiAgIGFkZHJlc3MxOiB7dG9rZW4xOiBiYWxhbmNlMSwgdG9rZW4yOiBiYWxhbmNlMn0sXG4gKiAgIGFkZHJlc3MyOiB7dG9rZW4xOiBiYWxhbmNlM31cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpbnB1dHMgLSBUaGUgdHJhbnNhY3Rpb24gaW5wdXRzXG4gKiBAcGFyYW0gb3V0cHV0cyAtIFRoZSB0cmFuc2FjdGlvbiBvdXRwdXRzXG4gKiBAcmV0dXJucyBBIG1hcCBvZiBhZGRyZXNzZXMgYW5kIGl0cyB0b2tlbiBiYWxhbmNlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0QWRkcmVzc0JhbGFuY2VNYXAgPSAoXG4gIGlucHV0czogVHhJbnB1dFtdLFxuICBvdXRwdXRzOiBUeE91dHB1dFtdLFxuKTogU3RyaW5nTWFwPFRva2VuQmFsYW5jZU1hcD4gPT4ge1xuICBjb25zdCBhZGRyZXNzQmFsYW5jZU1hcCA9IHt9O1xuXG4gIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IGlucHV0LmRlY29kZWQuYWRkcmVzcztcblxuICAgIC8vIGdldCB0aGUgVG9rZW5CYWxhbmNlTWFwIGZyb20gdGhpcyBpbnB1dFxuICAgIGNvbnN0IHRva2VuQmFsYW5jZU1hcCA9IFRva2VuQmFsYW5jZU1hcC5mcm9tVHhJbnB1dChpbnB1dCk7XG4gICAgLy8gbWVyZ2UgaXQgd2l0aCBleGlzdGluZyBUb2tlbkJhbGFuY2VNYXAgZm9yIHRoZSBhZGRyZXNzXG4gICAgYWRkcmVzc0JhbGFuY2VNYXBbYWRkcmVzc10gPSBUb2tlbkJhbGFuY2VNYXAubWVyZ2UoYWRkcmVzc0JhbGFuY2VNYXBbYWRkcmVzc10sIHRva2VuQmFsYW5jZU1hcCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG91dHB1dC5kZWNvZGVkLmFkZHJlc3M7XG5cbiAgICAvLyBnZXQgdGhlIFRva2VuQmFsYW5jZU1hcCBmcm9tIHRoaXMgb3V0cHV0XG4gICAgY29uc3QgdG9rZW5CYWxhbmNlTWFwID0gVG9rZW5CYWxhbmNlTWFwLmZyb21UeE91dHB1dChvdXRwdXQpO1xuXG4gICAgLy8gbWVyZ2UgaXQgd2l0aCBleGlzdGluZyBUb2tlbkJhbGFuY2VNYXAgZm9yIHRoZSBhZGRyZXNzXG4gICAgYWRkcmVzc0JhbGFuY2VNYXBbYWRkcmVzc10gPSBUb2tlbkJhbGFuY2VNYXAubWVyZ2UoYWRkcmVzc0JhbGFuY2VNYXBbYWRkcmVzc10sIHRva2VuQmFsYW5jZU1hcCk7XG4gIH1cblxuICByZXR1cm4gYWRkcmVzc0JhbGFuY2VNYXA7XG59O1xuXG4vKipcbiAqIEdldHMgYSBsaXN0IG9mIHRva2VucyBmcm9tIGEgbGlzdCBvZiBpbnB1dHMgYW5kIG91dHB1dHNcbiAqXG4gKiBAcGFyYW0gaW5wdXRzIC0gVGhlIHRyYW5zYWN0aW9uIGlucHV0c1xuICogQHBhcmFtIG91dHB1dHMgLSBUaGUgdHJhbnNhY3Rpb24gb3V0cHV0c1xuICogQHJldHVybnMgQSBsaXN0IG9mIHRva2VucyBwcmVzZW50IGluIHRoZSBpbnB1dHMgYW5kIG91dHB1dHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRva2VuTGlzdEZyb21JbnB1dHNBbmRPdXRwdXRzID0gKGlucHV0czogVHhJbnB1dFtdLCBvdXRwdXRzOiBUeE91dHB1dFdpdGhJbmRleFtdKTogc3RyaW5nW10gPT4ge1xuICBjb25zdCB0b2tlbklkcyA9IG5ldyBTZXQ8c3RyaW5nPihbXSk7XG5cbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICB0b2tlbklkcy5hZGQoaW5wdXQudG9rZW4pO1xuICB9XG5cbiAgZm9yIChjb25zdCBvdXRwdXQgb2Ygb3V0cHV0cykge1xuICAgIHRva2VuSWRzLmFkZChvdXRwdXQudG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIFsuLi50b2tlbklkc107XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWFwIG9mIHRva2VuIGJhbGFuY2VzIGZvciBlYWNoIHdhbGxldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogRGlmZmVyZW50IGFkZHJlc3NlcyBjYW4gYmVsb25nIHRvIHRoZSBzYW1lIHdhbGxldCwgc28gdGhpcyBmdW5jdGlvbiBtZXJnZXMgdGhlaXJcbiAqIHRva2VuIGJhbGFuY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBSZXR1cm4gbWFwIGhhcyB0aGlzIGZvcm1hdDpcbiAqIGBgYFxuICoge1xuICogICB3YWxsZXQxOiB7dG9rZW4xOiBiYWxhbmNlMSwgdG9rZW4yOiBiYWxhbmNlMn0sXG4gKiAgIHdhbGxldDI6IHt0b2tlbjE6IGJhbGFuY2UzfVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3NXYWxsZXRNYXAgLSBNYXAgb2YgYWRkcmVzc2VzIGFuZCBjb3JyZXNwb25kaW5nIHdhbGxldHNcbiAqIEBwYXJhbSBhZGRyZXNzQmFsYW5jZU1hcCAtIE1hcCBvZiBhZGRyZXNzZXMgYW5kIGNvcnJlc3BvbmRpbmcgdG9rZW4gYmFsYW5jZXNcbiAqIEByZXR1cm5zIEEgbWFwIG9mIHdhbGxldCBpZHMgYW5kIGl0cyB0b2tlbiBiYWxhbmNlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0V2FsbGV0QmFsYW5jZU1hcCA9IChcbiAgYWRkcmVzc1dhbGxldE1hcDogU3RyaW5nTWFwPFdhbGxldD4sXG4gIGFkZHJlc3NCYWxhbmNlTWFwOiBTdHJpbmdNYXA8VG9rZW5CYWxhbmNlTWFwPixcbik6IFN0cmluZ01hcDxUb2tlbkJhbGFuY2VNYXA+ID0+IHtcbiAgY29uc3Qgd2FsbGV0QmFsYW5jZU1hcCA9IHt9O1xuICBmb3IgKGNvbnN0IFthZGRyZXNzLCBiYWxhbmNlTWFwXSBvZiBPYmplY3QuZW50cmllcyhhZGRyZXNzQmFsYW5jZU1hcCkpIHtcbiAgICBjb25zdCB3YWxsZXQgPSBhZGRyZXNzV2FsbGV0TWFwW2FkZHJlc3NdO1xuICAgIGNvbnN0IHdhbGxldElkID0gd2FsbGV0ICYmIHdhbGxldC53YWxsZXRJZDtcblxuICAgIC8vIGlmIHRoaXMgYWRkcmVzcyBpcyBub3QgZnJvbSBhIHN0YXJ0ZWQgd2FsbGV0LCBpZ25vcmVcbiAgICBpZiAoIXdhbGxldElkKSBjb250aW51ZTtcblxuICAgIHdhbGxldEJhbGFuY2VNYXBbd2FsbGV0SWRdID0gVG9rZW5CYWxhbmNlTWFwLm1lcmdlKHdhbGxldEJhbGFuY2VNYXBbd2FsbGV0SWRdLCBiYWxhbmNlTWFwKTtcbiAgfVxuICByZXR1cm4gd2FsbGV0QmFsYW5jZU1hcDtcbn07XG5cbi8qKlxuICogR2V0IGEgd2FsbGV0J3MgYmFsYW5jZSwgdGFraW5nIGludG8gYWNjb3VudCBhbnkgZXhpc3RpbmcgdGltZWxvY2tzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiBhbnkgdGltZWxvY2sgaGFzIGV4cGlyZWQsIGRhdGFiYXNlIHRhYmxlcyB3aWxsIGJlIHJlZnJlc2hlZCBiZWZvcmUgcmV0dXJuaW5nIHRoZSBiYWxhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gbm93IC0gQ3VycmVudCB0aW1lc3RhbXBcbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSB0b2tlbklkcyAtIEEgbGlzdCBvZiB0b2tlbiBpZHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFdhbGxldEJhbGFuY2VzID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICBub3c6IG51bWJlcixcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdG9rZW5JZHM6IHN0cmluZ1tdID0gW10sXG4pOiBQcm9taXNlPFdhbGxldFRva2VuQmFsYW5jZVtdPiA9PiB7XG4gIGxldCBiYWxhbmNlcyA9IGF3YWl0IGRiR2V0V2FsbGV0QmFsYW5jZXMobXlzcWwsIHdhbGxldElkLCB0b2tlbklkcyk7XG5cbiAgLy8gaWYgYW55IG9mIHRoZSBiYWxhbmNlcycgdGltZWxvY2sgaGFzIGV4cGlyZWQsIHVwZGF0ZSB0aGUgdGFibGVzIGJlZm9yZSByZXR1cm5pbmdcbiAgY29uc3QgcmVmcmVzaEJhbGFuY2VzID0gYmFsYW5jZXMuc29tZSgodGIpID0+IHtcbiAgICBpZiAodGIuYmFsYW5jZS5sb2NrRXhwaXJlcyAmJiB0Yi5iYWxhbmNlLmxvY2tFeHBpcmVzIDw9IG5vdykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG5cbiAgaWYgKHJlZnJlc2hCYWxhbmNlcykge1xuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBhd2FpdCBnZXRMYXRlc3RIZWlnaHQobXlzcWwpO1xuICAgIGNvbnN0IHV0eG9zID0gYXdhaXQgZ2V0V2FsbGV0VW5sb2NrZWRVdHhvcyhteXNxbCwgd2FsbGV0SWQsIG5vdywgY3VycmVudEhlaWdodCk7XG4gICAgYXdhaXQgdW5sb2NrVXR4b3MobXlzcWwsIHV0eG9zLCB0cnVlKTtcbiAgICBiYWxhbmNlcyA9IGF3YWl0IGRiR2V0V2FsbGV0QmFsYW5jZXMobXlzcWwsIHdhbGxldElkLCB0b2tlbklkcyk7XG4gIH1cbiAgcmV0dXJuIGJhbGFuY2VzO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB3YWxsZXQtbGliIGNvbnN0YW50cyBpZiBuZWVkZWQuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHdhbGxldC1saWIgY29uc3RhbnRzIGhhdmUgYmVlbiBzZXQuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXliZVJlZnJlc2hXYWxsZXRDb25zdGFudHMgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBsYXN0VmVyc2lvbkRhdGE6IEZ1bGxOb2RlVmVyc2lvbkRhdGEgPSBhd2FpdCBnZXRWZXJzaW9uRGF0YShteXNxbCk7XG4gIGNvbnN0IG5vdyA9IGdldFVuaXhUaW1lc3RhbXAoKTtcblxuICBpZiAoIWxhc3RWZXJzaW9uRGF0YSB8fCBub3cgLSBsYXN0VmVyc2lvbkRhdGEudGltZXN0YW1wID4gVkVSU0lPTl9DSEVDS19NQVhfRElGRikge1xuICAgIC8vIFF1ZXJ5IGFuZCB1cGRhdGUgdmVyc2lvbnNcbiAgICBjb25zdCBhcGlSZXNwb25zZSA9IGF3YWl0IGhhdGhvckxpYi52ZXJzaW9uLmNoZWNrQXBpVmVyc2lvbigpO1xuICAgIGNvbnN0IHZlcnNpb25EYXRhOiBGdWxsTm9kZVZlcnNpb25EYXRhID0ge1xuICAgICAgdGltZXN0YW1wOiBub3csXG4gICAgICB2ZXJzaW9uOiBhcGlSZXNwb25zZS52ZXJzaW9uLFxuICAgICAgbmV0d29yazogYXBpUmVzcG9uc2UubmV0d29yayxcbiAgICAgIG1pbldlaWdodDogYXBpUmVzcG9uc2UubWluX3dlaWdodCxcbiAgICAgIG1pblR4V2VpZ2h0OiBhcGlSZXNwb25zZS5taW5fdHhfd2VpZ2h0LFxuICAgICAgbWluVHhXZWlnaHRDb2VmZmljaWVudDogYXBpUmVzcG9uc2UubWluX3R4X3dlaWdodF9jb2VmZmljaWVudCxcbiAgICAgIG1pblR4V2VpZ2h0SzogYXBpUmVzcG9uc2UubWluX3R4X3dlaWdodF9rLFxuICAgICAgdG9rZW5EZXBvc2l0UGVyY2VudGFnZTogYXBpUmVzcG9uc2UudG9rZW5fZGVwb3NpdF9wZXJjZW50YWdlLFxuICAgICAgcmV3YXJkU3BlbmRNaW5CbG9ja3M6IGFwaVJlc3BvbnNlLnJld2FyZF9zcGVuZF9taW5fYmxvY2tzLFxuICAgICAgbWF4TnVtYmVySW5wdXRzOiBhcGlSZXNwb25zZS5tYXhfbnVtYmVyX2lucHV0cyxcbiAgICAgIG1heE51bWJlck91dHB1dHM6IGFwaVJlc3BvbnNlLm1heF9udW1iZXJfb3V0cHV0cyxcbiAgICB9O1xuXG4gICAgYXdhaXQgdXBkYXRlVmVyc2lvbkRhdGEobXlzcWwsIHZlcnNpb25EYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBoYXRob3JMaWIudHJhbnNhY3Rpb24udXBkYXRlVHJhbnNhY3Rpb25XZWlnaHRDb25zdGFudHMoXG4gICAgICBsYXN0VmVyc2lvbkRhdGEubWluVHhXZWlnaHQsXG4gICAgICBsYXN0VmVyc2lvbkRhdGEubWluVHhXZWlnaHRDb2VmZmljaWVudCxcbiAgICAgIGxhc3RWZXJzaW9uRGF0YS5taW5UeFdlaWdodEssXG4gICAgKTtcbiAgICBoYXRob3JMaWIudG9rZW5zLnVwZGF0ZURlcG9zaXRQZXJjZW50YWdlKGxhc3RWZXJzaW9uRGF0YS50b2tlbkRlcG9zaXRQZXJjZW50YWdlKTtcbiAgICBoYXRob3JMaWIudHJhbnNhY3Rpb24udXBkYXRlTWF4SW5wdXRzQ29uc3RhbnQobGFzdFZlcnNpb25EYXRhLm1heE51bWJlcklucHV0cyk7XG4gICAgaGF0aG9yTGliLnRyYW5zYWN0aW9uLnVwZGF0ZU1heE91dHB1dHNDb25zdGFudChsYXN0VmVyc2lvbkRhdGEubWF4TnVtYmVyT3V0cHV0cyk7XG4gICAgaGF0aG9yTGliLndhbGxldC51cGRhdGVSZXdhcmRMb2NrQ29uc3RhbnQobGFzdFZlcnNpb25EYXRhLnJld2FyZFNwZW5kTWluQmxvY2tzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZWFyY2hlcyBvdXIgYmxvY2tzIGRhdGFiYXNlIGZvciB0aGUgbGFzdCBibG9jayB0aGF0IGlzIG5vdCB2b2lkZWQuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIEEgQmxvY2sgaW5zdGFuY2Ugd2l0aCB0aGUgbGFzdCBibG9jayB0aGF0IGlzIG5vdCB2b2lkZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWFyY2hGb3JMYXRlc3RWYWxpZEJsb2NrID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwpOiBQcm9taXNlPEJsb2NrPiA9PiB7XG4gIC8vIEdldCBvdXIgY3VycmVudCBiZXN0IGJsb2NrLlxuICBjb25zdCBsYXRlc3RIZWlnaHQ6IG51bWJlciA9IGF3YWl0IGdldExhdGVzdEhlaWdodChteXNxbCk7XG4gIGNvbnN0IGJlc3RCbG9jazogQmxvY2sgPSBhd2FpdCBnZXRCbG9ja0J5SGVpZ2h0KG15c3FsLCBsYXRlc3RIZWlnaHQpO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBiZXN0QmxvY2suaGVpZ2h0O1xuICBsZXQgbGF0ZXN0VmFsaWRCbG9jayA9IGJlc3RCbG9jaztcblxuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgY29uc3QgbWlkSGVpZ2h0ID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgYmxvY2sgYXQgbWlkZGxlIHBvc2l0aW9uIGlzIHZvaWRlZFxuICAgIGNvbnN0IG1pZGRsZUJsb2NrOiBCbG9jayA9IGF3YWl0IGdldEJsb2NrQnlIZWlnaHQobXlzcWwsIG1pZEhlaWdodCk7XG4gICAgY29uc3QgW2lzVm9pZGVkXSA9IGF3YWl0IGlzVHhWb2lkZWQobWlkZGxlQmxvY2sudHhJZCk7XG5cbiAgICBpZiAoIWlzVm9pZGVkKSB7XG4gICAgICAvLyBOb3Qgdm9pZGVkLCBkaXNjYXJkIGxlZnQgaGFsZiBhcyBhbGwgYmxvY2tzIHRvIHRoZSBsZWZ0IHNob3VsZFxuICAgICAgLy8gYmUgdmFsaWQsIHRoZSByZW9yZyBoYXBwZW5lZCBhZnRlciB0aGlzIGhlaWdodC5cbiAgICAgIGxhdGVzdFZhbGlkQmxvY2sgPSBtaWRkbGVCbG9jaztcbiAgICAgIHN0YXJ0ID0gbWlkSGVpZ2h0ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gbWlkSGVpZ2h0IC0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGF0ZXN0VmFsaWRCbG9jaztcbn07XG5cbi8qXG4gKiBSZWNlaXZlcyBhIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIGJlaW5nIHZvaWRlZCBvbiBhIHJlb3JnIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgdGhhdCBzcGVuZCB0aGVtLlxuICpcbiAqIEFsc28gbWFya3Mgd2FsbGV0IGFuZCBhZGRyZXNzZXMgaGlzdG9yeSB0aGF0IHVzZSB0aGlzIHRyYW5zYWN0aW9uIGFzIHZvaWRlZFxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eHMgLSBMaXN0IG9mIHZvaWRlZCB0cmFuc2FjdGlvbnMgdG8gaGFuZGxlXG4gKlxuICogQHJldHVybnMgQSBuZXcgbGlzdCBvZiB2b2lkZWQgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIGxpbmtlZCB0byB0aGUgcmVjZWl2ZWQgbGlzdCBhbmQgYSBsaXN0IG9mIHR4X291dHB1dHMgYWZmZWN0ZWRcbiAqIGJ5IHRoaXMgaXRlcmF0aW9uLlxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlVm9pZGVkVHhMaXN0ID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIGxvZ2dlcjogTG9nZ2VyLCB0eHM6IFR4W10pOiBQcm9taXNlPFtUeFtdLCBEYlR4T3V0cHV0W11dPiA9PiB7XG4gIGxvZ2dlci5kZWJ1ZyhgU2V0dGluZyAke3R4cy5sZW5ndGh9IHRyYW5zYWN0aW9ucyBhcyB2b2lkZWQuYCwge1xuICAgIHRyYW5zYWN0aW9uczogdHhzLFxuICB9KTtcbiAgYXdhaXQgbWFya1R4c0FzVm9pZGVkKG15c3FsLCB0eHMpO1xuICBsb2dnZXIuZGVidWcoYFNldHRpbmcgV2FsbGV0VHhIaXN0b3J5IGFzIHZvaWRlZCBmcm9tICR7dHhzLmxlbmd0aH0gdHJhbnNhY3Rpb25zLmApO1xuICBhd2FpdCBtYXJrV2FsbGV0VHhIaXN0b3J5QXNWb2lkZWQobXlzcWwsIHR4cyk7XG4gIGxvZ2dlci5kZWJ1ZyhgU2V0dGluZyBBZGRyZXNzVHhIaXN0b3J5IGFzIHZvaWRlZCBmcm9tICR7dHhzLmxlbmd0aH0gdHJhbnNhY3Rpb25zLmApO1xuICBhd2FpdCBtYXJrQWRkcmVzc1R4SGlzdG9yeUFzVm9pZGVkKG15c3FsLCB0eHMpO1xuXG4gIC8vIHR4IG91dHB1dHMgYXJlIHRoZSBsaXN0IG9mIGFsbCBvdXRwdXRzIGluIHRoZSB0cmFuc2FjdGlvbiBsaXN0XG4gIGNvbnN0IHR4T3V0cHV0czogRGJUeE91dHB1dFtdID0gYXdhaXQgZ2V0VHhPdXRwdXRzKG15c3FsLCB0eHMpO1xuXG4gIGxvZ2dlci5kZWJ1ZyhgRmV0Y2hlZCAke3R4T3V0cHV0cy5sZW5ndGh9IHV0eG9zIGZyb20gdGhlIHZvaWRlZCB0cmFuc2FjdGlvbiBsaXN0YCwge1xuICAgIHR4T3V0cHV0cyxcbiAgfSk7XG5cbiAgLy8gZ2V0IG91dHB1dHMgdGhhdCB3ZXJlIHNwZW50IGluIHR4T3V0cHV0c1xuICBjb25zdCB0eE91dHB1dHNUeElkczogU2V0PHN0cmluZz4gPSB0eE91dHB1dHMucmVkdWNlKFxuICAgIChhY2M6IFNldDxzdHJpbmc+LCB0eE91dHB1dDogRGJUeE91dHB1dCkgPT4gYWNjLmFkZCh0eE91dHB1dC50eElkKSxcbiAgICBuZXcgU2V0PHN0cmluZz4oKSxcbiAgKTtcblxuICAvLyBzcGVudCBvdXRwdXRzIGFyZSB0aGUgbGlzdCBvZiBvdXRwdXRzIHRoYXQgd2VyZSBzcGVudCBieSB0aG9zZSB0eF9vdXRwdXRzXG4gIGNvbnN0IHNwZW50T3V0cHV0czogRGJUeE91dHB1dFtdID0gYXdhaXQgZ2V0VHhPdXRwdXRzQnlTcGVudChteXNxbCwgWy4uLnR4T3V0cHV0c1R4SWRzXSk7XG5cbiAgLy8gdW5zcGVuZCB0aGVtIGFzIHRoZSB0eF9vdXRwdXRzIHRoYXQgc3BlbnQgdGhlbSBhcmUgbm93IHZvaWRlZFxuICBpZiAoc3BlbnRPdXRwdXRzLmxlbmd0aCA+IDApIHtcbiAgICBsb2dnZXIuZGVidWcoYFVuc3BlbmRpbmcgJHtzcGVudE91dHB1dHMubGVuZ3RofSB0eF9vdXRwdXRzLmAsIHtcbiAgICAgIHR4T3V0cHV0czogc3BlbnRPdXRwdXRzLFxuICAgIH0pO1xuICAgIGF3YWl0IHVuc3BlbmRVdHhvcyhteXNxbCwgWy4uLnNwZW50T3V0cHV0c10pO1xuICB9XG5cbiAgY29uc3QgYWZmZWN0ZWRVdHhvTGlzdCA9IFsuLi50eE91dHB1dHMsIC4uLnNwZW50T3V0cHV0c107XG5cbiAgLy8gbWFyayB0aGUgdHhfb3V0cHV0cyBmcm9tIHRoZSByZWNlaXZlZCB0eCBsaXN0IGFzIHZvaWRlZFxuICBsb2dnZXIuZGVidWcoYFNldHRpbmcgJHt0eE91dHB1dHMubGVuZ3RofSB0eF9vdXRwdXRzIGFzIHZvaWRlZC5gLCB7XG4gICAgdHhPdXRwdXRzLFxuICB9KTtcbiAgYXdhaXQgbWFya1V0eG9zQXNWb2lkZWQobXlzcWwsIHR4T3V0cHV0cyk7XG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIHR4IGlkcyB0aGF0IHNwZW5kIHRoZSB0eF9vdXRwdXRzIGxpc3QgZnJvbSB0aGUgcmVjZWl2ZWQgdHggbGlzdFxuICBjb25zdCB0eElkcyA9IHR4T3V0cHV0cy5yZWR1Y2UoKGFjYzogU2V0PHN0cmluZz4sIHV0eG86IERiVHhPdXRwdXQpID0+IHtcbiAgICBpZiAodXR4by5zcGVudEJ5KSB7XG4gICAgICBhY2MuYWRkKHV0eG8uc3BlbnRCeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgbmV3IFNldDxzdHJpbmc+KCkpO1xuXG4gIC8vIGZldGNoIGFsbCB0cmFuc2FjdGlvbnMgdGhhdCBzcGVuZCB0aG9zZSB2b2lkZWQgdHhzIG91dHB1dHM6XG4gIGNvbnN0IG5ld1R4cyA9IGF3YWl0IGdldFRyYW5zYWN0aW9uc0J5SWQobXlzcWwsIFsuLi50eElkc10pO1xuXG4gIGxvZ2dlci5kZWJ1ZyhgRmV0Y2hlZCAke25ld1R4cy5sZW5ndGh9IHRyYW5zYWN0aW9ucyB0aGF0IHNwZW5kIHRoZSB2b2lkZWQgdHggb3V0cHV0cyBsaXN0YCwge1xuICAgIHRyYW5zYWN0aW9uczogbmV3VHhzLFxuICB9KTtcblxuICByZXR1cm4gW25ld1R4cywgYWZmZWN0ZWRVdHhvTGlzdF07XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSB2b2lkZWQgdHJhbnNhY3Rpb24gYnkgcmUtY2FsY3VsYXRpbmcgdGhlIGJhbGFuY2VzIGZvciBhbGwgYWZmZWN0ZWQgYWRkcmVzc2VzIGFmdGVyXG4gKiByZW1vdmluZyB0aGUgdHhcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHggLSBUaGUgdm9pZGVkIHRyYW5zYWN0aW9uIHRvIHJlbW92ZVxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlVm9pZGVkID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIGxvZ2dlcjogTG9nZ2VyLCB0eDogVHgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgbGV0IHR4czogVHhbXSA9IFt0eF07XG4gIGxldCBhZmZlY3RlZFV0eG9MaXN0OiBEYlR4T3V0cHV0W10gPSBbXTtcblxuICB3aGlsZSAodHhzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbbmV3VHhzLCBuZXdBZmZlY3RlZFV0eG9MaXN0XSA9IGF3YWl0IGhhbmRsZVZvaWRlZFR4TGlzdChteXNxbCwgbG9nZ2VyLCB0eHMpO1xuICAgIHR4cyA9IG5ld1R4cztcbiAgICBhZmZlY3RlZFV0eG9MaXN0ID0gWy4uLmFmZmVjdGVkVXR4b0xpc3QsIC4uLm5ld0FmZmVjdGVkVXR4b0xpc3RdO1xuICB9XG5cbiAgLy8gZmV0Y2ggYWxsIGFkZHJlc3NlcyBhbmQgdHJhbnNhY3Rpb25zIGFmZmVjdGVkIGJ5IHRoZSB2b2lkZWQgdHJhbnNhY3Rpb25cbiAgY29uc3QgW2FmZmVjdGVkQWRkcmVzc2VzLCBhZmZlY3RlZFR4SWRzXSA9IGFmZmVjdGVkVXR4b0xpc3QucmVkdWNlKFxuICAgIChhY2M6IFtTZXQ8c3RyaW5nPiwgU2V0PHN0cmluZz5dLCB1dHhvOiBEYlR4T3V0cHV0KSA9PiB7XG4gICAgICBhY2NbMF0uYWRkKHV0eG8uYWRkcmVzcyk7XG4gICAgICBhY2NbMV0uYWRkKHV0eG8udHhJZCk7XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICBbbmV3IFNldDxzdHJpbmc+KCksIG5ldyBTZXQ8c3RyaW5nPigpXSxcbiAgKTtcblxuICBpZiAoYWZmZWN0ZWRBZGRyZXNzZXMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBbLi4uYWZmZWN0ZWRBZGRyZXNzZXNdO1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBSZWJ1aWxkaW5nIGJhbGFuY2VzIGZvciAke2FkZHJlc3Nlcy5sZW5ndGh9IGFkZHJlc3Nlcy5gLCB7XG4gICAgICBhZGRyZXNzZXMsXG4gICAgfSk7XG4gICAgbG9nZ2VyLmRlYnVnKGBSZWJ1aWxkaW5nIHR4IGNvdW50IGZyb20gJHthZmZlY3RlZFR4SWRzLnNpemV9IHRyYW5zYWN0aW9uc2AsIHtcbiAgICAgIGFmZmVjdGVkVHhJZHMsXG4gICAgfSk7XG4gICAgYXdhaXQgcmVidWlsZEFkZHJlc3NCYWxhbmNlc0Zyb21VdHhvcyhteXNxbCwgYWRkcmVzc2VzLCBbLi4uYWZmZWN0ZWRUeElkc10pO1xuICAgIGF3YWl0IHZhbGlkYXRlQWRkcmVzc0JhbGFuY2VzKG15c3FsLCBhZGRyZXNzZXMpO1xuICB9XG5cbiAgbG9nZ2VyLmRlYnVnKCdIYW5kbGUgdm9pZGVkIHR4IGlzIGRvbmUuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBZGRyZXNzQmFsYW5jZXMgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgYWRkcmVzc2VzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBhZGRyZXNzQmFsYW5jZXM6IEFkZHJlc3NCYWxhbmNlW10gPSBhd2FpdCBmZXRjaEFkZHJlc3NCYWxhbmNlKG15c3FsLCBhZGRyZXNzZXMpO1xuICBjb25zdCBhZGRyZXNzVHhIaXN0b3J5U3VtczogQWRkcmVzc1RvdGFsQmFsYW5jZVtdID0gYXdhaXQgZmV0Y2hBZGRyZXNzVHhIaXN0b3J5U3VtKG15c3FsLCBhZGRyZXNzZXMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc1R4SGlzdG9yeVN1bXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhZGRyZXNzQmFsYW5jZTogQWRkcmVzc0JhbGFuY2UgPSBhZGRyZXNzQmFsYW5jZXNbaV07XG4gICAgY29uc3QgYWRkcmVzc1R4SGlzdG9yeVN1bTogQWRkcmVzc1RvdGFsQmFsYW5jZSA9IGFkZHJlc3NUeEhpc3RvcnlTdW1zW2ldO1xuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKGFkZHJlc3NCYWxhbmNlLnRva2VuSWQsIGFkZHJlc3NUeEhpc3RvcnlTdW0udG9rZW5JZCk7XG5cbiAgICAvLyBiYWxhbmNlcyBtdXN0IG1hdGNoXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKGFkZHJlc3NCYWxhbmNlLnVubG9ja2VkQmFsYW5jZSArIGFkZHJlc3NCYWxhbmNlLmxvY2tlZEJhbGFuY2UsIGFkZHJlc3NUeEhpc3RvcnlTdW0uYmFsYW5jZSk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHJlb3JnIGJ5IGZpbmRpbmcgdGhlIGxhc3QgdmFsaWQgYmxvY2sgb24gdGhlIHNlcnZpY2UncyBkYXRhYmFzZSBhbmRcbiAqIHJlbW92aW5nIHRyYW5zYWN0aW9ucyBhbmQgdHhfb3V0cHV0cyBiZWZvcmUgcmUtY2FsY3VsYXRpbmcgdGhlIGFkZHJlc3MgYmFsYW5jZXMuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgYmVzdCBibG9jayBoZWlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IGhhbmRsZVJlb3JnID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIGxvZ2dlcjogTG9nZ2VyKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgY29uc3QgeyBoZWlnaHQgfSA9IGF3YWl0IHNlYXJjaEZvckxhdGVzdFZhbGlkQmxvY2sobXlzcWwpO1xuICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gYXdhaXQgZ2V0TGF0ZXN0SGVpZ2h0KG15c3FsKTtcblxuICBsb2dnZXIuZGVidWcoYEhhbmRsaW5nIHJlb3JnLiBPdXIgbGF0ZXN0IHZhbGlkIGJsb2NrIGlzICR7aGVpZ2h0fSBhbmQgb3VyIGhpZ2hlc3QgYmxvY2sgaGVpZ2h0IGlzICR7Y3VycmVudEhlaWdodH1gLCB7XG4gICAgaGVpZ2h0LFxuICAgIGN1cnJlbnRIZWlnaHQsXG4gIH0pO1xuXG4gIGlmICgoY3VycmVudEhlaWdodCAtIGhlaWdodCkgPiBXQVJOX01BWF9SRU9SR19TSVpFKSB7XG4gICAgbG9nZ2VyLmVycm9yKGBBIHJlb3JnIHdpdGggJHtjdXJyZW50SGVpZ2h0IC0gaGVpZ2h0fSBibG9ja3MgaGFzIGJlZW4gZGV0ZWN0ZWRgKTtcbiAgICBhd2FpdCBhZGRBbGVydChcbiAgICAgICdCaWcgcmVvcmcgZGV0ZWN0ZWQnLFxuICAgICAgYEEgcmVvcmcgd2l0aCAke2N1cnJlbnRIZWlnaHQgLSBoZWlnaHR9IGJsb2NrcyBoYXMgYmVlbiBkZXRlY3RlZGAsXG4gICAgICBTZXZlcml0eS5NSU5PUixcbiAgICAgIHsgd2FsbGV0U2VydmljZUhlaWdodDogY3VycmVudEhlaWdodCwgZnVsbE5vZGVIZWlnaHQ6IGhlaWdodCB9LFxuICAgICk7XG4gIH1cblxuICAvLyBmZXRjaCBhbGwgYmxvY2sgdHJhbnNhY3Rpb25zIHdoZXJlIGhlaWdodCA+IGxhdGVzdFZhbGlkQmxvY2tcbiAgY29uc3QgYWxsVHhzQWZ0ZXJIZWlnaHQgPSBhd2FpdCBnZXRUeHNBZnRlckhlaWdodChteXNxbCwgaGVpZ2h0KTtcbiAgbGV0IHR4czogVHhbXSA9IGFsbFR4c0FmdGVySGVpZ2h0LmZpbHRlcigodHgpID0+IFtcbiAgICBoYXRob3JMaWIuY29uc3RhbnRzLkJMT0NLX1ZFUlNJT04sXG4gICAgaGF0aG9yTGliLmNvbnN0YW50cy5NRVJHRURfTUlORURfQkxPQ0tfVkVSU0lPTixcbiAgXS5pbmRleE9mKHR4LnZlcnNpb24pID4gLTEpO1xuXG4gIC8vIHJlbW92ZSBibG9ja3Mgd2hlcmUgaGVpZ2h0ID4gbGF0ZXN0VmFsaWRCbG9jayBhcyB3ZSBhbHJlYWR5IGhhdmUgdGhlbSBvbiBtZW1vcnlcbiAgYXdhaXQgZGVsZXRlQmxvY2tzQWZ0ZXJIZWlnaHQobXlzcWwsIGhlaWdodCk7XG5cbiAgbG9nZ2VyLmRlYnVnKCdSZW1vdmluZyB0cmFuc2FjdGlvbnMnLCB0eHMubWFwKCh0eCkgPT4gdHgudHhJZCkpO1xuXG4gIGxldCBhZmZlY3RlZFV0eG9MaXN0OiBEYlR4T3V0cHV0W10gPSBbXTtcblxuICAvKlxuICAgKiBIZXJlIHdlIG5lZWQgdG8gdHJhdmVyc2UgdGhlIERBRyBvZiBcImZ1bmRzXCIsIHN0YXJ0aW5nIGZyb20gdGhlIHZvaWRlZCB0eF9vdXRwdXRzIGZyb20gdGhlIGJsb2Nrc1xuICAgKiBhbmQgc3RvcHBpbmcgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBsaW5rZWQgdHhfb3V0cHV0cyB2b2lkZWQuXG4gICAqXG4gICAqIFdlIGRvIHRoYXQgYnkgdXNpbmcgYSBCRlMsIHRoYXQgbXV0YXRlcyB0aGUgREFHIG9uIGV2ZXJ5IGl0ZXJhdGlvbiAoYnkgc2V0dGluZyB0aGUgdHJhbnNhY3Rpb25zXG4gICAqIGFzIHZvaWRlZCBvbiB0aGUgZGF0YWJhc2UpLlxuICAgKi9cbiAgd2hpbGUgKHR4cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW25ld1R4cywgbmV3QWZmZWN0ZWRVdHhvTGlzdF0gPSBhd2FpdCBoYW5kbGVWb2lkZWRUeExpc3QobXlzcWwsIGxvZ2dlciwgdHhzKTtcblxuICAgIHR4cyA9IG5ld1R4cztcbiAgICBhZmZlY3RlZFV0eG9MaXN0ID0gWy4uLmFmZmVjdGVkVXR4b0xpc3QsIC4uLm5ld0FmZmVjdGVkVXR4b0xpc3RdO1xuICB9XG5cbiAgLy8gZ2V0IGFsbCByZW1haW5pbmcgdHhzIGFuZCBzZXQgaGVpZ2h0ID0gbnVsbCAobWVtcG9vbClcbiAgY29uc3QgcmVtYWluaW5nVHhzOiBUeFtdID0gYXdhaXQgZ2V0VHhzQWZ0ZXJIZWlnaHQobXlzcWwsIGhlaWdodCk7XG4gIGlmIChyZW1haW5pbmdUeHMubGVuZ3RoID4gMCkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgU2V0dGluZyAke3JlbWFpbmluZ1R4cy5sZW5ndGh9IHVuY29uZmlybWVkIHRyYW5zYWN0aW9ucyB0byB0aGUgbWVtcG9vbCAoaGVpZ2h0ID0gTlVMTCkuYCwge1xuICAgICAgcmVtYWluaW5nVHhzLFxuICAgIH0pO1xuICAgIGF3YWl0IHJlbW92ZVR4c0hlaWdodChteXNxbCwgcmVtYWluaW5nVHhzKTtcbiAgfVxuXG4gIC8vIGZldGNoIGFsbCBhZGRyZXNzZXMgYW5kIHRyYW5zYWN0aW9ucyBhZmZlY3RlZCBieSB0aGUgcmVvcmdcbiAgY29uc3QgW2FmZmVjdGVkQWRkcmVzc2VzLCBhZmZlY3RlZFR4SWRzXSA9IGFmZmVjdGVkVXR4b0xpc3QucmVkdWNlKFxuICAgIChhY2M6IFtTZXQ8c3RyaW5nPiwgU2V0PHN0cmluZz5dLCB1dHhvOiBEYlR4T3V0cHV0KSA9PiB7XG4gICAgICBhY2NbMF0uYWRkKHV0eG8uYWRkcmVzcyk7XG4gICAgICBhY2NbMV0uYWRkKHV0eG8udHhJZCk7XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICBbbmV3IFNldDxzdHJpbmc+KCksIG5ldyBTZXQ8c3RyaW5nPigpXSxcbiAgKTtcblxuICBpZiAoYWZmZWN0ZWRBZGRyZXNzZXMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBbLi4uYWZmZWN0ZWRBZGRyZXNzZXNdO1xuICAgIGxvZ2dlci5kZWJ1ZyhgUmVidWlsZGluZyBiYWxhbmNlcyBmb3IgJHthZGRyZXNzZXMubGVuZ3RofSBhZGRyZXNzZXMuYCwge1xuICAgICAgYWRkcmVzc2VzLFxuICAgIH0pO1xuICAgIGxvZ2dlci5kZWJ1ZyhgUmVidWlsZGluZyB0eCBjb3VudCBmcm9tICR7YWZmZWN0ZWRUeElkcy5zaXplfSB0cmFuc2FjdGlvbnNgLCB7XG4gICAgICBhZmZlY3RlZFR4SWRzLFxuICAgIH0pO1xuICAgIGF3YWl0IHJlYnVpbGRBZGRyZXNzQmFsYW5jZXNGcm9tVXR4b3MobXlzcWwsIGFkZHJlc3NlcywgWy4uLmFmZmVjdGVkVHhJZHNdKTtcbiAgICBhd2FpdCB2YWxpZGF0ZUFkZHJlc3NCYWxhbmNlcyhteXNxbCwgYWRkcmVzc2VzKTtcbiAgfVxuXG4gIGxvZ2dlci5kZWJ1ZygnUmVvcmcgaXMgZG9uZS4nKTtcblxuICByZXR1cm4gaGVpZ2h0O1xufTtcblxuZXhwb3J0IGNvbnN0IHdhbGxldElkUHJveHlIYW5kbGVyID0gKGhhbmRsZXI6IFdhbGxldFByb3h5SGFuZGxlcik6IEFQSUdhdGV3YXlQcm94eUhhbmRsZXIgPT4gKFxuICBhc3luYyAoZXZlbnQsIGNvbnRleHQpID0+IHtcbiAgICBsZXQgd2FsbGV0SWQ6IHN0cmluZztcbiAgICB0cnkge1xuICAgICAgd2FsbGV0SWQgPSBldmVudC5yZXF1ZXN0Q29udGV4dC5hdXRob3JpemVyLnByaW5jaXBhbElkO1xuICAgICAgLy8gdmFsaWRhdGUgd2FsbGV0SWQ/XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzQ29kZTogNDAxLFxuICAgICAgICBib2R5OiAnVW5hdXRob3JpemVkJyxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyKHdhbGxldElkLCBldmVudCwgY29udGV4dCk7XG4gIH1cbik7XG5cbmV4cG9ydCBjb25zdCBwcmVwYXJlT3V0cHV0cyA9IChvdXRwdXRzOiBUeE91dHB1dFtdLCB0eElkOiBzdHJpbmcsIGxvZ2dlcjogTG9nZ2VyKTogVHhPdXRwdXRXaXRoSW5kZXhbXSA9PiB7XG4gIGNvbnN0IHByZXBhcmVkT3V0cHV0czogW251bWJlciwgVHhPdXRwdXRXaXRoSW5kZXhbXV0gPSBvdXRwdXRzLnJlZHVjZShcbiAgICAoW2N1cnJJbmRleCwgbmV3T3V0cHV0c106IFtudW1iZXIsIFR4T3V0cHV0V2l0aEluZGV4W11dLCBvdXRwdXQ6IFR4T3V0cHV0KTogW251bWJlciwgVHhPdXRwdXRXaXRoSW5kZXhbXV0gPT4ge1xuICAgICAgaWYgKCFvdXRwdXQuZGVjb2RlZFxuICAgICAgICAgIHx8IG91dHB1dC5kZWNvZGVkLnR5cGUgPT09IG51bGxcbiAgICAgICAgICB8fCBvdXRwdXQuZGVjb2RlZC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYElnbm9yaW5nIHR4IG91dHB1dCB3aXRoIGluZGV4ICR7Y3VyckluZGV4fSBmcm9tIHR4ICR7dHhJZH0gYXMgc2NyaXB0IGNvdWxkbid0IGJlIGRlY29kZWQuYCk7XG4gICAgICAgIHJldHVybiBbY3VyckluZGV4ICsgMSwgbmV3T3V0cHV0c107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGN1cnJJbmRleCArIDEsXG4gICAgICAgIFtcbiAgICAgICAgICAuLi5uZXdPdXRwdXRzLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLm91dHB1dCxcbiAgICAgICAgICAgIGluZGV4OiBjdXJySW5kZXgsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIF07XG4gICAgfSxcbiAgICBbMCwgW11dLFxuICApO1xuXG4gIHJldHVybiBwcmVwYXJlZE91dHB1dHNbMV07XG59O1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2Ygd2FsbGV0IGJhbGFuY2UgcGVyIHRva2VuIGJ5IGluZm9ybWVkIHRyYW5zYWN0aW9uLlxuICpcbiAqIEBwYXJhbSBteXNxbFxuICogQHBhcmFtIHR4IC0gVGhlIHRyYW5zYWN0aW9uIHRvIGdldCByZWxhdGVkIHdhbGxldHMgYW5kIHRoZWlyIHRva2VuIGJhbGFuY2VzXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgY29uc3QgZ2V0V2FsbGV0QmFsYW5jZXNGb3JUeCA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCB0eDogVHJhbnNhY3Rpb24pOiBQcm9taXNlPFN0cmluZ01hcDxXYWxsZXRCYWxhbmNlVmFsdWU+PiA9PiB7XG4gIGNvbnN0IGFkZHJlc3NCYWxhbmNlTWFwOiBTdHJpbmdNYXA8VG9rZW5CYWxhbmNlTWFwPiA9IGdldEFkZHJlc3NCYWxhbmNlTWFwKHR4LmlucHV0cywgdHgub3V0cHV0cyk7XG4gIC8vIHJldHVybiBvbmx5IHdhbGxldHMgdGhhdCB3ZXJlIHN0YXJ0ZWRcbiAgY29uc3QgYWRkcmVzc1dhbGxldE1hcDogU3RyaW5nTWFwPFdhbGxldD4gPSBhd2FpdCBnZXRBZGRyZXNzV2FsbGV0SW5mbyhteXNxbCwgT2JqZWN0LmtleXMoYWRkcmVzc0JhbGFuY2VNYXApKTtcblxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGZvY3VzZWQgb24gdGhlIHdhbGxldElkIGFuZCBzdG9yaW5nIGl0cyBiYWxhbmNlIHZhcmlhdGlvbiBmcm9tIHRoaXMgdHhcbiAgY29uc3Qgd2FsbGV0c01hcDogU3RyaW5nTWFwPFdhbGxldEJhbGFuY2U+ID0ge307XG5cbiAgLy8gQWNjdW11bGF0aW9uIG9mIHRva2VuSWQgdG8gYmUgdXNlZCB0byBleHRyYWN0IGl0cyBzeW1ib2xzLlxuICBjb25zdCB0b2tlbklkQWNjdW11bGF0aW9uID0gW107XG5cbiAgLy8gSXRlcmF0ZXMgYWxsIHRoZSBhZGRyZXNzZXMgdG8gcG9wdWxhdGUgdGhlIG1hcCdzIGRhdGFcbiAgY29uc3QgYWRkcmVzc1dhbGxldEVudHJpZXMgPSBzdHJpbmdNYXBJdGVyYXRvcihhZGRyZXNzV2FsbGV0TWFwKSBhcyBbc3RyaW5nLCBXYWxsZXRdW107XG4gIGZvciAoY29uc3QgW2FkZHJlc3MsIHdhbGxldF0gb2YgYWRkcmVzc1dhbGxldEVudHJpZXMpIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgd2FsbGV0SWQgZW50cnkgaWYgaXQgZG9lcyBub3QgZXhpc3RcbiAgICBpZiAoIXdhbGxldHNNYXBbd2FsbGV0LndhbGxldElkXSkge1xuICAgICAgd2FsbGV0c01hcFt3YWxsZXQud2FsbGV0SWRdID0ge1xuICAgICAgICB0eElkOiB0eC50eF9pZCxcbiAgICAgICAgd2FsbGV0SWQ6IHdhbGxldC53YWxsZXRJZCxcbiAgICAgICAgYWRkcmVzc2VzOiBbXSxcbiAgICAgICAgd2FsbGV0QmFsYW5jZUZvclR4OiBuZXcgVG9rZW5CYWxhbmNlTWFwKCksXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXREYXRhID0gd2FsbGV0c01hcFt3YWxsZXQud2FsbGV0SWRdO1xuXG4gICAgLy8gQWRkIHRoaXMgYWRkcmVzcyB0byB0aGUgd2FsbGV0J3MgYWZmZWN0ZWQgYWRkcmVzc2VzIGxpc3RcbiAgICB3YWxsZXREYXRhLmFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuXG4gICAgLy8gTWVyZ2UgdGhlIGJhbGFuY2Ugb2YgdGhpcyBhZGRyZXNzIHdpdGggdGhlIHRvdGFsIGJhbGFuY2Ugb2YgdGhlIHdhbGxldFxuICAgIGNvbnN0IG1lcmdlZEJhbGFuY2UgPSBUb2tlbkJhbGFuY2VNYXAubWVyZ2Uod2FsbGV0RGF0YS53YWxsZXRCYWxhbmNlRm9yVHgsIGFkZHJlc3NCYWxhbmNlTWFwW2FkZHJlc3NdKTtcbiAgICB3YWxsZXREYXRhLndhbGxldEJhbGFuY2VGb3JUeCA9IG1lcmdlZEJhbGFuY2U7XG5cbiAgICBjb25zdCB0b2tlbklkTGlzdCA9IE9iamVjdC5rZXlzKG1lcmdlZEJhbGFuY2UubWFwKTtcbiAgICB0b2tlbklkQWNjdW11bGF0aW9uLnB1c2godG9rZW5JZExpc3QpO1xuICB9XG5cbiAgY29uc3QgdG9rZW5JZFNldCA9IG5ldyBTZXQ8c3RyaW5nPih0b2tlbklkQWNjdW11bGF0aW9uLnJlZHVjZSgocHJldiwgZWFjaEdyb3VwKSA9PiBbLi4ucHJldiwgLi4uZWFjaEdyb3VwXSwgW10pKTtcbiAgY29uc3QgdG9rZW5TeW1ib2xzTWFwID0gYXdhaXQgZ2V0VG9rZW5TeW1ib2xzKG15c3FsLCBBcnJheS5mcm9tKHRva2VuSWRTZXQudmFsdWVzKCkpKTtcblxuICByZXR1cm4gV2FsbGV0QmFsYW5jZU1hcENvbnZlcnRlci50b1ZhbHVlKHdhbGxldHNNYXAsIHRva2VuU3ltYm9sc01hcCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/commons.ts\n");

/***/ }),

/***/ "./src/db/index.ts":
/*!*************************!*\
  !*** ./src/db/index.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getTransactionsById = exports.getTxOutputs = exports.getTxsAfterHeight = exports.releaseTxProposalUtxos = exports.getTxProposal = exports.updateTxProposal = exports.createTxProposal = exports.markUtxosWithProposalId = exports.getUnusedAddresses = exports.getTokenInformation = exports.storeTokenInformation = exports.getBlockByHeight = exports.getLatestBlockByHeight = exports.getLatestHeight = exports.getVersionData = exports.updateVersionData = exports.getWalletUnlockedUtxos = exports.getUtxosLockedAtHeight = exports.getWalletTxHistory = exports.getWalletTokens = exports.getWalletBalances = exports.getNewAddresses = exports.getWalletAddresses = exports.updateWalletLockedBalance = exports.updateAddressLockedBalance = exports.updateAddressTablesWithTx = exports.getLockedUtxoFromInputs = exports.unlockUtxos = exports.getWalletSortedValueUtxos = exports.getUtxos = exports.getAuthorityUtxo = exports.getTxOutput = exports.updateTxOutputSpentBy = exports.addOrUpdateTx = exports.updateTx = exports.addUtxos = exports.updateWalletTablesWithTx = exports.initWalletBalance = exports.initWalletTxHistory = exports.getWalletAddressDetail = exports.updateExistingAddresses = exports.addNewAddresses = exports.updateWalletAuthXpub = exports.updateWalletStatus = exports.createWallet = exports.getWallet = exports.getAddressWalletInfo = exports.generateAddresses = exports.cleanupVoidedTx = exports.checkTxWasVoided = void 0;\nexports.getAddressAtIndex = exports.getUnsentTxProposals = exports.getTokenSymbols = exports.deleteStalePushDevices = exports.countStalePushDevices = exports.getPushDeviceSettingsList = exports.getPushDevice = exports.existsWallet = exports.getTransactionById = exports.unregisterPushDevice = exports.updatePushDevice = exports.removeAllPushDevicesByDeviceId = exports.registerPushDevice = exports.existsPushDevice = exports.incrementTokensTxCount = exports.getAffectedAddressTotalReceivedFromTxList = exports.getAffectedTokenTxCountFromTxList = exports.getAffectedAddressTxCountFromTxList = exports.getAvailableAuthorities = exports.getTotalTransactions = exports.getExpiredTimelocksUtxos = exports.getTotalSupply = exports.getMinersList = exports.addMiner = exports.getMempoolTransactionsBeforeDate = exports.getTxProposalInputs = exports.mapDbResultToDbTxOutput = exports.filterTxOutputs = exports.fetchAddressTxHistorySum = exports.fetchAddressBalance = exports.fetchTx = exports.rebuildAddressBalancesFromUtxos = exports.markWalletTxHistoryAsVoided = exports.markAddressTxHistoryAsVoided = exports.markTxsAsVoided = exports.deleteBlocksAfterHeight = exports.markUtxosAsVoided = exports.removeTxsHeight = exports.unspendUtxos = exports.getTxOutputsBySpent = void 0;\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst wallet_lib_1 = __webpack_require__(/*! @hathor/wallet-lib */ \"@hathor/wallet-lib\");\nconst types_1 = __webpack_require__(/*! @src/types */ \"./src/types.ts\");\nconst utils_1 = __webpack_require__(/*! @src/utils */ \"./src/utils.ts\");\nconst utils_2 = __webpack_require__(/*! @src/db/utils */ \"./src/db/utils.ts\");\nconst alerting_utils_1 = __webpack_require__(/*! @src/utils/alerting.utils */ \"./src/utils/alerting.utils.ts\");\nconst BLOCK_VERSION = [\n    wallet_lib_1.constants.BLOCK_VERSION,\n    wallet_lib_1.constants.MERGED_MINED_BLOCK_VERSION,\n];\nconst BURN_ADDRESS = 'HDeadDeadDeadDeadDeadDeadDeagTPgmn';\nconst checkTxWasVoided = async (mysql, txId) => {\n    const results = await mysql.query(`SELECT * FROM \\`address_tx_history\\`\n      WHERE tx_id = ?\n      LIMIT 1`, [txId]);\n    if (!results.length) {\n        return false;\n    }\n    const addressTxHistory = results[0];\n    return Boolean(addressTxHistory.voided);\n};\nexports.checkTxWasVoided = checkTxWasVoided;\nconst cleanupVoidedTx = async (mysql, txId) => {\n    await mysql.query(`DELETE FROM \\`transaction\\`\n      WHERE tx_id = ?\n        AND voided = true`, [txId]);\n    await mysql.query(`DELETE FROM \\`tx_output\\`\n      WHERE tx_id = ?\n        AND voided = true`, [txId]);\n    await mysql.query(`DELETE FROM \\`address_tx_history\\`\n      WHERE tx_id = ?\n        AND voided = true`, [txId]);\n    await mysql.query(`DELETE FROM \\`wallet_tx_history\\`\n      WHERE tx_id = ?\n        AND voided = true`, [txId]);\n};\nexports.cleanupVoidedTx = cleanupVoidedTx;\nconst generateAddresses = async (mysql, xpubkey, maxGap) => {\n    const existingAddresses = {};\n    const newAddresses = {};\n    const allAddresses = [];\n    const derivedXpub = (0, utils_1.xpubDeriveChild)(xpubkey, 0);\n    let highestCheckedIndex = -1;\n    let lastUsedAddressIndex = -1;\n    do {\n        const addrMap = (0, utils_1.getAddresses)(derivedXpub, highestCheckedIndex + 1, maxGap);\n        allAddresses.push(...Object.keys(addrMap));\n        const results = await mysql.query(`SELECT \\`address\\`,\n              \\`index\\`,\n              \\`transactions\\`\n         FROM \\`address\\`\n        WHERE \\`address\\`\n           IN (?)`, [Object.keys(addrMap)]);\n        for (const entry of results) {\n            const address = entry.address;\n            const index = addrMap[address];\n            existingAddresses[address] = index;\n            if (entry.transactions > 0 && index > lastUsedAddressIndex) {\n                lastUsedAddressIndex = index;\n            }\n            delete addrMap[address];\n        }\n        highestCheckedIndex += maxGap;\n        Object.assign(newAddresses, addrMap);\n    } while (lastUsedAddressIndex + maxGap > highestCheckedIndex);\n    const totalAddresses = lastUsedAddressIndex + maxGap + 1;\n    for (const [address, index] of Object.entries(newAddresses)) {\n        if (index > lastUsedAddressIndex + maxGap) {\n            delete newAddresses[address];\n        }\n    }\n    return {\n        addresses: allAddresses.slice(0, totalAddresses),\n        newAddresses,\n        existingAddresses,\n        lastUsedAddressIndex,\n    };\n};\nexports.generateAddresses = generateAddresses;\nconst getAddressWalletInfo = async (mysql, addresses) => {\n    const addressWalletMap = {};\n    const results = await mysql.query(`SELECT DISTINCT a.\\`address\\`,\n                     a.\\`wallet_id\\`,\n                     w.\\`auth_xpubkey\\`,\n                     w.\\`xpubkey\\`,\n                     w.\\`max_gap\\`\n       FROM \\`address\\` a\n INNER JOIN \\`wallet\\` w\n         ON a.wallet_id = w.id\n      WHERE a.\\`address\\`\n         IN (?)`, [addresses]);\n    for (const entry of results) {\n        const walletInfo = {\n            walletId: entry.wallet_id,\n            authXpubkey: entry.auth_xpubkey,\n            xpubkey: entry.xpubkey,\n            maxGap: entry.max_gap,\n        };\n        addressWalletMap[entry.address] = walletInfo;\n    }\n    return addressWalletMap;\n};\nexports.getAddressWalletInfo = getAddressWalletInfo;\nconst getWallet = async (mysql, walletId) => {\n    const results = await mysql.query('SELECT * FROM `wallet` WHERE `id` = ?', walletId);\n    if (results.length) {\n        const result = results[0];\n        return (0, utils_2.getWalletFromDbEntry)(result);\n    }\n    return null;\n};\nexports.getWallet = getWallet;\nconst createWallet = async (mysql, walletId, xpubkey, authXpubkey, maxGap) => {\n    const ts = (0, utils_1.getUnixTimestamp)();\n    const entry = {\n        id: walletId,\n        xpubkey,\n        auth_xpubkey: authXpubkey,\n        status: types_1.WalletStatus.CREATING,\n        created_at: ts,\n        max_gap: maxGap,\n    };\n    await mysql.query(`INSERT INTO \\`wallet\\`\n        SET ?`, [entry]);\n    return {\n        walletId,\n        xpubkey,\n        authXpubkey,\n        maxGap,\n        retryCount: 0,\n        status: types_1.WalletStatus.CREATING,\n        createdAt: ts,\n        readyAt: null,\n    };\n};\nexports.createWallet = createWallet;\nconst updateWalletStatus = async (mysql, walletId, status, retryCount = 0) => {\n    const ts = (0, utils_1.getUnixTimestamp)();\n    await mysql.query(`UPDATE \\`wallet\\`\n        SET \\`status\\` = ?,\n            \\`ready_at\\` = ?,\n            \\`retry_count\\` = ?\n      WHERE \\`id\\` = ?`, [status, ts, retryCount, walletId]);\n};\nexports.updateWalletStatus = updateWalletStatus;\nconst updateWalletAuthXpub = async (mysql, walletId, authXpubkey) => {\n    await mysql.query(`UPDATE \\`wallet\\`\n        SET \\`auth_xpubkey\\` = ?\n      WHERE \\`id\\` = ?`, [authXpubkey, walletId]);\n};\nexports.updateWalletAuthXpub = updateWalletAuthXpub;\nconst addNewAddresses = async (mysql, walletId, addresses, lastUsedAddressIndex) => {\n    if (Object.keys(addresses).length === 0)\n        return;\n    const entries = [];\n    for (const [address, index] of Object.entries(addresses)) {\n        entries.push([address, index, walletId, 0]);\n    }\n    await mysql.query(`INSERT INTO \\`address\\`(\\`address\\`, \\`index\\`,\n                             \\`wallet_id\\`, \\`transactions\\`)\n     VALUES ?`, [entries]);\n    await mysql.query(`UPDATE \\`wallet\\`\n        SET \\`last_used_address_index\\` = ?\n      WHERE \\`id\\` = ?`, [lastUsedAddressIndex, walletId]);\n};\nexports.addNewAddresses = addNewAddresses;\nconst updateExistingAddresses = async (mysql, walletId, addresses) => {\n    if (Object.keys(addresses).length === 0)\n        return;\n    for (const [address, index] of Object.entries(addresses)) {\n        await mysql.query(`UPDATE \\`address\\`\n          SET \\`wallet_id\\` = ?,\n              \\`index\\` = ?\n        WHERE \\`address\\` = ?`, [walletId, index, address]);\n    }\n};\nexports.updateExistingAddresses = updateExistingAddresses;\nconst getWalletAddressDetail = async (mysql, walletId, address) => {\n    const results = await mysql.query(`\n    SELECT *\n      FROM \\`address\\`\n     WHERE \\`wallet_id\\` = ?\n         AND \\`address\\` = ?`, [walletId, address]);\n    if (results.length > 0) {\n        const data = results[0];\n        const addressDetail = {\n            address: data.address,\n            index: data.index,\n            transactions: data.transactions,\n        };\n        return addressDetail;\n    }\n    return null;\n};\nexports.getWalletAddressDetail = getWalletAddressDetail;\nconst initWalletTxHistory = async (mysql, walletId, addresses) => {\n    if (addresses.length === 0)\n        return;\n    const results = await mysql.query(`SELECT \\`tx_id\\`,\n            \\`token_id\\`,\n            SUM(\\`balance\\`) AS balance,\n            \\`timestamp\\`\n       FROM \\`address_tx_history\\`\n      WHERE \\`address\\` IN (?)\n        AND \\`voided\\` = FALSE\n   GROUP BY \\`tx_id\\`,\n            \\`token_id\\`,\n            \\`timestamp\\``, [addresses]);\n    if (results.length === 0)\n        return;\n    const walletTxHistory = [];\n    for (const row of results) {\n        walletTxHistory.push([walletId, row.token_id, row.tx_id, row.balance, row.timestamp]);\n    }\n    await mysql.query(`INSERT INTO \\`wallet_tx_history\\`(\\`wallet_id\\`, \\`token_id\\`,\n                                       \\`tx_id\\`, \\`balance\\`,\n                                       \\`timestamp\\`)\n          VALUES ?`, [walletTxHistory]);\n};\nexports.initWalletTxHistory = initWalletTxHistory;\nconst initWalletBalance = async (mysql, walletId, addresses) => {\n    const results1 = await mysql.query(`SELECT \\`token_id\\`,\n            SUM(\\`total_received\\`) AS \\`total_received\\`,\n            SUM(\\`unlocked_balance\\`) AS \\`unlocked_balance\\`,\n            SUM(\\`locked_balance\\`) AS \\`locked_balance\\`,\n            MIN(\\`timelock_expires\\`) AS \\`timelock_expires\\`\n       FROM \\`address_balance\\`\n      WHERE \\`address\\`\n         IN (?)\n   GROUP BY \\`token_id\\`\n   ORDER BY \\`token_id\\``, [addresses]);\n    const results2 = await mysql.query(`SELECT \\`token_id\\`,\n            SUM(\\`balance\\`) AS \\`balance\\`,\n            COUNT(DISTINCT \\`tx_id\\`) AS \\`transactions\\`\n       FROM \\`address_tx_history\\`\n      WHERE \\`address\\` IN (?)\n        AND \\`voided\\` = FALSE\n   GROUP BY \\`token_id\\`\n   ORDER BY \\`token_id\\``, [addresses]);\n    assert_1.strict.strictEqual(results1.length, results2.length);\n    const balanceEntries = [];\n    for (let i = 0; i < results1.length; i++) {\n        const row1 = results1[i];\n        const row2 = results2[i];\n        assert_1.strict.strictEqual(row1.token_id, row2.token_id);\n        assert_1.strict.strictEqual(row1.unlocked_balance + row1.locked_balance, row2.balance);\n        balanceEntries.push([\n            walletId,\n            row1.token_id,\n            row1.total_received,\n            row1.unlocked_balance,\n            row1.locked_balance,\n            row1.timelock_expires,\n            row2.transactions,\n        ]);\n    }\n    if (balanceEntries.length > 0) {\n        await mysql.query(`INSERT INTO \\`wallet_balance\\`(\\`wallet_id\\`, \\`token_id\\`,\n                                      \\`total_received\\`,\n                                      \\`unlocked_balance\\`, \\`locked_balance\\`,\n                                      \\`timelock_expires\\`, \\`transactions\\`)\n            VALUES ?`, [balanceEntries]);\n    }\n};\nexports.initWalletBalance = initWalletBalance;\nconst updateWalletTablesWithTx = async (mysql, txId, timestamp, walletBalanceMap) => {\n    const entries = [];\n    for (const [walletId, tokenBalanceMap] of Object.entries(walletBalanceMap)) {\n        for (const [token, tokenBalance] of tokenBalanceMap.iterator()) {\n            const entry = {\n                wallet_id: walletId,\n                token_id: token,\n                total_received: tokenBalance.totalAmountSent,\n                unlocked_balance: (tokenBalance.unlockedAmount < 0 ? 0 : tokenBalance.unlockedAmount),\n                locked_balance: tokenBalance.lockedAmount,\n                unlocked_authorities: tokenBalance.unlockedAuthorities.toUnsignedInteger(),\n                locked_authorities: tokenBalance.lockedAuthorities.toUnsignedInteger(),\n                timelock_expires: tokenBalance.lockExpires,\n                transactions: 1,\n            };\n            await mysql.query(`INSERT INTO wallet_balance\n            SET ?\n             ON DUPLICATE KEY\n         UPDATE total_received = total_received + ?,\n                unlocked_balance = unlocked_balance + ?,\n                locked_balance = locked_balance + ?,\n                transactions = transactions + 1,\n                timelock_expires = CASE WHEN timelock_expires IS NULL THEN VALUES(timelock_expires)\n                                        WHEN VALUES(timelock_expires) IS NULL THEN timelock_expires\n                                        ELSE LEAST(timelock_expires, VALUES(timelock_expires))\n                                   END,\n                unlocked_authorities = (unlocked_authorities | VALUES(unlocked_authorities)),\n                locked_authorities = locked_authorities | VALUES(locked_authorities)`, [entry, tokenBalance.totalAmountSent, tokenBalance.unlockedAmount, tokenBalance.lockedAmount, walletId, token]);\n            if (tokenBalance.unlockedAuthorities.hasNegativeValue()) {\n                await mysql.query(`UPDATE \\`wallet_balance\\`\n              SET \\`unlocked_authorities\\` = (\n                SELECT BIT_OR(\\`unlocked_authorities\\`)\n                  FROM \\`address_balance\\`\n                 WHERE \\`address\\` IN (\n                   SELECT \\`address\\`\n                     FROM \\`address\\`\n                    WHERE \\`wallet_id\\` = ?)\n                   AND \\`token_id\\` = ?)\n            WHERE \\`wallet_id\\` = ?\n              AND \\`token_id\\` = ?`, [walletId, token, walletId, token]);\n            }\n            entries.push([walletId, token, txId, tokenBalance.total(), timestamp]);\n        }\n    }\n    if (entries.length > 0) {\n        await mysql.query(`INSERT INTO \\`wallet_tx_history\\` (\\`wallet_id\\`, \\`token_id\\`,\n                                          \\`tx_id\\`, \\`balance\\`,\n                                          \\`timestamp\\`)\n            VALUES ?`, [entries]);\n    }\n};\nexports.updateWalletTablesWithTx = updateWalletTablesWithTx;\nconst addUtxos = async (mysql, txId, outputs, heightlock = null) => {\n    if (outputs.length === 0)\n        return;\n    const entries = outputs.map((output) => {\n        let authorities = 0;\n        let value = output.value;\n        if ((0, utils_1.isAuthority)(output.token_data)) {\n            authorities = value;\n            value = 0;\n        }\n        return [\n            txId,\n            output.index,\n            output.token,\n            value,\n            authorities,\n            output.decoded.address,\n            output.decoded.timelock,\n            heightlock,\n            output.locked,\n        ];\n    });\n    await mysql.query(`INSERT INTO \\`tx_output\\` (\\`tx_id\\`, \\`index\\`, \\`token_id\\`,\n                           \\`value\\`, \\`authorities\\`, \\`address\\`,\n                           \\`timelock\\`, \\`heightlock\\`, \\`locked\\`)\n     VALUES ?\n     ON DUPLICATE KEY UPDATE tx_id=tx_id`, [entries]);\n};\nexports.addUtxos = addUtxos;\nconst updateTx = async (mysql, txId, height, timestamp, version, weight) => (0, exports.addOrUpdateTx)(mysql, txId, height, timestamp, version, weight);\nexports.updateTx = updateTx;\nconst addOrUpdateTx = async (mysql, txId, height, timestamp, version, weight) => {\n    const entries = [[txId, height, timestamp, version, weight]];\n    await mysql.query(`INSERT INTO \\`transaction\\` (tx_id, height, timestamp, version, weight)\n     VALUES ?\n         ON DUPLICATE KEY UPDATE height = ?`, [entries, height]);\n};\nexports.addOrUpdateTx = addOrUpdateTx;\nconst updateTxOutputSpentBy = async (mysql, inputs, txId) => {\n    const entries = inputs.map((input) => [input.tx_id, input.index]);\n    if (entries.length) {\n        const result = await mysql.query(`UPDATE \\`tx_output\\` USE INDEX (PRIMARY)\n          SET \\`spent_by\\` = ?\n        WHERE (\\`tx_id\\` ,\\`index\\`)\n           IN (?)`, [txId, entries]);\n        assert_1.strict.strictEqual(result.affectedRows, inputs.length, new Error('Not all informed UTXOs had their spentBy updated'));\n    }\n};\nexports.updateTxOutputSpentBy = updateTxOutputSpentBy;\nconst getTxOutput = async (mysql, txId, index, skipSpent) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\`\n      WHERE \\`tx_id\\` = ?\n        AND \\`index\\` = ?\n        ${skipSpent ? 'AND `spent_by` IS NULL' : ''}\n        AND \\`voided\\` = FALSE`, [txId, index]);\n    if (!results.length || results.length === 0) {\n        return null;\n    }\n    const result = results[0];\n    const txOutput = (0, exports.mapDbResultToDbTxOutput)(result);\n    return txOutput;\n};\nexports.getTxOutput = getTxOutput;\nconst getAuthorityUtxo = async (mysql, tokenId, authority) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\`\n      WHERE \\`authorities\\` = ?\n        AND \\`spent_by\\` IS NULL\n        AND \\`voided\\` = FALSE\n        AND \\`token_id\\` = ?\n      LIMIT 1`, [authority, tokenId]);\n    if (!results.length || results.length === 0) {\n        return null;\n    }\n    const result = results[0];\n    const utxo = (0, exports.mapDbResultToDbTxOutput)(result);\n    return utxo;\n};\nexports.getAuthorityUtxo = getAuthorityUtxo;\nconst getUtxos = async (mysql, utxosInfo) => {\n    const entries = utxosInfo.map((utxo) => [utxo.txId, utxo.index]);\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\` USE INDEX (PRIMARY)\n      WHERE (\\`tx_id\\`, \\`index\\`)\n         IN (?)\n        AND \\`spent_by\\` IS NULL\n        AND \\`voided\\` = FALSE`, [entries]);\n    const utxos = results.map(exports.mapDbResultToDbTxOutput);\n    return utxos;\n};\nexports.getUtxos = getUtxos;\nconst getWalletSortedValueUtxos = async (mysql, walletId, tokenId) => {\n    const utxos = [];\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\`\n      WHERE \\`address\\`\n         IN (\n           SELECT \\`address\\`\n             FROM \\`address\\`\n            WHERE \\`wallet_id\\` = ?\n         )\n        AND \\`token_id\\` = ?\n        AND \\`authorities\\` = 0\n        AND \\`locked\\` = FALSE\n        AND \\`tx_proposal\\` IS NULL\n        AND \\`spent_by\\` IS NULL\n        AND \\`voided\\` = FALSE\n   ORDER BY \\`value\\`\n       DESC`, [walletId, tokenId]);\n    for (const result of results) {\n        const utxo = {\n            txId: result.tx_id,\n            index: result.index,\n            tokenId: result.token_id,\n            address: result.address,\n            value: result.value,\n            authorities: result.authorities,\n            timelock: result.timelock,\n            heightlock: result.heightlock,\n            locked: result.locked > 0,\n        };\n        utxos.push(utxo);\n    }\n    return utxos;\n};\nexports.getWalletSortedValueUtxos = getWalletSortedValueUtxos;\nconst unlockUtxos = async (mysql, utxos) => {\n    if (utxos.length === 0)\n        return;\n    const entries = utxos.map((utxo) => [utxo.txId, utxo.index]);\n    await mysql.query(`UPDATE \\`tx_output\\`\n        SET \\`locked\\` = FALSE\n      WHERE (\\`tx_id\\` ,\\`index\\`)\n         IN (?)`, [entries]);\n};\nexports.unlockUtxos = unlockUtxos;\nconst getLockedUtxoFromInputs = async (mysql, inputs) => {\n    const entries = inputs.map((input) => [input.tx_id, input.index]);\n    if (entries.length) {\n        const results = await mysql.query(`SELECT *\n         FROM \\`tx_output\\` USE INDEX (PRIMARY)\n        WHERE (\\`tx_id\\` ,\\`index\\`)\n           IN (?)\n          AND \\`locked\\` = TRUE\n          AND \\`spent_by\\` IS NULL\n          AND \\`voided\\` = FALSE`, [entries]);\n        return results.map((utxo) => ({\n            txId: utxo.tx_id,\n            index: utxo.index,\n            tokenId: utxo.token_id,\n            address: utxo.address,\n            value: utxo.value,\n            authorities: utxo.authorities,\n            timelock: utxo.timelock,\n            heightlock: utxo.heightlock,\n            locked: (utxo.locked > 0),\n        }));\n    }\n    return [];\n};\nexports.getLockedUtxoFromInputs = getLockedUtxoFromInputs;\nconst updateAddressTablesWithTx = async (mysql, txId, timestamp, addressBalanceMap) => {\n    const addressEntries = Object.keys(addressBalanceMap).map((address) => [address, 1]);\n    await mysql.query(`INSERT INTO \\`address\\`(\\`address\\`, \\`transactions\\`)\n          VALUES ?\n              ON DUPLICATE KEY UPDATE transactions = transactions + 1`, [addressEntries]);\n    const entries = [];\n    for (const [address, tokenMap] of Object.entries(addressBalanceMap)) {\n        for (const [token, tokenBalance] of tokenMap.iterator()) {\n            const entry = {\n                address,\n                token_id: token,\n                total_received: tokenBalance.totalAmountSent,\n                unlocked_balance: (tokenBalance.unlockedAmount < 0 ? 0 : tokenBalance.unlockedAmount),\n                locked_balance: tokenBalance.lockedAmount,\n                unlocked_authorities: tokenBalance.unlockedAuthorities.toUnsignedInteger(),\n                locked_authorities: tokenBalance.lockedAuthorities.toUnsignedInteger(),\n                timelock_expires: tokenBalance.lockExpires,\n                transactions: 1,\n            };\n            await mysql.query(`INSERT INTO address_balance\n                 SET ?\n                  ON DUPLICATE KEY\n                            UPDATE total_received = total_received + ?,\n                                   unlocked_balance = unlocked_balance + ?,\n                                   locked_balance = locked_balance + ?,\n                                   transactions = transactions + 1,\n                                   timelock_expires = CASE\n                                                        WHEN timelock_expires IS NULL THEN VALUES(timelock_expires)\n                                                        WHEN VALUES(timelock_expires) IS NULL THEN timelock_expires\n                                                        ELSE LEAST(timelock_expires, VALUES(timelock_expires))\n                                                      END,\n                                   unlocked_authorities = (unlocked_authorities | VALUES(unlocked_authorities)),\n                                   locked_authorities = locked_authorities | VALUES(locked_authorities)`, [entry, tokenBalance.totalAmountSent, tokenBalance.unlockedAmount, tokenBalance.lockedAmount, address, token]);\n            if (tokenBalance.unlockedAuthorities.hasNegativeValue()) {\n                await mysql.query(`UPDATE \\`address_balance\\`\n              SET \\`unlocked_authorities\\` = (\n                SELECT BIT_OR(\\`authorities\\`)\n                  FROM \\`tx_output\\`\n                 WHERE \\`address\\` = ?\n                   AND \\`token_id\\` = ?\n                   AND \\`locked\\` = FALSE\n                   AND \\`spent_by\\` IS NULL\n                   AND \\`voided\\` = FALSE\n              )\n            WHERE \\`address\\` = ?\n              AND \\`token_id\\` = ?`, [address, token, address, token]);\n            }\n            entries.push([address, txId, token, tokenBalance.total(), timestamp]);\n        }\n    }\n    await mysql.query(`INSERT INTO \\`address_tx_history\\`(\\`address\\`, \\`tx_id\\`,\n                                        \\`token_id\\`, \\`balance\\`,\n                                        \\`timestamp\\`)\n     VALUES ?`, [entries]);\n};\nexports.updateAddressTablesWithTx = updateAddressTablesWithTx;\nconst updateAddressLockedBalance = async (mysql, addressBalanceMap, updateTimelocks = false) => {\n    for (const [address, tokenBalanceMap] of Object.entries(addressBalanceMap)) {\n        for (const [token, tokenBalance] of tokenBalanceMap.iterator()) {\n            await mysql.query(`UPDATE \\`address_balance\\`\n            SET \\`unlocked_balance\\` = \\`unlocked_balance\\` + ?,\n                \\`locked_balance\\` = \\`locked_balance\\` - ?,\n                \\`unlocked_authorities\\` = (unlocked_authorities | ?)\n          WHERE \\`address\\` = ?\n            AND \\`token_id\\` = ?`, [\n                tokenBalance.unlockedAmount,\n                tokenBalance.unlockedAmount,\n                tokenBalance.unlockedAuthorities.toInteger(),\n                address,\n                token,\n            ]);\n            if (tokenBalance.unlockedAuthorities.toInteger() > 0) {\n                await mysql.query(`UPDATE \\`address_balance\\`\n              SET \\`locked_authorities\\` = (\n                SELECT BIT_OR(\\`authorities\\`)\n                  FROM \\`tx_output\\`\n                 WHERE \\`address\\` = ?\n                   AND \\`token_id\\` = ?\n                   AND \\`locked\\` = TRUE\n                   AND \\`spent_by\\` IS NULL\n                   AND \\`voided\\` = FALSE)\n                 WHERE \\`address\\` = ?\n                   AND \\`token_id\\` = ?`, [address, token, address, token]);\n            }\n            if (updateTimelocks) {\n                await mysql.query(`\n          UPDATE \\`address_balance\\`\n             SET \\`timelock_expires\\` = (\n               SELECT MIN(\\`timelock\\`)\n                 FROM \\`tx_output\\`\n                WHERE \\`address\\` = ?\n                  AND \\`token_id\\` = ?\n                  AND \\`locked\\` = TRUE\n                  AND \\`spent_by\\` IS NULL\n                  AND \\`voided\\` = FALSE\n             )\n           WHERE \\`address\\` = ?\n             AND \\`token_id\\` = ?`, [address, token, address, token]);\n            }\n        }\n    }\n};\nexports.updateAddressLockedBalance = updateAddressLockedBalance;\nconst updateWalletLockedBalance = async (mysql, walletBalanceMap, updateTimelocks = false) => {\n    for (const [walletId, tokenBalanceMap] of Object.entries(walletBalanceMap)) {\n        for (const [token, tokenBalance] of tokenBalanceMap.iterator()) {\n            await mysql.query(`UPDATE \\`wallet_balance\\`\n            SET \\`unlocked_balance\\` = \\`unlocked_balance\\` + ?,\n                \\`locked_balance\\` = \\`locked_balance\\` - ?,\n                \\`unlocked_authorities\\` = (\\`unlocked_authorities\\` | ?)\n          WHERE \\`wallet_id\\` = ?\n            AND \\`token_id\\` = ?`, [tokenBalance.unlockedAmount, tokenBalance.unlockedAmount,\n                tokenBalance.unlockedAuthorities.toInteger(), walletId, token]);\n            if (tokenBalance.unlockedAuthorities.toInteger() > 0) {\n                await mysql.query(`UPDATE \\`wallet_balance\\`\n              SET \\`locked_authorities\\` = (\n                SELECT BIT_OR(\\`locked_authorities\\`)\n                  FROM \\`address_balance\\`\n                 WHERE \\`address\\` IN (\n                   SELECT \\`address\\`\n                     FROM \\`address\\`\n                    WHERE \\`wallet_id\\` = ?)\n                    AND \\`token_id\\` = ?)\n            WHERE \\`wallet_id\\` = ?\n              AND \\`token_id\\` = ?`, [walletId, token, walletId, token]);\n            }\n            if (updateTimelocks) {\n                await mysql.query(`UPDATE \\`wallet_balance\\`\n              SET \\`timelock_expires\\` = (\n                SELECT MIN(\\`timelock_expires\\`)\n                  FROM \\`address_balance\\`\n                 WHERE \\`address\\`\n                    IN (\n                      SELECT \\`address\\`\n                        FROM \\`address\\`\n                       WHERE \\`wallet_id\\` = ?)\n                   AND \\`token_id\\` = ?)\n            WHERE \\`wallet_id\\` = ? AND \\`token_id\\` = ?`, [walletId, token, walletId, token]);\n            }\n        }\n    }\n};\nexports.updateWalletLockedBalance = updateWalletLockedBalance;\nconst getWalletAddresses = async (mysql, walletId, filterAddresses) => {\n    const addresses = [];\n    const subQuery = filterAddresses ? `\n    AND \\`address\\` IN (?)\n  ` : '';\n    const results = await mysql.query(`\n    SELECT *\n      FROM \\`address\\`\n     WHERE \\`wallet_id\\` = ?\n      ${subQuery}\n  ORDER BY \\`index\\`\n       ASC`, [walletId, filterAddresses]);\n    for (const result of results) {\n        const address = {\n            address: result.address,\n            index: result.index,\n            transactions: result.transactions,\n        };\n        addresses.push(address);\n    }\n    return addresses;\n};\nexports.getWalletAddresses = getWalletAddresses;\nconst getNewAddresses = async (mysql, walletId) => {\n    const addresses = [];\n    const resultsWallet = await mysql.query('SELECT * FROM `wallet` WHERE `id` = ?', walletId);\n    if (resultsWallet.length) {\n        const gapLimit = resultsWallet[0].max_gap;\n        const latestUsedIndex = resultsWallet[0].last_used_address_index;\n        const results = await mysql.query(`\n      SELECT *\n        FROM \\`address\\`\n       WHERE \\`wallet_id\\` = ?\n         AND \\`transactions\\` = 0\n         AND \\`index\\` > ?\n    ORDER BY \\`index\\`\n         ASC\n    LIMIT ?`, [walletId, latestUsedIndex, gapLimit]);\n        for (const result of results) {\n            const index = result.index;\n            const address = {\n                address: result.address,\n                index,\n                addressPath: (0, utils_1.getAddressPath)(index),\n            };\n            addresses.push(address);\n        }\n    }\n    return addresses;\n};\nexports.getNewAddresses = getNewAddresses;\nconst getWalletBalances = async (mysql, walletId, tokenIds = []) => {\n    const balances = [];\n    let subquery = 'SELECT * FROM `wallet_balance` WHERE `wallet_id` = ?';\n    const params = [walletId];\n    if (tokenIds.length > 0) {\n        subquery += ' AND `token_id` IN (?)';\n        params.push(tokenIds);\n    }\n    const query = `\n    SELECT w.total_received AS total_received,\n           w.unlocked_balance AS unlocked_balance,\n           w.locked_balance AS locked_balance,\n           w.unlocked_authorities AS unlocked_authorities,\n           w.locked_authorities AS locked_authorities,\n           w.timelock_expires AS timelock_expires,\n           w.transactions AS transactions,\n           w.token_id AS token_id,\n           token.name AS name,\n           token.symbol AS symbol\n      FROM (${subquery}) w\nINNER JOIN token ON w.token_id = token.id\n  `;\n    const results = await mysql.query(query, params);\n    for (const result of results) {\n        const totalAmount = result.total_received;\n        const unlockedBalance = result.unlocked_balance;\n        const lockedBalance = result.locked_balance;\n        const unlockedAuthorities = new types_1.Authorities(result.unlocked_authorities);\n        const lockedAuthorities = new types_1.Authorities(result.locked_authorities);\n        const timelockExpires = result.timelock_expires;\n        const balance = new types_1.WalletTokenBalance(new types_1.TokenInfo(result.token_id, result.name, result.symbol), new types_1.Balance(totalAmount, unlockedBalance, lockedBalance, timelockExpires, unlockedAuthorities, lockedAuthorities), result.transactions);\n        balances.push(balance);\n    }\n    return balances;\n};\nexports.getWalletBalances = getWalletBalances;\nconst getWalletTokens = async (mysql, walletId) => {\n    const tokenList = [];\n    const results = await mysql.query(`SELECT DISTINCT(token_id)\n       FROM \\`wallet_tx_history\\`\n      WHERE \\`wallet_id\\` = ?`, [walletId]);\n    for (const result of results) {\n        tokenList.push(result.token_id);\n    }\n    return tokenList;\n};\nexports.getWalletTokens = getWalletTokens;\nconst getWalletTxHistory = async (mysql, walletId, tokenId, skip, count) => {\n    const history = [];\n    const results = await mysql.query(`\n    SELECT wallet_tx_history.balance AS balance,\n           wallet_tx_history.timestamp AS timestamp,\n           wallet_tx_history.token_id AS token_id,\n           wallet_tx_history.tx_id AS tx_id,\n           wallet_tx_history.voided AS voided,\n           wallet_tx_history.wallet_id AS wallet_id,\n           transaction.version AS version\n      FROM wallet_tx_history\nLEFT OUTER JOIN transaction ON transaction.tx_id = wallet_tx_history.tx_id\n     WHERE wallet_id = ?\n       AND token_id = ?\n  ORDER BY wallet_tx_history.timestamp\n      DESC\n     LIMIT ?, ?`, [walletId, tokenId, skip, count]);\n    for (const result of results) {\n        const tx = {\n            txId: result.tx_id,\n            timestamp: result.timestamp,\n            voided: result.voided,\n            balance: result.balance,\n            version: result.version,\n        };\n        history.push(tx);\n    }\n    return history;\n};\nexports.getWalletTxHistory = getWalletTxHistory;\nconst getUtxosLockedAtHeight = async (mysql, now, height) => {\n    const utxos = [];\n    if (height >= 0) {\n        const results = await mysql.query(`SELECT *\n         FROM \\`tx_output\\`\n        WHERE \\`heightlock\\` = ?\n          AND \\`spent_by\\` IS NULL\n          AND \\`voided\\` = FALSE\n          AND (\\`timelock\\` <= ?\n               OR \\`timelock\\` is NULL)\n          AND \\`locked\\` = 1`, [height, now]);\n        for (const result of results) {\n            const utxo = {\n                txId: result.tx_id,\n                index: result.index,\n                tokenId: result.token_id,\n                address: result.address,\n                value: result.value,\n                authorities: result.authorities,\n                timelock: result.timelock,\n                heightlock: result.heightlock,\n                locked: result.locked > 0,\n            };\n            utxos.push(utxo);\n        }\n    }\n    return utxos;\n};\nexports.getUtxosLockedAtHeight = getUtxosLockedAtHeight;\nconst getWalletUnlockedUtxos = async (mysql, walletId, now, currentHeight) => {\n    const utxos = [];\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\`\n      WHERE (\\`heightlock\\` <= ?\n             OR \\`heightlock\\` is NULL)\n        AND (\\`timelock\\` <= ?\n             OR \\`timelock\\` is NULL)\n        AND \\`locked\\` = 1\n        AND \\`spent_by\\` IS NULL\n        AND \\`voided\\` = FALSE\n        AND \\`address\\` IN (\n          SELECT \\`address\\`\n            FROM \\`address\\`\n           WHERE \\`wallet_id\\` = ?)`, [currentHeight, now, walletId]);\n    for (const result of results) {\n        const utxo = {\n            txId: result.tx_id,\n            index: result.index,\n            tokenId: result.token_id,\n            address: result.address,\n            value: result.value,\n            authorities: result.authorities,\n            timelock: result.timelock,\n            heightlock: result.heightlock,\n            locked: result.locked > 0,\n        };\n        utxos.push(utxo);\n    }\n    return utxos;\n};\nexports.getWalletUnlockedUtxos = getWalletUnlockedUtxos;\nconst updateVersionData = async (mysql, data) => {\n    const entry = {\n        id: 1,\n        timestamp: data.timestamp,\n        version: data.version,\n        network: data.network,\n        min_weight: data.minWeight,\n        min_tx_weight: data.minTxWeight,\n        min_tx_weight_coefficient: data.minTxWeightCoefficient,\n        min_tx_weight_k: data.minTxWeightK,\n        token_deposit_percentage: data.tokenDepositPercentage,\n        reward_spend_min_blocks: data.rewardSpendMinBlocks,\n        max_number_inputs: data.maxNumberInputs,\n        max_number_outputs: data.maxNumberOutputs,\n    };\n    await mysql.query('INSERT INTO `version_data` SET ? ON DUPLICATE KEY UPDATE ?', [entry, entry]);\n};\nexports.updateVersionData = updateVersionData;\nconst getVersionData = async (mysql) => {\n    const results = await mysql.query('SELECT * FROM `version_data` WHERE id = 1 LIMIT 1;');\n    if (results.length > 0) {\n        const data = results[0];\n        const entry = {\n            timestamp: data.timestamp,\n            version: data.version,\n            network: data.network,\n            minWeight: data.min_weight,\n            minTxWeight: data.min_tx_weight,\n            minTxWeightCoefficient: data.min_tx_weight_coefficient,\n            minTxWeightK: data.min_tx_weight_k,\n            tokenDepositPercentage: data.token_deposit_percentage,\n            rewardSpendMinBlocks: data.reward_spend_min_blocks,\n            maxNumberInputs: data.max_number_inputs,\n            maxNumberOutputs: data.max_number_outputs,\n        };\n        return entry;\n    }\n    return null;\n};\nexports.getVersionData = getVersionData;\nconst getLatestHeight = async (mysql) => {\n    const results = await mysql.query(`SELECT \\`height\\` AS value\n       FROM \\`transaction\\`\n      WHERE version\n         IN (?)\n      ORDER BY height\n       DESC\n      LIMIT 1`, [BLOCK_VERSION]);\n    if (results.length > 0 && results[0].value !== null) {\n        return results[0].value;\n    }\n    return 0;\n};\nexports.getLatestHeight = getLatestHeight;\nconst getLatestBlockByHeight = async (mysql) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`transaction\\`\n      WHERE \\`version\\` IN (?)\n      ORDER BY height DESC\n      LIMIT 1`, [BLOCK_VERSION]);\n    if (results.length > 0) {\n        return {\n            txId: results[0].tx_id,\n            height: results[0].height,\n            timestamp: results[0].timestamp,\n        };\n    }\n    return null;\n};\nexports.getLatestBlockByHeight = getLatestBlockByHeight;\nconst getBlockByHeight = async (mysql, height) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`transaction\\`\n      WHERE \\`height\\` = ?\n        AND \\`version\\` IN (?)\n      LIMIT 1`, [height, BLOCK_VERSION]);\n    if (results.length > 0) {\n        return {\n            txId: results[0].tx_id,\n            height: results[0].height,\n            timestamp: results[0].timestamp,\n        };\n    }\n    return null;\n};\nexports.getBlockByHeight = getBlockByHeight;\nconst storeTokenInformation = async (mysql, tokenId, tokenName, tokenSymbol) => {\n    const entry = { id: tokenId, name: tokenName, symbol: tokenSymbol };\n    await mysql.query('INSERT INTO `token` SET ?', [entry]);\n};\nexports.storeTokenInformation = storeTokenInformation;\nconst getTokenInformation = async (mysql, tokenId) => {\n    const results = await mysql.query('SELECT * FROM `token` WHERE `id` = ?', [tokenId]);\n    if (results.length === 0)\n        return null;\n    return new types_1.TokenInfo(tokenId, results[0].name, results[0].symbol);\n};\nexports.getTokenInformation = getTokenInformation;\nconst getUnusedAddresses = async (mysql, walletId) => {\n    const addresses = [];\n    const results = await mysql.query('SELECT `address` FROM `address` WHERE `wallet_id` = ? AND `transactions` = 0 ORDER BY `index` ASC', [walletId]);\n    for (const entry of results) {\n        const address = entry.address;\n        addresses.push(address);\n    }\n    return addresses;\n};\nexports.getUnusedAddresses = getUnusedAddresses;\nconst markUtxosWithProposalId = async (mysql, txProposalId, utxos) => {\n    const entries = utxos.map((utxo, index) => ([utxo.txId, utxo.index, '', '', 0, 0, null, null, false, txProposalId, index, null, 0]));\n    await mysql.query(`INSERT INTO \\`tx_output\\`\n          VALUES ?\n              ON DUPLICATE KEY\\\n          UPDATE \\`tx_proposal\\` = VALUES(\\`tx_proposal\\`),\n                 \\`tx_proposal_index\\` = VALUES(\\`tx_proposal_index\\`)`, [entries]);\n};\nexports.markUtxosWithProposalId = markUtxosWithProposalId;\nconst createTxProposal = async (mysql, txProposalId, walletId, now) => {\n    const entry = { id: txProposalId, wallet_id: walletId, status: types_1.TxProposalStatus.OPEN, created_at: now };\n    await mysql.query('INSERT INTO `tx_proposal` SET ?', [entry]);\n};\nexports.createTxProposal = createTxProposal;\nconst updateTxProposal = async (mysql, txProposalIds, now, status) => {\n    await mysql.query(`\n    UPDATE \\`tx_proposal\\`\n       SET \\`updated_at\\` = ?,\n           \\`status\\` = ?\n     WHERE \\`id\\` IN (?)`, [\n        now,\n        status,\n        txProposalIds,\n    ]);\n};\nexports.updateTxProposal = updateTxProposal;\nconst getTxProposal = async (mysql, txProposalId) => {\n    const results = await mysql.query('SELECT * FROM `tx_proposal` WHERE `id` = ?', [txProposalId]);\n    if (results.length === 0)\n        return null;\n    return {\n        id: txProposalId,\n        walletId: results[0].wallet_id,\n        status: results[0].status,\n        createdAt: results[0].created_at,\n        updatedAt: results[0].updated_at,\n    };\n};\nexports.getTxProposal = getTxProposal;\nconst releaseTxProposalUtxos = async (mysql, txProposalIds) => {\n    const result = await mysql.query(`UPDATE \\`tx_output\\`\n        SET \\`tx_proposal\\` = NULL,\n            \\`tx_proposal_index\\` = NULL\n      WHERE \\`tx_proposal\\` IN (?)`, [txProposalIds]);\n    assert_1.strict.strictEqual(result.affectedRows, txProposalIds.length, 'Not all utxos were correctly updated');\n};\nexports.releaseTxProposalUtxos = releaseTxProposalUtxos;\nconst getTxsAfterHeight = async (mysql, height) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`transaction\\`\n      WHERE \\`height\\` > ?\n        AND \\`voided\\` = FALSE`, [height]);\n    return (0, utils_2.getTxsFromDBResult)(results);\n};\nexports.getTxsAfterHeight = getTxsAfterHeight;\nconst getTxOutputs = async (mysql, transactions) => {\n    const txIds = transactions.map((tx) => tx.txId);\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\`\n      WHERE \\`tx_id\\` IN (?)`, [txIds]);\n    const utxos = [];\n    for (const result of results) {\n        const utxo = {\n            txId: result.tx_id,\n            index: result.index,\n            tokenId: result.token_id,\n            address: result.address,\n            value: result.value,\n            authorities: result.authorities,\n            timelock: result.timelock,\n            heightlock: result.heightlock,\n            locked: result.locked > 0,\n            txProposalId: result.tx_proposal,\n            txProposalIndex: result.tx_proposal_index,\n            spentBy: result.spent_by ? result.spent_by : null,\n        };\n        utxos.push(utxo);\n    }\n    return utxos;\n};\nexports.getTxOutputs = getTxOutputs;\nconst getTransactionsById = async (mysql, txIds) => {\n    if (txIds.length === 0) {\n        return [];\n    }\n    const results = await mysql.query(`SELECT *\n       FROM \\`transaction\\`\n      WHERE \\`tx_id\\` IN (?)\n        AND \\`voided\\` = FALSE`, [txIds]);\n    return (0, utils_2.getTxsFromDBResult)(results);\n};\nexports.getTransactionsById = getTransactionsById;\nconst getTxOutputsBySpent = async (mysql, txIds) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\`\n      WHERE \\`spent_by\\` IN (?)`, [txIds]);\n    const utxos = [];\n    for (const result of results) {\n        const utxo = {\n            txId: result.tx_id,\n            index: result.index,\n            tokenId: result.token_id,\n            address: result.address,\n            value: result.value,\n            authorities: result.authorities,\n            timelock: result.timelock,\n            heightlock: result.heightlock,\n            locked: result.locked > 0,\n            txProposalId: result.tx_proposal,\n            txProposalIndex: result.tx_proposal_index,\n            spentBy: result.spent_by ? result.spent_by : null,\n        };\n        utxos.push(utxo);\n    }\n    return utxos;\n};\nexports.getTxOutputsBySpent = getTxOutputsBySpent;\nconst unspendUtxos = async (mysql, txOutputs) => {\n    const txIdIndexList = txOutputs.map((txOutput) => [txOutput.txId, txOutput.index]);\n    await mysql.query(`UPDATE \\`tx_output\\`\n        SET \\`spent_by\\` = NULL\n      WHERE (\\`tx_id\\`, \\`index\\`) IN (?)`, [txIdIndexList]);\n};\nexports.unspendUtxos = unspendUtxos;\nconst removeTxsHeight = async (mysql, txs) => {\n    const txIds = txs.map((tx) => tx.txId);\n    await mysql.query(`UPDATE \\`transaction\\`\n        SET \\`height\\` = NULL\n      WHERE \\`tx_id\\` IN (?)`, [txIds]);\n};\nexports.removeTxsHeight = removeTxsHeight;\nconst markUtxosAsVoided = async (mysql, utxos) => {\n    const txIds = utxos.map((tx) => tx.txId);\n    await mysql.query(`\n    UPDATE \\`tx_output\\`\n       SET \\`voided\\` = TRUE\n     WHERE \\`tx_id\\` IN (?)`, [txIds]);\n};\nexports.markUtxosAsVoided = markUtxosAsVoided;\nconst deleteBlocksAfterHeight = async (mysql, height) => {\n    await mysql.query(`DELETE FROM \\`transaction\\`\n      WHERE height > ?\n        AND version IN (?)`, [height, BLOCK_VERSION]);\n};\nexports.deleteBlocksAfterHeight = deleteBlocksAfterHeight;\nconst markTxsAsVoided = async (mysql, transactions) => {\n    const txIds = transactions.map((tx) => tx.txId);\n    await mysql.query(`UPDATE \\`transaction\\`\n        SET \\`voided\\` = TRUE\n      WHERE \\`tx_id\\` IN (?)`, [txIds]);\n};\nexports.markTxsAsVoided = markTxsAsVoided;\nconst markAddressTxHistoryAsVoided = async (mysql, transactions) => {\n    const txIds = transactions.map((tx) => tx.txId);\n    await mysql.query(`UPDATE \\`address_tx_history\\`\n        SET \\`voided\\` = TRUE\n      WHERE \\`tx_id\\` IN (?)`, [txIds]);\n};\nexports.markAddressTxHistoryAsVoided = markAddressTxHistoryAsVoided;\nconst markWalletTxHistoryAsVoided = async (mysql, transactions) => {\n    const txIds = transactions.map((tx) => tx.txId);\n    await mysql.query(`UPDATE \\`wallet_tx_history\\`\n        SET \\`voided\\` = TRUE\n      WHERE \\`tx_id\\` IN (?)`, [txIds]);\n};\nexports.markWalletTxHistoryAsVoided = markWalletTxHistoryAsVoided;\nconst rebuildAddressBalancesFromUtxos = async (mysql, addresses, txList) => {\n    if (txList.length === 0) {\n        throw new Error('Attempted to rebuild address balances but no transactions were affected');\n    }\n    const oldAddressTokenTransactions = await mysql.query(`SELECT \\`address\\`, \\`token_id\\` AS tokenId, \\`transactions\\`, \\`total_received\\` as \\`totalReceived\\`\n       FROM \\`address_balance\\`\n      WHERE \\`address\\` IN (?)`, [addresses]);\n    await mysql.query(`UPDATE \\`address_balance\\`\n        SET \\`unlocked_balance\\` = 0,\n            \\`locked_balance\\` = 0,\n            \\`locked_authorities\\` = 0,\n            \\`unlocked_authorities\\` = 0,\n            \\`timelock_expires\\` = NULL,\n            \\`transactions\\` = 0\n      WHERE \\`address\\` IN (?)`, [addresses]);\n    await mysql.query(`\n    INSERT INTO address_balance (\n      \\`address\\`,\n      \\`token_id\\`,\n      \\`unlocked_balance\\`,\n      \\`locked_balance\\`,\n      \\`unlocked_authorities\\`,\n      \\`locked_authorities\\`,\n      \\`timelock_expires\\`,\n      \\`transactions\\`\n    )\n        SELECT address,\n                token_id,\n                SUM(\\`value\\`), -- unlocked_balance\n                0,\n                BIT_OR(\\`authorities\\`), -- unlocked_authorities\n                0, -- locked_authorities\n                NULL, -- timelock_expires\n                0 -- transactions\n          FROM \\`tx_output\\`\n         WHERE spent_by IS NULL\n           AND voided = FALSE\n           AND locked = FALSE\n           AND address IN (?)\n      GROUP BY address, token_id\n   ON DUPLICATE KEY UPDATE\n    unlocked_balance = VALUES(unlocked_balance),\n    unlocked_authorities = VALUES(unlocked_authorities)\n  `, [addresses]);\n    await mysql.query(`\n    INSERT INTO \\`address_balance\\` (\n      \\`address\\`,\n      \\`token_id\\`,\n      \\`unlocked_balance\\`,\n      \\`locked_balance\\`,\n      \\`locked_authorities\\`,\n      \\`timelock_expires\\`,\n      \\`transactions\\`\n    )\n       SELECT address,\n              token_id,\n              0 AS unlocked_balance,\n              SUM(\\`value\\`) AS locked_balance,\n              BIT_OR(\\`authorities\\`) AS locked_authorities,\n              MIN(\\`timelock\\`) AS timelock_expires,\n              0 -- transactions\n         FROM \\`tx_output\\`\n        WHERE spent_by IS NULL\n          AND voided = FALSE\n          AND locked = TRUE\n          AND address IN (?)\n     GROUP BY \\`address\\`, \\`token_id\\`\n   ON DUPLICATE KEY UPDATE\n    locked_balance = VALUES(locked_balance),\n    locked_authorities = VALUES(locked_authorities),\n    timelock_expires = VALUES(timelock_expires)\n   `, [addresses]);\n    const addressTransactionCount = await (0, exports.getAffectedAddressTxCountFromTxList)(mysql, txList);\n    const addressTotalReceived = await (0, exports.getAffectedAddressTotalReceivedFromTxList)(mysql, txList);\n    const tokenTransactionCount = await (0, exports.getAffectedTokenTxCountFromTxList)(mysql, txList);\n    const finalValues = oldAddressTokenTransactions.map(({ address, tokenId, transactions, totalReceived }) => {\n        const diffTransactions = addressTransactionCount[`${address}_${tokenId}`] || 0;\n        const diffTotalReceived = addressTotalReceived[`${address}_${tokenId}`] || 0;\n        return [transactions - diffTransactions, totalReceived - diffTotalReceived, address, tokenId];\n    });\n    for (const item of finalValues) {\n        await mysql.query(`\n      UPDATE \\`address_balance\\`\n        SET \\`transactions\\` = ?,\n            \\`total_received\\` = ?\n       WHERE \\`address\\` = ?\n         AND \\`token_id\\` = ?\n    `, item);\n    }\n    for (const token of Object.keys(tokenTransactionCount)) {\n        await mysql.query(`\n      UPDATE \\`token\\`\n        SET \\`transactions\\` = \\`transactions\\` - ?\n       WHERE \\`id\\` = ?\n    `, [tokenTransactionCount[token], token]);\n    }\n};\nexports.rebuildAddressBalancesFromUtxos = rebuildAddressBalancesFromUtxos;\nconst fetchTx = async (mysql, txId) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`transaction\\`\n      WHERE \\`tx_id\\` = ?\n        AND \\`voided\\` = FALSE`, [txId]);\n    const txResult = (0, utils_2.getTxsFromDBResult)(results);\n    return (0, lodash_1.get)(txResult, '[0]', null);\n};\nexports.fetchTx = fetchTx;\nconst fetchAddressBalance = async (mysql, addresses) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`address_balance\\`\n      WHERE \\`address\\` IN (?)\n   ORDER BY \\`address\\`, \\`token_id\\``, [addresses]);\n    return results.map((result) => ({\n        address: result.address,\n        tokenId: result.token_id,\n        unlockedBalance: result.unlocked_balance,\n        lockedBalance: result.locked_balance,\n        lockedAuthorities: result.locked_authorities,\n        unlockedAuthorities: result.unlocked_authorities,\n        timelockExpires: result.timelock_expires,\n        transactions: result.transactions,\n    }));\n};\nexports.fetchAddressBalance = fetchAddressBalance;\nconst fetchAddressTxHistorySum = async (mysql, addresses) => {\n    const results = await mysql.query(`SELECT address,\n            token_id,\n            SUM(\\`balance\\`) AS balance,\n            COUNT(\\`tx_id\\`) AS transactions\n       FROM \\`address_tx_history\\`\n      WHERE \\`address\\` IN (?)\n        AND \\`voided\\` = FALSE\n   GROUP BY address, token_id\n   ORDER BY address, token_id`, [addresses]);\n    return results.map((result) => ({\n        address: result.address,\n        tokenId: result.token_id,\n        balance: result.balance,\n        transactions: result.transactions,\n    }));\n};\nexports.fetchAddressTxHistorySum = fetchAddressTxHistorySum;\nconst filterTxOutputs = async (mysql, filters = { addresses: [] }) => {\n    const finalFilters = Object.assign({ addresses: [], tokenId: '00', authority: 0, ignoreLocked: false, skipSpent: true, biggerThan: -1, smallerThan: wallet_lib_1.constants.MAX_OUTPUT_VALUE + 1 }, filters);\n    if (finalFilters.addresses.length === 0) {\n        throw new Error('Addresses can\\'t be empty.');\n    }\n    const queryParams = [\n        finalFilters.addresses,\n        finalFilters.tokenId,\n    ];\n    if (finalFilters.authority === 0) {\n        queryParams.push(finalFilters.smallerThan);\n        queryParams.push(finalFilters.biggerThan);\n    }\n    else {\n        queryParams.push(finalFilters.authority);\n    }\n    queryParams.push(finalFilters.maxOutputs);\n    const results = await mysql.query(`SELECT *\n       FROM \\`tx_output\\`\n      WHERE \\`address\\`\n         IN (?)\n        AND \\`token_id\\` = ?\n        ${finalFilters.authority !== 0 ? 'AND `authorities` & ? > 0' : 'AND `authorities` = 0'}\n        ${finalFilters.ignoreLocked ? 'AND `locked` = FALSE' : ''}\n        ${finalFilters.authority === 0 ? 'AND value < ?' : ''}\n        ${finalFilters.authority === 0 ? 'AND value > ?' : ''}\n        ${finalFilters.skipSpent ? 'AND `spent_by` IS NULL' : ''}\n        ${finalFilters.skipSpent ? 'AND `tx_proposal` IS NULL' : ''}\n        AND \\`voided\\` = FALSE\n   ORDER BY \\`value\\` DESC\n        ${finalFilters.maxOutputs ? 'LIMIT ?' : ''}\n       `, queryParams);\n    const utxos = results.map(exports.mapDbResultToDbTxOutput);\n    return utxos;\n};\nexports.filterTxOutputs = filterTxOutputs;\nconst mapDbResultToDbTxOutput = (result) => ({\n    txId: result.tx_id,\n    index: result.index,\n    tokenId: result.token_id,\n    address: result.address,\n    value: result.value,\n    authorities: result.authorities,\n    timelock: result.timelock,\n    heightlock: result.heightlock,\n    locked: result.locked > 0,\n    txProposalId: result.tx_proposal,\n    txProposalIndex: result.tx_proposal_index,\n    spentBy: result.spent_by,\n});\nexports.mapDbResultToDbTxOutput = mapDbResultToDbTxOutput;\nconst getTxProposalInputs = async (mysql, txProposalId) => {\n    const inputs = [];\n    const results = await mysql.query('SELECT * FROM `tx_output` WHERE `tx_proposal` = ? ORDER BY `tx_proposal_index` ASC', [txProposalId]);\n    for (const result of results) {\n        const input = {\n            txId: result.tx_id,\n            index: result.index,\n        };\n        inputs.push(input);\n    }\n    return inputs;\n};\nexports.getTxProposalInputs = getTxProposalInputs;\nconst getMempoolTransactionsBeforeDate = async (mysql, date) => {\n    const results = await mysql.query(`SELECT *\n       FROM \\`transaction\\`\n      WHERE \\`timestamp\\` < ?\n        AND \\`voided\\` = FALSE\n        AND \\`height\\` IS NULL`, [date]);\n    return (0, utils_2.getTxsFromDBResult)(results);\n};\nexports.getMempoolTransactionsBeforeDate = getMempoolTransactionsBeforeDate;\nconst addMiner = async (mysql, address, txId) => {\n    await mysql.query(`INSERT INTO \\`miner\\` (address, first_block, last_block, count)\n     VALUES (?, ?, ?, 1)\n         ON DUPLICATE KEY UPDATE last_block = ?, count = count + 1`, [address, txId, txId, txId]);\n};\nexports.addMiner = addMiner;\nconst getMinersList = async (mysql) => {\n    const results = await mysql.query(`\n    SELECT address, first_block, last_block, count\n      FROM miner;\n  `);\n    const minerList = [];\n    for (const result of results) {\n        minerList.push({\n            address: result.address,\n            firstBlock: result.first_block,\n            lastBlock: result.last_block,\n            count: result.count,\n        });\n    }\n    return minerList;\n};\nexports.getMinersList = getMinersList;\nconst getTotalSupply = async (mysql, tokenId) => {\n    const results = await mysql.query(`\n    SELECT SUM(value) as value\n      FROM tx_output\n     WHERE spent_by IS NULL\n       AND token_id = ?\n       AND voided = FALSE\n       AND address != '${BURN_ADDRESS}'\n  `, [tokenId]);\n    if (!results.length) {\n        await (0, alerting_utils_1.addAlert)('Total supply query returned no results', '-', types_1.Severity.MINOR, { tokenId });\n        throw new Error('Total supply query returned no results');\n    }\n    return results[0].value;\n};\nexports.getTotalSupply = getTotalSupply;\nconst getExpiredTimelocksUtxos = async (mysql, now) => {\n    const results = await mysql.query(`\n    SELECT *\n      FROM tx_output\n     WHERE locked = TRUE\n       AND timelock IS NOT NULL\n       AND timelock < ?\n  `, [now]);\n    const lockedUtxos = results.map(exports.mapDbResultToDbTxOutput);\n    return lockedUtxos;\n};\nexports.getExpiredTimelocksUtxos = getExpiredTimelocksUtxos;\nconst getTotalTransactions = async (mysql, tokenId) => {\n    const results = await mysql.query(`\n    SELECT COUNT(DISTINCT(tx_id)) AS count\n      FROM address_tx_history\n     WHERE token_id = ?\n       AND voided = FALSE\n  `, [tokenId]);\n    if (!results.length) {\n        await (0, alerting_utils_1.addAlert)('Total transactions query returned no results', '-', types_1.Severity.MINOR, { tokenId });\n        throw new Error('Total transactions query returned no results');\n    }\n    return results[0].count;\n};\nexports.getTotalTransactions = getTotalTransactions;\nconst getAvailableAuthorities = async (mysql, tokenId) => {\n    const results = await mysql.query(`\n  SELECT *\n    FROM tx_output\n   WHERE authorities > 0\n     AND token_id = ?\n     AND voided = FALSE\n     AND locked = FALSE\n     AND spent_by IS NULL\n  `, [tokenId]);\n    const utxos = results.map(exports.mapDbResultToDbTxOutput);\n    return utxos;\n};\nexports.getAvailableAuthorities = getAvailableAuthorities;\nconst getAffectedAddressTxCountFromTxList = async (mysql, txList) => {\n    const results = await mysql.query(`\n    SELECT address, COUNT(DISTINCT(tx_id)) AS txCount, token_id as tokenId\n      FROM address_tx_history\n     WHERE tx_id IN (?)\n       AND voided = TRUE\n  GROUP BY address, token_id\n  `, [txList]);\n    const addressTransactions = results.reduce((acc, result) => {\n        const address = result.address;\n        const txCount = result.txCount;\n        const tokenId = result.tokenId;\n        acc[`${address}_${tokenId}`] = txCount;\n        return acc;\n    }, {});\n    return addressTransactions;\n};\nexports.getAffectedAddressTxCountFromTxList = getAffectedAddressTxCountFromTxList;\nconst getAffectedTokenTxCountFromTxList = async (mysql, txList) => {\n    const results = await mysql.query(`\n    SELECT token_id AS tokenId, COUNT(DISTINCT(tx_id)) AS txCount\n      FROM address_tx_history\n     WHERE tx_id IN (?)\n       AND voided = TRUE\n  GROUP BY token_id\n  `, [txList]);\n    const tokenTransactions = results.reduce((acc, result) => {\n        const tokenId = result.tokenId;\n        const txCount = result.txCount;\n        acc[tokenId] = txCount;\n        return acc;\n    }, {});\n    return tokenTransactions;\n};\nexports.getAffectedTokenTxCountFromTxList = getAffectedTokenTxCountFromTxList;\nconst getAffectedAddressTotalReceivedFromTxList = async (mysql, txList) => {\n    const results = await mysql.query(`\n    SELECT address, token_id as tokenId, SUM(value) as total\n      FROM tx_output\n     WHERE tx_id IN (?)\n       AND voided = TRUE\n  GROUP BY address, token_id\n  `, [txList]);\n    const addressTotalReceivedMap = results.reduce((acc, result) => {\n        const address = result.address;\n        const total = result.total;\n        const tokenId = result.tokenId;\n        acc[`${address}_${tokenId}`] = total;\n        return acc;\n    }, {});\n    return addressTotalReceivedMap;\n};\nexports.getAffectedAddressTotalReceivedFromTxList = getAffectedAddressTotalReceivedFromTxList;\nconst incrementTokensTxCount = async (mysql, tokenList) => {\n    await mysql.query(`\n    UPDATE \\`token\\`\n       SET \\`transactions\\` = \\`transactions\\` + 1\n     WHERE \\`id\\` IN (?)\n  `, [tokenList]);\n};\nexports.incrementTokensTxCount = incrementTokensTxCount;\nconst existsPushDevice = async (mysql, deviceId, walletId) => {\n    const [{ count }] = await mysql.query(`\n    SELECT COUNT(1) as \\`count\\`\n      FROM \\`push_devices\\` pd\n     WHERE device_id = ?\n       AND wallet_id = ?`, [deviceId, walletId]);\n    return count > 0;\n};\nexports.existsPushDevice = existsPushDevice;\nconst registerPushDevice = async (mysql, input) => {\n    await mysql.query(`\n    INSERT\n      INTO \\`push_devices\\` (\n           device_id\n         , wallet_id\n         , push_provider\n         , enable_push\n         , enable_show_amounts)\n    VALUES (?, ?, ?, ?, ?)\n        ON DUPLICATE KEY UPDATE\n           updated_at = CURRENT_TIMESTAMP`, [input.deviceId, input.walletId, input.pushProvider, input.enablePush, input.enableShowAmounts]);\n};\nexports.registerPushDevice = registerPushDevice;\nconst removeAllPushDevicesByDeviceId = async (mysql, deviceId) => {\n    await mysql.query(`\n     DELETE\n       FROM \\`push_devices\\`\n      WHERE\n  device_id = ?\n    `, [deviceId]);\n};\nexports.removeAllPushDevicesByDeviceId = removeAllPushDevicesByDeviceId;\nconst updatePushDevice = async (mysql, input) => {\n    await mysql.query(`\n    UPDATE \\`push_devices\\`\n       SET enable_push = ?\n         , enable_show_amounts = ?\n     WHERE device_id = ?\n       AND wallet_id = ?`, [input.enablePush, input.enableShowAmounts, input.deviceId, input.walletId]);\n};\nexports.updatePushDevice = updatePushDevice;\nconst unregisterPushDevice = async (mysql, deviceId, walletId) => {\n    if (walletId) {\n        await mysql.query(`\n      DELETE\n        FROM \\`push_devices\\`\n       WHERE device_id = ?\n         AND wallet_id = ?`, [deviceId, walletId]);\n    }\n    else {\n        await mysql.query(`\n      DELETE\n        FROM \\`push_devices\\`\n       WHERE device_id = ?`, [deviceId]);\n    }\n};\nexports.unregisterPushDevice = unregisterPushDevice;\nconst getTransactionById = async (mysql, txId, walletId) => {\n    const result = await mysql.query(`\n       SELECT\n              transaction.tx_id AS tx_id\n            , transaction.timestamp AS timestamp\n            , transaction.version AS version\n            , transaction.voided AS voided\n            , transaction.height AS height\n            , transaction.weight AS weight\n            , wallet_tx_history.balance AS balance\n            , wallet_tx_history.token_id AS token_id\n            , token.name AS name\n            , token.symbol AS symbol\n         FROM wallet_tx_history\n   INNER JOIN transaction ON transaction.tx_id = wallet_tx_history.tx_id\n   INNER JOIN token ON wallet_tx_history.token_id = token.id\n        WHERE transaction.tx_id = ?\n          AND transaction.voided = FALSE\n          AND wallet_tx_history.wallet_id = ?`, [txId, walletId]);\n    const txTokens = [];\n    result.forEach((eachTxToken) => {\n        const txToken = {\n            txId: eachTxToken.tx_id,\n            timestamp: eachTxToken.timestamp,\n            version: eachTxToken.version,\n            voided: !!eachTxToken.voided,\n            weight: eachTxToken.weight,\n            balance: eachTxToken.balance,\n            tokenId: eachTxToken.token_id,\n            tokenName: eachTxToken.name,\n            tokenSymbol: eachTxToken.symbol,\n        };\n        txTokens.push(txToken);\n    });\n    return txTokens;\n};\nexports.getTransactionById = getTransactionById;\nconst existsWallet = async (mysql, walletId) => {\n    const [{ count }] = (await mysql.query(`\n    SELECT COUNT(1) as \\`count\\`\n      FROM \\`wallet\\` pd\n     WHERE id = ?`, [walletId]));\n    return count > 0;\n};\nexports.existsWallet = existsWallet;\nconst getPushDevice = async (mysql, deviceId) => {\n    const [pushDevice] = await mysql.query(`\n    SELECT *\n      FROM \\`push_devices\\`\n     WHERE device_id = ?`, [deviceId]);\n    if (!pushDevice) {\n        return null;\n    }\n    return {\n        walletId: pushDevice.wallet_id,\n        deviceId: pushDevice.device_id,\n        pushProvider: pushDevice.push_provider,\n        enablePush: !!pushDevice.enable_push,\n        enableShowAmounts: !!pushDevice.enable_show_amounts,\n    };\n};\nexports.getPushDevice = getPushDevice;\nconst getPushDeviceSettingsList = async (mysql, walletIdList) => {\n    const pushDeviceSettingsResult = await mysql.query(`\n    SELECT wallet_id\n         , device_id\n         , enable_push\n         , enable_show_amounts\n      FROM \\`push_devices\\`\n     WHERE wallet_id in (?)`, [walletIdList]);\n    const pushDeviceSettignsList = pushDeviceSettingsResult.map((each) => ({\n        walletId: each.wallet_id,\n        deviceId: each.device_id,\n        enablePush: !!each.enable_push,\n        enableShowAmounts: !!each.enable_show_amounts,\n    }));\n    return pushDeviceSettignsList;\n};\nexports.getPushDeviceSettingsList = getPushDeviceSettingsList;\nconst countStalePushDevices = async (mysql) => {\n    const [{ count }] = await mysql.query(`\n    SELECT COUNT(device_id) as count\n      FROM \\`push_devices\\`\n     WHERE UNIX_TIMESTAMP(updated_at) < UNIX_TIMESTAMP(date_sub(now(), interval 1 month))`);\n    return count;\n};\nexports.countStalePushDevices = countStalePushDevices;\nconst deleteStalePushDevices = async (mysql) => {\n    await mysql.query(`\n    DELETE\n      FROM \\`push_devices\\`\n     WHERE UNIX_TIMESTAMP(updated_at) < UNIX_TIMESTAMP(date_sub(now(), interval 1 month))`);\n};\nexports.deleteStalePushDevices = deleteStalePushDevices;\nconst getTokenSymbols = async (mysql, tokenIdList) => {\n    if (tokenIdList.length === 0)\n        return null;\n    const results = await mysql.query('SELECT `id`, `symbol` FROM `token` WHERE `id` IN (?)', [tokenIdList]);\n    if (results.length === 0)\n        return null;\n    return results.reduce((prev, token) => {\n        prev[token.id] = token.symbol;\n        return prev;\n    }, {});\n};\nexports.getTokenSymbols = getTokenSymbols;\nconst getUnsentTxProposals = async (mysql, txProposalsBefore) => {\n    const result = await mysql.query(`\n    SELECT id\n      FROM \\`tx_proposal\\`\n     WHERE created_at < ?\n       AND status IN (?)`, [txProposalsBefore, [\n            types_1.TxProposalStatus.OPEN,\n            types_1.TxProposalStatus.SEND_ERROR,\n            types_1.TxProposalStatus.CANCELLED,\n        ]]);\n    return result.map((row) => row.id);\n};\nexports.getUnsentTxProposals = getUnsentTxProposals;\nconst getAddressAtIndex = async (mysql, walletId, index) => {\n    const addresses = await mysql.query(`\n    SELECT \\`address\\`, \\`index\\`, \\`transactions\\`\n      FROM \\`address\\` pd\n     WHERE \\`index\\` = ?\n       AND \\`wallet_id\\` = ?\n     LIMIT 1`, [walletId, index]);\n    if (addresses.length <= 0) {\n        return null;\n    }\n    return {\n        address: addresses[0].address,\n        index: addresses[0].index,\n        transactions: addresses[0].transactions,\n    };\n};\nexports.getAddressAtIndex = getAddressAtIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGIvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7OztBQU1BO0FBRUE7QUFFQTtBQUNBO0FBaUNBO0FBT0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUNBOztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBZkE7QUE0QkE7QUFDQTs7QUFHQTtBQUlBOztBQUdBO0FBSUE7O0FBR0E7QUFJQTs7QUFHQTtBQUdBO0FBNUJBO0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBTUE7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVEQTtBQXlFQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFrQkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9CQTtBQXdDQTtBQU1BO0FBQ0E7Ozs7QUFLQTtBQUdBO0FBZkE7QUF3QkE7QUFLQTs7QUFHQTtBQUdBO0FBWEE7QUF1QkE7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUtBOztBQUdBO0FBR0E7QUF6QkE7QUFxQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTs7O0FBSUE7QUFHQTtBQUNBO0FBWkE7QUFzQkE7QUFDQTs7OztBQUlBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQXJCQTtBQWlDQTtBQUdBO0FBQUE7QUFFQTs7Ozs7Ozs7O0FBVUE7QUFHQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFHQTtBQS9CQTtBQTJDQTtBQUdBOzs7Ozs7Ozs7QUFVQTtBQUtBOzs7Ozs7O0FBUUE7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBO0FBR0E7QUFDQTtBQTNEQTtBQXlFQTtBQU1BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFLQTtBQUtBOzs7Ozs7Ozs7O0FBV0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUlBO0FBR0E7QUFDQTtBQWhGQTtBQThGQTtBQU9BO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7O0FBS0E7QUFHQTtBQTFDQTtBQXdEQTtBQUFBO0FBcUJBO0FBUUE7QUFFQTs7QUFHQTtBQUdBO0FBaEJBO0FBeUJBO0FBQ0E7QUFFQTtBQW1CQTs7O0FBSUE7QUFJQTtBQUtBO0FBQ0E7QUFwQ0E7QUErQ0E7QUFNQTs7OztBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQXpCQTtBQW9DQTtBQUtBOzs7Ozs7QUFPQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBeEJBO0FBaUNBO0FBSUE7QUFDQTs7Ozs7QUFNQTtBQUlBO0FBRUE7QUFDQTtBQWxCQTtBQStCQTtBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeENBO0FBZ0RBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUlBO0FBR0E7QUFWQTtBQTJCQTtBQUNBO0FBRUE7QUFFQTs7Ozs7O0FBT0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBOUJBO0FBNENBO0FBY0E7QUFDQTs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBUUE7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBRUE7OztBQUlBO0FBR0E7QUFqR0E7QUE4R0E7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFHQTtBQUdBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUEzREE7QUF3RUE7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFFQTtBQUlBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUdBO0FBR0E7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUF2REE7QUFpRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkJBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBMUNBO0FBaURBO0FBSUE7QUFDQTs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFqQkE7QUFvQ0E7QUFPQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcENBO0FBbURBO0FBS0E7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbENBO0FBaURBO0FBTUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRDQTtBQThDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBcEJBO0FBNEJBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQXhCQTtBQWdDQTtBQUNBOzs7Ozs7QUFPQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFqQkE7QUEwQkE7QUFDQTs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBbEJBO0FBNEJBO0FBQ0E7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQWxCQTtBQTRCQTtBQU1BO0FBQ0E7QUFJQTtBQVhBO0FBb0JBO0FBSUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQVZBO0FBc0JBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBcUJBO0FBQ0E7QUFDQTs7OztBQUtBO0FBR0E7QUFWQTtBQW9CQTtBQU1BO0FBQ0E7QUFJQTtBQVhBO0FBcUJBO0FBTUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQXdCQTtBQUlBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUF3QkE7QUFJQTs7O0FBSUE7QUFJQTtBQUtBO0FBakJBO0FBMkJBO0FBSUE7OztBQUlBO0FBSUE7QUFDQTtBQWJBO0FBdUJBO0FBSUE7QUFDQTs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFoQ0E7QUEwQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7O0FBSUE7QUFJQTtBQUNBO0FBakJBO0FBMkJBO0FBSUE7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBaENBO0FBd0NBO0FBSUE7QUFFQTs7QUFHQTtBQUdBO0FBWkE7QUFvQkE7QUFJQTtBQUVBOztBQUdBO0FBR0E7QUFaQTtBQW9CQTtBQUlBO0FBRUE7OztBQUdBO0FBRUE7QUFYQTtBQW1CQTtBQUlBOztBQUdBO0FBR0E7QUFWQTtBQWtCQTtBQUlBO0FBRUE7O0FBR0E7QUFHQTtBQVpBO0FBb0JBO0FBSUE7QUFFQTs7QUFHQTtBQUdBO0FBWkE7QUFvQkE7QUFJQTtBQUVBOztBQUdBO0FBR0E7QUFaQTtBQXNCQTtBQUtBO0FBR0E7QUFDQTtBQUVBOztBQUdBO0FBS0E7Ozs7Ozs7QUFRQTtBQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQTVIQTtBQW9JQTtBQUlBOzs7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQWRBO0FBc0JBO0FBSUE7OztBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQThCQTtBQUlBOzs7Ozs7OztBQVNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUErQkE7QUFJQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQXZEQTtBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUF5QkE7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBMkJBO0FBSUE7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFkQTtBQXFCQTtBQUtBOztBQUdBO0FBR0E7QUFYQTtBQW9CQTtBQUdBOzs7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFwQkE7QUE2QkE7QUFJQTs7Ozs7O0FBTUE7QUFDQTtBQUVBO0FBRUE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQXpCQTtBQW1DQTtBQUlBOzs7Ozs7QUFNQTtBQUVBO0FBRUE7QUFDQTtBQWZBO0FBeUJBO0FBSUE7Ozs7O0FBS0E7QUFFQTtBQUVBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUF2QkE7QUFpQ0E7QUFXQTs7Ozs7Ozs7QUFRQTtBQUVBO0FBRUE7QUFDQTtBQXhCQTtBQW1DQTtBQUlBOzs7Ozs7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQXZCQTtBQWtDQTtBQUlBOzs7Ozs7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUF0QkE7QUFnQ0E7QUFJQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUF2QkE7QUErQkE7QUFJQTs7OztBQUlBO0FBQ0E7QUFUQTtBQWtCQTtBQUtBOzs7O0FBS0E7QUFJQTtBQUNBO0FBZkE7QUF1QkE7QUFVQTs7Ozs7Ozs7OztBQVdBO0FBR0E7QUF4QkE7QUFnQ0E7QUFDQTs7Ozs7QUFNQTtBQUdBO0FBVkE7QUFrQkE7QUFTQTs7Ozs7QUFNQTtBQUdBO0FBbEJBO0FBMkJBO0FBS0E7QUFDQTs7OztBQUtBO0FBR0E7QUFBQTtBQUNBOzs7QUFJQTtBQUdBO0FBQ0E7QUF2QkE7QUFpQ0E7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBM0NBO0FBbURBO0FBSUE7OztBQUlBO0FBSUE7QUFDQTtBQWJBO0FBcUJBO0FBSUE7OztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQWlDQTtBQUlBOzs7Ozs7QUFPQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUF4QkE7QUFnQ0E7QUFDQTs7O0FBSUE7QUFFQTtBQUNBO0FBUkE7QUFlQTtBQUNBOzs7QUFJQTtBQUVBO0FBUEE7QUFnQkE7QUFJQTtBQUFBO0FBRUE7QUFLQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQTBCQTtBQUlBOzs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFsQkE7QUE2QkE7QUFLQTs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1zZXJ2aWNlLy4vc3JjL2RiL2luZGV4LnRzPzAwMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEhhdGhvciBMYWJzIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IHsgc3RyaWN0IGFzIGFzc2VydCB9IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBTZXJ2ZXJsZXNzTXlzcWwgfSBmcm9tICdzZXJ2ZXJsZXNzLW15c3FsJztcbmltcG9ydCB7IGdldCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBPa1BhY2tldCB9IGZyb20gJ215c3FsJztcbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJ0BoYXRob3Ivd2FsbGV0LWxpYic7XG5pbXBvcnQge1xuICBBZGRyZXNzSW5kZXhNYXAsXG4gIEFkZHJlc3NJbmZvLFxuICBBdXRob3JpdGllcyxcbiAgQmFsYW5jZSxcbiAgRGJTZWxlY3RSZXN1bHQsXG4gIEdlbmVyYXRlQWRkcmVzc2VzLFxuICBJV2FsbGV0SW5wdXQsXG4gIFNob3J0QWRkcmVzc0luZm8sXG4gIFN0cmluZ01hcCxcbiAgVG9rZW5CYWxhbmNlTWFwLFxuICBUb2tlbkluZm8sXG4gIFR4SW5wdXQsXG4gIFR4T3V0cHV0V2l0aEluZGV4LFxuICBUeFByb3Bvc2FsLFxuICBUeFByb3Bvc2FsU3RhdHVzLFxuICBUeFRva2VuQmFsYW5jZSxcbiAgRGJUeE91dHB1dCxcbiAgV2FsbGV0LFxuICBXYWxsZXRTdGF0dXMsXG4gIFdhbGxldFRva2VuQmFsYW5jZSxcbiAgRnVsbE5vZGVWZXJzaW9uRGF0YSxcbiAgQmxvY2ssXG4gIFR4LFxuICBBZGRyZXNzQmFsYW5jZSxcbiAgQWRkcmVzc1RvdGFsQmFsYW5jZSxcbiAgSUZpbHRlclR4T3V0cHV0LFxuICBNaW5lcixcbiAgUHVzaERldmljZSxcbiAgVHhCeUlkVG9rZW4sXG4gIFB1c2hEZXZpY2VTZXR0aW5ncyxcbiAgU2V2ZXJpdHksXG59IGZyb20gJ0BzcmMvdHlwZXMnO1xuaW1wb3J0IHtcbiAgZ2V0VW5peFRpbWVzdGFtcCxcbiAgaXNBdXRob3JpdHksXG4gIGdldEFkZHJlc3NQYXRoLFxuICB4cHViRGVyaXZlQ2hpbGQsXG4gIGdldEFkZHJlc3Nlcyxcbn0gZnJvbSAnQHNyYy91dGlscyc7XG5pbXBvcnQge1xuICBnZXRXYWxsZXRGcm9tRGJFbnRyeSxcbiAgZ2V0VHhzRnJvbURCUmVzdWx0LFxufSBmcm9tICdAc3JjL2RiL3V0aWxzJztcbmltcG9ydCB7IGFkZEFsZXJ0IH0gZnJvbSAnQHNyYy91dGlscy9hbGVydGluZy51dGlscyc7XG5cbmNvbnN0IEJMT0NLX1ZFUlNJT04gPSBbXG4gIGNvbnN0YW50cy5CTE9DS19WRVJTSU9OLFxuICBjb25zdGFudHMuTUVSR0VEX01JTkVEX0JMT0NLX1ZFUlNJT04sXG5dO1xuY29uc3QgQlVSTl9BRERSRVNTID0gJ0hEZWFkRGVhZERlYWREZWFkRGVhZERlYWREZWFnVFBnbW4nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHRyYW5zYWN0aW9uIHdhcyBvbiB0aGUgZGF0YWJhc2UgaW4gdGhlIHBhc3QgYW5kIGdvdCB2b2lkZWQuXG4gKlxuICogQHJlbWFya3NcbiAqIFNpbmNlIHdlIGRlbGV0ZSB0cmFuc2FjdGlvbnMgZnJvbSB0aGUgdHJhbnNhY3Rpb25zIHRhYmxlIHdoZW4gaXQncyB2b2lkZWQsXG4gKiB3ZSBjYW4gdXNlIHRoZSBhZGRyZXNzX3R4X2hpc3RvcnkgdGFibGUgKHdoaWNoIHN0b3JlcyB2b2lkZWQgdHhzKSB0byBjaGVja1xuICogaWYgaXQncyB0aGVyZS5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHhJZCAtIFRoZSB0cmFuc2FjdGlvbiBpZCB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJucyBUcnVlIG9yIEZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja1R4V2FzVm9pZGVkID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIHR4SWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgKiBGUk9NIFxcYGFkZHJlc3NfdHhfaGlzdG9yeVxcYFxuICAgICAgV0hFUkUgdHhfaWQgPSA/XG4gICAgICBMSU1JVCAxYCxcbiAgICBbdHhJZF0sXG4gICk7XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFkZHJlc3NUeEhpc3RvcnkgPSByZXN1bHRzWzBdO1xuXG4gIHJldHVybiBCb29sZWFuKGFkZHJlc3NUeEhpc3Rvcnkudm9pZGVkKTtcbn07XG5cbi8qKlxuICogQ2xlYW51cCBhbGwgcmVjb3JkcyBmcm9tIGEgdHJhbnNhY3Rpb24gdGhhdCB3YXMgdm9pZGVkIGluIHRoZSBwYXN0XG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZG9lcyBub3QgcmUtY2FsY3VsYXRlcyBiYWxhbmNlcywgc28gaXQncyBvbmx5IHN1cHBvc2VkIHRvIGJlIHVzZWQgdG8gY2xlYXJcbiAqIHRoZSB0eF9vdXRwdXQsIGFkZHJlc3NfdHhfaGlzdG9yeSBhbmQgd2FsbGV0X3R4X2hpc3RvcnkgdGFibGVzIGFmdGVyIHRoZVxuICogaGFuZGxlUmVvcmcgbWV0aG9kIHZvaWRlZCB0aGlzIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHR4SWQgLSBUaGUgdHJhbnNhY3Rpb24gdG8gY2xlYXIgZnJvbSBkYXRhYmFzZVxuICovXG5leHBvcnQgY29uc3QgY2xlYW51cFZvaWRlZFR4ID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIHR4SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgREVMRVRFIEZST00gXFxgdHJhbnNhY3Rpb25cXGBcbiAgICAgIFdIRVJFIHR4X2lkID0gP1xuICAgICAgICBBTkQgdm9pZGVkID0gdHJ1ZWAsXG4gICAgW3R4SWRdLFxuICApO1xuXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBERUxFVEUgRlJPTSBcXGB0eF9vdXRwdXRcXGBcbiAgICAgIFdIRVJFIHR4X2lkID0gP1xuICAgICAgICBBTkQgdm9pZGVkID0gdHJ1ZWAsXG4gICAgW3R4SWRdLFxuICApO1xuXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBERUxFVEUgRlJPTSBcXGBhZGRyZXNzX3R4X2hpc3RvcnlcXGBcbiAgICAgIFdIRVJFIHR4X2lkID0gP1xuICAgICAgICBBTkQgdm9pZGVkID0gdHJ1ZWAsXG4gICAgW3R4SWRdLFxuICApO1xuXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBERUxFVEUgRlJPTSBcXGB3YWxsZXRfdHhfaGlzdG9yeVxcYFxuICAgICAgV0hFUkUgdHhfaWQgPSA/XG4gICAgICAgIEFORCB2b2lkZWQgPSB0cnVlYCxcbiAgICBbdHhJZF0sXG4gICk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIHhwdWJrZXksIGdlbmVyYXRlIGl0cyBhZGRyZXNzZXMuXG4gKlxuICogQHJlbWFya3NcbiAqIEFsc28sIGNoZWNrIHdoaWNoIGFkZHJlc3NlcyBhcmUgdXNlZCwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgbWF4aW11bSBnYXAgb2YgdW51c2VkIGFkZHJlc3NlcyAobWF4R2FwKS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lc24ndCB1cGRhdGUgYW55dGhpbmcgb24gdGhlIGRhdGFiYXNlLCBqdXN0IHJlYWRzIGRhdGEgZnJvbSBpdC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0geHB1YmtleSAtIFRoZSB4cHVia2V5XG4gKiBAcGFyYW0gbWF4R2FwIC0gTnVtYmVyIG9mIGFkZHJlc3NlcyB0aGF0IHNob3VsZCBoYXZlIG5vIHRyYW5zYWN0aW9ucyBiZWZvcmUgd2UgY29uc2lkZXIgYWxsIGFkZHJlc3NlcyBsb2FkZWRcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGFsbCBhZGRyZXNzZXMgZm9yIHRoZSBnaXZlbiB4cHVia2V5IGFuZCBjb3JyZXNwb25kaW5nIGluZGV4XG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUFkZHJlc3NlcyA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCB4cHVia2V5OiBzdHJpbmcsIG1heEdhcDogbnVtYmVyKTogUHJvbWlzZTxHZW5lcmF0ZUFkZHJlc3Nlcz4gPT4ge1xuICBjb25zdCBleGlzdGluZ0FkZHJlc3NlczogQWRkcmVzc0luZGV4TWFwID0ge307XG4gIGNvbnN0IG5ld0FkZHJlc3NlczogQWRkcmVzc0luZGV4TWFwID0ge307XG4gIGNvbnN0IGFsbEFkZHJlc3Nlczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBXZSBjdXJyZW50bHkgZ2VuZXJhdGUgb25seSBhZGRyZXNzZXMgaW4gY2hhbmdlIGRlcml2YXRpb24gcGF0aCAwXG4gIC8vIChtb3JlIGRldGFpbHMgaW4gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA0NC5tZWRpYXdpa2kjQ2hhbmdlKVxuICAvLyBzbyB3ZSBkZXJpdmUgb3VyIHhwdWIgdG8gdGhpcyBwYXRoIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBhZGRyZXNzZXNcbiAgY29uc3QgZGVyaXZlZFhwdWIgPSB4cHViRGVyaXZlQ2hpbGQoeHB1YmtleSwgMCk7XG5cbiAgbGV0IGhpZ2hlc3RDaGVja2VkSW5kZXggPSAtMTtcbiAgbGV0IGxhc3RVc2VkQWRkcmVzc0luZGV4ID0gLTE7XG4gIGRvIHtcbiAgICBjb25zdCBhZGRyTWFwID0gZ2V0QWRkcmVzc2VzKGRlcml2ZWRYcHViLCBoaWdoZXN0Q2hlY2tlZEluZGV4ICsgMSwgbWF4R2FwKTtcbiAgICBhbGxBZGRyZXNzZXMucHVzaCguLi5PYmplY3Qua2V5cyhhZGRyTWFwKSk7XG5cbiAgICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgYFNFTEVDVCBcXGBhZGRyZXNzXFxgLFxuICAgICAgICAgICAgICBcXGBpbmRleFxcYCxcbiAgICAgICAgICAgICAgXFxgdHJhbnNhY3Rpb25zXFxgXG4gICAgICAgICBGUk9NIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgV0hFUkUgXFxgYWRkcmVzc1xcYFxuICAgICAgICAgICBJTiAoPylgLFxuICAgICAgW09iamVjdC5rZXlzKGFkZHJNYXApXSxcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiByZXN1bHRzKSB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gZW50cnkuYWRkcmVzcyBhcyBzdHJpbmc7XG4gICAgICAvLyBnZXQgaW5kZXggZnJvbSBhZGRyTWFwIGFzIHRoZSBvbmUgZnJvbSBlbnRyeSBtaWdodCBiZSBudWxsXG4gICAgICBjb25zdCBpbmRleCA9IGFkZHJNYXBbYWRkcmVzc107XG4gICAgICAvLyBhZGQgdG8gZXhpc3RpbmdBZGRyZXNzZXNcbiAgICAgIGV4aXN0aW5nQWRkcmVzc2VzW2FkZHJlc3NdID0gaW5kZXg7XG5cbiAgICAgIC8vIGlmIGFkZHJlc3MgaXMgdXNlZCwgY2hlY2sgaWYgaXRzIGluZGV4IGlzIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IGhpZ2hlc3QgdXNlZCBpbmRleFxuICAgICAgaWYgKGVudHJ5LnRyYW5zYWN0aW9ucyA+IDAgJiYgaW5kZXggPiBsYXN0VXNlZEFkZHJlc3NJbmRleCkge1xuICAgICAgICBsYXN0VXNlZEFkZHJlc3NJbmRleCA9IGluZGV4O1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgYWRkck1hcFthZGRyZXNzXTtcbiAgICB9XG5cbiAgICBoaWdoZXN0Q2hlY2tlZEluZGV4ICs9IG1heEdhcDtcbiAgICBPYmplY3QuYXNzaWduKG5ld0FkZHJlc3NlcywgYWRkck1hcCk7XG4gIH0gd2hpbGUgKGxhc3RVc2VkQWRkcmVzc0luZGV4ICsgbWF4R2FwID4gaGlnaGVzdENoZWNrZWRJbmRleCk7XG5cbiAgLy8gd2UgcHJvYmFibHkgZ2VuZXJhdGVkIG1vcmUgYWRkcmVzc2VzIHRoYW4gbmVlZGVkLCBhcyB3ZSBhbHdheXMgZ2VuZXJhdGVcbiAgLy8gYWRkcmVzc2VzIGluIG1heEdhcCBibG9ja3NcbiAgY29uc3QgdG90YWxBZGRyZXNzZXMgPSBsYXN0VXNlZEFkZHJlc3NJbmRleCArIG1heEdhcCArIDE7XG4gIGZvciAoY29uc3QgW2FkZHJlc3MsIGluZGV4XSBvZiBPYmplY3QuZW50cmllcyhuZXdBZGRyZXNzZXMpKSB7XG4gICAgaWYgKGluZGV4ID4gbGFzdFVzZWRBZGRyZXNzSW5kZXggKyBtYXhHYXApIHtcbiAgICAgIGRlbGV0ZSBuZXdBZGRyZXNzZXNbYWRkcmVzc107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZGRyZXNzZXM6IGFsbEFkZHJlc3Nlcy5zbGljZSgwLCB0b3RhbEFkZHJlc3NlcyksXG4gICAgbmV3QWRkcmVzc2VzLFxuICAgIGV4aXN0aW5nQWRkcmVzc2VzLFxuICAgIGxhc3RVc2VkQWRkcmVzc0luZGV4LFxuICB9O1xufTtcblxuLyoqXG4gKiBHZXQgd2FsbGV0IGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gYWRkcmVzc2VzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBGb3IgZWFjaCBhZGRyZXNzIGluIHRoZSBsaXN0LCBjaGVjayBpZiBpdCdzIGZyb20gYSBzdGFydGVkIHdhbGxldCBhbmQgcmV0dXJuIGl0cyBpbmZvcm1hdGlvbi4gSWZcbiAqIGFkZHJlc3MgaXMgbm90IGZyb20gYSBzdGFydGVkIHdhbGxldCwgaXQgd29uJ3QgYmUgb24gdGhlIGZpbmFsIG1hcC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gYWRkcmVzc2VzIC0gQWRkcmVzc2VzIHRvIGZldGNoIHdhbGxldCBpbmZvcm1hdGlvblxuICogQHJldHVybnMgQSBtYXAgb2YgYWRkcmVzcyBhbmQgY29ycmVzcG9uZGluZyB3YWxsZXQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFkZHJlc3NXYWxsZXRJbmZvID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIGFkZHJlc3Nlczogc3RyaW5nW10pOiBQcm9taXNlPFN0cmluZ01hcDxXYWxsZXQ+PiA9PiB7XG4gIGNvbnN0IGFkZHJlc3NXYWxsZXRNYXA6IFN0cmluZ01hcDxXYWxsZXQ+ID0ge307XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCBESVNUSU5DVCBhLlxcYGFkZHJlc3NcXGAsXG4gICAgICAgICAgICAgICAgICAgICBhLlxcYHdhbGxldF9pZFxcYCxcbiAgICAgICAgICAgICAgICAgICAgIHcuXFxgYXV0aF94cHVia2V5XFxgLFxuICAgICAgICAgICAgICAgICAgICAgdy5cXGB4cHVia2V5XFxgLFxuICAgICAgICAgICAgICAgICAgICAgdy5cXGBtYXhfZ2FwXFxgXG4gICAgICAgRlJPTSBcXGBhZGRyZXNzXFxgIGFcbiBJTk5FUiBKT0lOIFxcYHdhbGxldFxcYCB3XG4gICAgICAgICBPTiBhLndhbGxldF9pZCA9IHcuaWRcbiAgICAgIFdIRVJFIGEuXFxgYWRkcmVzc1xcYFxuICAgICAgICAgSU4gKD8pYCxcbiAgICBbYWRkcmVzc2VzXSxcbiAgKTtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiByZXN1bHRzKSB7XG4gICAgY29uc3Qgd2FsbGV0SW5mbzogV2FsbGV0ID0ge1xuICAgICAgd2FsbGV0SWQ6IGVudHJ5LndhbGxldF9pZCBhcyBzdHJpbmcsXG4gICAgICBhdXRoWHB1YmtleTogZW50cnkuYXV0aF94cHVia2V5IGFzIHN0cmluZyxcbiAgICAgIHhwdWJrZXk6IGVudHJ5LnhwdWJrZXkgYXMgc3RyaW5nLFxuICAgICAgbWF4R2FwOiBlbnRyeS5tYXhfZ2FwIGFzIG51bWJlcixcbiAgICB9O1xuICAgIGFkZHJlc3NXYWxsZXRNYXBbZW50cnkuYWRkcmVzcyBhcyBzdHJpbmddID0gd2FsbGV0SW5mbztcbiAgfVxuICByZXR1cm4gYWRkcmVzc1dhbGxldE1hcDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB3YWxsZXQgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHdhbGxldElkIC0gVGhlIHdhbGxldCBpZFxuICogQHJldHVybnMgVGhlIHdhbGxldCBpbmZvcm1hdGlvbiBvciBudWxsIGlmIGl0IHdhcyBub3QgZm91bmRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFdhbGxldCA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCB3YWxsZXRJZDogc3RyaW5nKTogUHJvbWlzZTxXYWxsZXQ+ID0+IHtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeSgnU0VMRUNUICogRlJPTSBgd2FsbGV0YCBXSEVSRSBgaWRgID0gPycsIHdhbGxldElkKTtcbiAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1swXTtcbiAgICByZXR1cm4gZ2V0V2FsbGV0RnJvbURiRW50cnkocmVzdWx0KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgd2FsbGV0IG9uIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSB4cHVia2V5IC0gVGhlIHdhbGxldCdzIHhwdWJrZXlcbiAqIEBwYXJhbSBtYXhHYXAgLSBNYXhpbXVtIGdhcCBvZiBhZGRyZXNzZXMgZm9yIHRoaXMgd2FsbGV0XG4gKiBAcmV0dXJucyBUaGUgd2FsbGV0IGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVXYWxsZXQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHdhbGxldElkOiBzdHJpbmcsXG4gIHhwdWJrZXk6IHN0cmluZyxcbiAgYXV0aFhwdWJrZXk6IHN0cmluZyxcbiAgbWF4R2FwOiBudW1iZXIsXG4pOiBQcm9taXNlPFdhbGxldD4gPT4ge1xuICBjb25zdCB0cyA9IGdldFVuaXhUaW1lc3RhbXAoKTtcbiAgY29uc3QgZW50cnkgPSB7XG4gICAgaWQ6IHdhbGxldElkLFxuICAgIHhwdWJrZXksXG4gICAgYXV0aF94cHVia2V5OiBhdXRoWHB1YmtleSxcbiAgICBzdGF0dXM6IFdhbGxldFN0YXR1cy5DUkVBVElORyxcbiAgICBjcmVhdGVkX2F0OiB0cyxcbiAgICBtYXhfZ2FwOiBtYXhHYXAsXG4gIH07XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBJTlNFUlQgSU5UTyBcXGB3YWxsZXRcXGBcbiAgICAgICAgU0VUID9gLFxuICAgIFtlbnRyeV0sXG4gICk7XG4gIHJldHVybiB7XG4gICAgd2FsbGV0SWQsXG4gICAgeHB1YmtleSxcbiAgICBhdXRoWHB1YmtleSxcbiAgICBtYXhHYXAsXG4gICAgcmV0cnlDb3VudDogMCxcbiAgICBzdGF0dXM6IFdhbGxldFN0YXR1cy5DUkVBVElORyxcbiAgICBjcmVhdGVkQXQ6IHRzLFxuICAgIHJlYWR5QXQ6IG51bGwsXG4gIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyB3YWxsZXQncyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHdhbGxldElkIC0gVGhlIHdhbGxldCBpZFxuICogQHBhcmFtIHN0YXR1cyAtIFRoZSBuZXcgd2FsbGV0IHN0YXR1c1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlV2FsbGV0U3RhdHVzID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICBzdGF0dXM6IFdhbGxldFN0YXR1cyxcbiAgcmV0cnlDb3VudCA9IDAsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgdHMgPSBnZXRVbml4VGltZXN0YW1wKCk7XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBVUERBVEUgXFxgd2FsbGV0XFxgXG4gICAgICAgIFNFVCBcXGBzdGF0dXNcXGAgPSA/LFxuICAgICAgICAgICAgXFxgcmVhZHlfYXRcXGAgPSA/LFxuICAgICAgICAgICAgXFxgcmV0cnlfY291bnRcXGAgPSA/XG4gICAgICBXSEVSRSBcXGBpZFxcYCA9ID9gLFxuICAgIFtzdGF0dXMsIHRzLCByZXRyeUNvdW50LCB3YWxsZXRJZF0sXG4gICk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyB3YWxsZXQncyBhdXRoX3hwdWJrZXlcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IGlkXG4gKiBAcGFyYW0gYXV0aFhwdWJrZXkgLSBUaGUgbmV3IHdhbGxldCBhdXRoX3hwdWJrZXlcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVdhbGxldEF1dGhYcHViID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICBhdXRoWHB1YmtleTogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBVUERBVEUgXFxgd2FsbGV0XFxgXG4gICAgICAgIFNFVCBcXGBhdXRoX3hwdWJrZXlcXGAgPSA/XG4gICAgICBXSEVSRSBcXGBpZFxcYCA9ID9gLFxuICAgIFthdXRoWHB1YmtleSwgd2FsbGV0SWRdLFxuICApO1xufTtcblxuLyoqXG4gKiBBZGQgYWRkcmVzc2VzIHRvIGFkZHJlc3MgdGFibGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBhZGRyZXNzZXMgYXJlIGFkZGVkIHdpdGggdGhlIGdpdmVuIHdhbGxldElkIGFuZCAwIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IGlkXG4gKiBAcGFyYW0gYWRkcmVzc2VzIC0gQSBtYXAgb2YgYWRkcmVzc2VzIGFuZCBjb3JyZXNwb25kaW5nIGluZGV4ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZE5ld0FkZHJlc3NlcyA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgYWRkcmVzc2VzOiBBZGRyZXNzSW5kZXhNYXAsXG4gIGxhc3RVc2VkQWRkcmVzc0luZGV4OiBudW1iZXIsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKE9iamVjdC5rZXlzKGFkZHJlc3NlcykubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgZm9yIChjb25zdCBbYWRkcmVzcywgaW5kZXhdIG9mIE9iamVjdC5lbnRyaWVzKGFkZHJlc3NlcykpIHtcbiAgICBlbnRyaWVzLnB1c2goW2FkZHJlc3MsIGluZGV4LCB3YWxsZXRJZCwgMF0pO1xuICB9XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBJTlNFUlQgSU5UTyBcXGBhZGRyZXNzXFxgKFxcYGFkZHJlc3NcXGAsIFxcYGluZGV4XFxgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXGB3YWxsZXRfaWRcXGAsIFxcYHRyYW5zYWN0aW9uc1xcYClcbiAgICAgVkFMVUVTID9gLFxuICAgIFtlbnRyaWVzXSxcbiAgKTtcblxuICAvLyBTdG9yZSBvbiB0aGUgd2FsbGV0IHRhYmxlIHRoZSBoaWdoZXN0IHVzZWQgaW5kZXhcbiAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFVQREFURSBcXGB3YWxsZXRcXGBcbiAgICAgICAgU0VUIFxcYGxhc3RfdXNlZF9hZGRyZXNzX2luZGV4XFxgID0gP1xuICAgICAgV0hFUkUgXFxgaWRcXGAgPSA/YCxcbiAgICBbbGFzdFVzZWRBZGRyZXNzSW5kZXgsIHdhbGxldElkXSxcbiAgKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGFkZHJlc3NlcyBvbiB0aGUgYWRkcmVzcyB0YWJsZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogSXQgdXBkYXRlcyBib3RoIHRoZSB3YWxsZXRJZCBhbmQgaW5kZXggb2YgZ2l2ZW4gYWRkcmVzc2VzLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSBhZGRyZXNzZXMgLSBBIG1hcCBvZiBhZGRyZXNzZXMgYW5kIGNvcnJlc3BvbmRpbmcgaW5kZXhlc1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlRXhpc3RpbmdBZGRyZXNzZXMgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgd2FsbGV0SWQ6IHN0cmluZywgYWRkcmVzc2VzOiBBZGRyZXNzSW5kZXhNYXApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKE9iamVjdC5rZXlzKGFkZHJlc3NlcykubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgZm9yIChjb25zdCBbYWRkcmVzcywgaW5kZXhdIG9mIE9iamVjdC5lbnRyaWVzKGFkZHJlc3NlcykpIHtcbiAgICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAgIGBVUERBVEUgXFxgYWRkcmVzc1xcYFxuICAgICAgICAgIFNFVCBcXGB3YWxsZXRfaWRcXGAgPSA/LFxuICAgICAgICAgICAgICBcXGBpbmRleFxcYCA9ID9cbiAgICAgICAgV0hFUkUgXFxgYWRkcmVzc1xcYCA9ID9gLFxuICAgICAgW3dhbGxldElkLCBpbmRleCwgYWRkcmVzc10sXG4gICAgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSB3YWxsZXQncyBhZGRyZXNzIGRldGFpbC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gd2FsbGV0SWQgLSBXYWxsZXQgaWRcbiAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyB0byBnZXQgdGhlIGRldGFpbFxuICogQHJldHVybnMgVGhlIGRldGFpbHMgb2YgdGhlIGFkZHJlc3Mge2FkZHJlc3MsIGluZGV4LCB0cmFuc2FjdGlvbnN9IG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRXYWxsZXRBZGRyZXNzRGV0YWlsID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIHdhbGxldElkOiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QWRkcmVzc0luZm8gfCBudWxsPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgIFNFTEVDVCAqXG4gICAgICBGUk9NIFxcYGFkZHJlc3NcXGBcbiAgICAgV0hFUkUgXFxgd2FsbGV0X2lkXFxgID0gP1xuICAgICAgICAgQU5EIFxcYGFkZHJlc3NcXGAgPSA/YCxcbiAgW3dhbGxldElkLCBhZGRyZXNzXSk7XG5cbiAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGRhdGEgPSByZXN1bHRzWzBdO1xuXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbDogQWRkcmVzc0luZm8gPSB7XG4gICAgICBhZGRyZXNzOiBkYXRhLmFkZHJlc3MgYXMgc3RyaW5nLFxuICAgICAgaW5kZXg6IGRhdGEuaW5kZXggYXMgbnVtYmVyLFxuICAgICAgdHJhbnNhY3Rpb25zOiBkYXRhLnRyYW5zYWN0aW9ucyBhcyBudW1iZXIsXG4gICAgfTtcblxuICAgIHJldHVybiBhZGRyZXNzRGV0YWlsO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSB3YWxsZXQncyB0cmFuc2FjdGlvbiBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZW50cmllcyB0byB3YWxsZXRfdHhfaGlzdG9yeSB0YWJsZSwgdXNpbmcgZGF0YSBmcm9tIGFkZHJlc3NfdHhfaGlzdG9yeS5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IGlkXG4gKiBAcGFyYW0gYWRkcmVzc2VzIC0gVGhlIGFkZHJlc3NlcyB0aGF0IGJlbG9uZyB0byB0aGlzIHdhbGxldFxuICovXG5leHBvcnQgY29uc3QgaW5pdFdhbGxldFR4SGlzdG9yeSA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCB3YWxsZXRJZDogc3RyaW5nLCBhZGRyZXNzZXM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIFhYWCB3ZSBjb3VsZCBhbHNvIGdldCB0aGUgYWRkcmVzc2VzIGZyb20gdGhlIGFkZHJlc3MgdGFibGUsIGJ1dCB0aGUgY2FsbGVyIHByb2JhYmx5IGhhcyB0aGlzIGluZm8gYWxyZWFkeVxuXG4gIGlmIChhZGRyZXNzZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUIFxcYHR4X2lkXFxgLFxuICAgICAgICAgICAgXFxgdG9rZW5faWRcXGAsXG4gICAgICAgICAgICBTVU0oXFxgYmFsYW5jZVxcYCkgQVMgYmFsYW5jZSxcbiAgICAgICAgICAgIFxcYHRpbWVzdGFtcFxcYFxuICAgICAgIEZST00gXFxgYWRkcmVzc190eF9oaXN0b3J5XFxgXG4gICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgIElOICg/KVxuICAgICAgICBBTkQgXFxgdm9pZGVkXFxgID0gRkFMU0VcbiAgIEdST1VQIEJZIFxcYHR4X2lkXFxgLFxuICAgICAgICAgICAgXFxgdG9rZW5faWRcXGAsXG4gICAgICAgICAgICBcXGB0aW1lc3RhbXBcXGBgLFxuICAgIFthZGRyZXNzZXNdLFxuICApO1xuICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICBjb25zdCB3YWxsZXRUeEhpc3RvcnkgPSBbXTtcbiAgZm9yIChjb25zdCByb3cgb2YgcmVzdWx0cykge1xuICAgIHdhbGxldFR4SGlzdG9yeS5wdXNoKFt3YWxsZXRJZCwgcm93LnRva2VuX2lkLCByb3cudHhfaWQsIHJvdy5iYWxhbmNlLCByb3cudGltZXN0YW1wXSk7XG4gIH1cbiAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYElOU0VSVCBJTlRPIFxcYHdhbGxldF90eF9oaXN0b3J5XFxgKFxcYHdhbGxldF9pZFxcYCwgXFxgdG9rZW5faWRcXGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXGB0eF9pZFxcYCwgXFxgYmFsYW5jZVxcYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcYHRpbWVzdGFtcFxcYClcbiAgICAgICAgICBWQUxVRVMgP2AsXG4gICAgW3dhbGxldFR4SGlzdG9yeV0sXG4gICk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSB3YWxsZXQncyBiYWxhbmNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZW50cmllcyB0byB3YWxsZXRfYmFsYW5jZSB0YWJsZSwgdXNpbmcgZGF0YSBmcm9tIGFkZHJlc3NfYmFsYW5jZSBhbmQgYWRkcmVzc190eF9oaXN0b3J5LlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSBhZGRyZXNzZXMgLSBUaGUgYWRkcmVzc2VzIHRoYXQgYmVsb25nIHRvIHRoaXMgd2FsbGV0XG4gKi9cbmV4cG9ydCBjb25zdCBpbml0V2FsbGV0QmFsYW5jZSA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCB3YWxsZXRJZDogc3RyaW5nLCBhZGRyZXNzZXM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIFhYWCB3ZSBjb3VsZCBhbHNvIGRvIGEgam9pbiBiZXR3ZWVuIGFkZHJlc3MgYW5kIGFkZHJlc3NfYmFsYW5jZSB0YWJsZXMgc28gd2UgZG9uJ3RcbiAgLy8gbmVlZCB0byByZWNlaXZlIHRoZSBhZGRyZXNzZXMsIGJ1dCB0aGUgY2FsbGVyIHByb2JhYmx5IGhhcyB0aGlzIGluZm8gYWxyZWFkeVxuICBjb25zdCByZXN1bHRzMTogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUIFxcYHRva2VuX2lkXFxgLFxuICAgICAgICAgICAgU1VNKFxcYHRvdGFsX3JlY2VpdmVkXFxgKSBBUyBcXGB0b3RhbF9yZWNlaXZlZFxcYCxcbiAgICAgICAgICAgIFNVTShcXGB1bmxvY2tlZF9iYWxhbmNlXFxgKSBBUyBcXGB1bmxvY2tlZF9iYWxhbmNlXFxgLFxuICAgICAgICAgICAgU1VNKFxcYGxvY2tlZF9iYWxhbmNlXFxgKSBBUyBcXGBsb2NrZWRfYmFsYW5jZVxcYCxcbiAgICAgICAgICAgIE1JTihcXGB0aW1lbG9ja19leHBpcmVzXFxgKSBBUyBcXGB0aW1lbG9ja19leHBpcmVzXFxgXG4gICAgICAgRlJPTSBcXGBhZGRyZXNzX2JhbGFuY2VcXGBcbiAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgIElOICg/KVxuICAgR1JPVVAgQlkgXFxgdG9rZW5faWRcXGBcbiAgIE9SREVSIEJZIFxcYHRva2VuX2lkXFxgYCxcbiAgICBbYWRkcmVzc2VzXSxcbiAgKTtcbiAgLy8gd2UgbmVlZCB0byB1c2UgdGFibGUgYWRkcmVzc190eF9oaXN0b3J5IGZvciB0aGUgdHJhbnNhY3Rpb24gY291bnQuIFdlIGNhbid0IHNpbXBseVxuICAvLyBzdW0gdGhlIHRyYW5zYWN0aW9uIGNvdW50IGZvciBlYWNoIGFkZHJlc3NfYmFsYW5jZSwgYXMgdGhleSBtYXkgc2hhcmUgdHJhbnNhY3Rpb25zXG4gIGNvbnN0IHJlc3VsdHMyOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgXFxgdG9rZW5faWRcXGAsXG4gICAgICAgICAgICBTVU0oXFxgYmFsYW5jZVxcYCkgQVMgXFxgYmFsYW5jZVxcYCxcbiAgICAgICAgICAgIENPVU5UKERJU1RJTkNUIFxcYHR4X2lkXFxgKSBBUyBcXGB0cmFuc2FjdGlvbnNcXGBcbiAgICAgICBGUk9NIFxcYGFkZHJlc3NfdHhfaGlzdG9yeVxcYFxuICAgICAgV0hFUkUgXFxgYWRkcmVzc1xcYCBJTiAoPylcbiAgICAgICAgQU5EIFxcYHZvaWRlZFxcYCA9IEZBTFNFXG4gICBHUk9VUCBCWSBcXGB0b2tlbl9pZFxcYFxuICAgT1JERVIgQlkgXFxgdG9rZW5faWRcXGBgLFxuICAgIFthZGRyZXNzZXNdLFxuICApO1xuXG4gIGFzc2VydC5zdHJpY3RFcXVhbChyZXN1bHRzMS5sZW5ndGgsIHJlc3VsdHMyLmxlbmd0aCk7XG5cbiAgY29uc3QgYmFsYW5jZUVudHJpZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzMS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGFzIGJvdGggcXVlcmllcyBoYWQgT1JERVIgQlksIHdlIHNob3VsZCBnZXQgdGhlIHJlc3VsdHMgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICBjb25zdCByb3cxID0gcmVzdWx0czFbaV07XG4gICAgY29uc3Qgcm93MiA9IHJlc3VsdHMyW2ldO1xuICAgIGFzc2VydC5zdHJpY3RFcXVhbChyb3cxLnRva2VuX2lkLCByb3cyLnRva2VuX2lkKTtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwoPG51bWJlcj5yb3cxLnVubG9ja2VkX2JhbGFuY2UgKyA8bnVtYmVyPnJvdzEubG9ja2VkX2JhbGFuY2UsIHJvdzIuYmFsYW5jZSk7XG4gICAgYmFsYW5jZUVudHJpZXMucHVzaChbXG4gICAgICB3YWxsZXRJZCxcbiAgICAgIHJvdzEudG9rZW5faWQsXG4gICAgICByb3cxLnRvdGFsX3JlY2VpdmVkLFxuICAgICAgcm93MS51bmxvY2tlZF9iYWxhbmNlLFxuICAgICAgcm93MS5sb2NrZWRfYmFsYW5jZSxcbiAgICAgIHJvdzEudGltZWxvY2tfZXhwaXJlcyxcbiAgICAgIHJvdzIudHJhbnNhY3Rpb25zLFxuICAgIF0pO1xuICB9XG4gIGlmIChiYWxhbmNlRW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgICBgSU5TRVJUIElOVE8gXFxgd2FsbGV0X2JhbGFuY2VcXGAoXFxgd2FsbGV0X2lkXFxgLCBcXGB0b2tlbl9pZFxcYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxgdG90YWxfcmVjZWl2ZWRcXGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcYHVubG9ja2VkX2JhbGFuY2VcXGAsIFxcYGxvY2tlZF9iYWxhbmNlXFxgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXGB0aW1lbG9ja19leHBpcmVzXFxgLCBcXGB0cmFuc2FjdGlvbnNcXGApXG4gICAgICAgICAgICBWQUxVRVMgP2AsXG4gICAgICBbYmFsYW5jZUVudHJpZXNdLFxuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGEgd2FsbGV0J3MgYmFsYW5jZSBhbmQgdHggaGlzdG9yeSB3aXRoIGEgbmV3IHRyYW5zYWN0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBXaGVuIGEgbmV3IHRyYW5zYWN0aW9uIGFycml2ZXMsIGl0IGNhbiBjaGFuZ2UgdGhlIGJhbGFuY2UgYW5kIHR4IGhpc3RvcnkgZm9yIHRoZSB3YWxsZXRzLiBUaGlzIGZ1bmN0aW9uXG4gKiB1cGRhdGVzIHRoZSB3YWxsZXRfYmFsYW5jZSBhbmQgd2FsbGV0X3R4X2hpc3RvcnkgdGFibGVzIHdpdGggaW5mb3JtYXRpb24gZnJvbSB0aGlzIHRyYW5zYWN0aW9uLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eElkIC0gVHJhbnNhY3Rpb24gaWRcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUcmFuc2FjdGlvbiB0aW1lc3RhbXBcbiAqIEBwYXJhbSB3YWxsZXRCYWxhbmNlTWFwIC0gTWFwIHdpdGggdGhlIHRyYW5zYWN0aW9uJ3MgYmFsYW5jZSBmb3IgZWFjaCB3YWxsZXQgKGJ5IHdhbGxldElkKVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlV2FsbGV0VGFibGVzV2l0aFR4ID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB0eElkOiBzdHJpbmcsXG4gIHRpbWVzdGFtcDogbnVtYmVyLFxuICB3YWxsZXRCYWxhbmNlTWFwOiBTdHJpbmdNYXA8VG9rZW5CYWxhbmNlTWFwPixcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGZvciAoY29uc3QgW3dhbGxldElkLCB0b2tlbkJhbGFuY2VNYXBdIG9mIE9iamVjdC5lbnRyaWVzKHdhbGxldEJhbGFuY2VNYXApKSB7XG4gICAgZm9yIChjb25zdCBbdG9rZW4sIHRva2VuQmFsYW5jZV0gb2YgdG9rZW5CYWxhbmNlTWFwLml0ZXJhdG9yKCkpIHtcbiAgICAgIC8vIG9uIHdhbGxldF9iYWxhbmNlIHRhYmxlLCBiYWxhbmNlIGNhbm5vdCBiZSBuZWdhdGl2ZSAoaXQncyB1bnNpZ25lZCkuIFRoYXQncyB3aHkgd2UgdXNlIGJhbGFuY2VcbiAgICAgIC8vIGFzICh0b2tlbkJhbGFuY2UgPCAwID8gMCA6IHRva2VuQmFsYW5jZSkuIEluIGNhc2UgdGhlIHdhbGxldCdzIGJhbGFuY2UgaW4gdGhpcyB0eCBpcyBuZWdhdGl2ZSxcbiAgICAgIC8vIHRoZXJlIG11c3QgbmVjZXNzYXJpbHkgYmUgYW4gZW50cnkgYWxyZWFkeSBhbmQgd2UnbGwgZmFsbCBvbiB0aGUgT04gRFVQTElDQVRFIEtFWSBjYXNlLCBzbyB0aGVcbiAgICAgIC8vIGVudHJ5IHZhbHVlIHdvbid0IGJlIHVzZWQuIFdlJ2xsIGp1c3QgdXBkYXRlIGJhbGFuY2UgPSBiYWxhbmNlICsgdG9rZW5CYWxhbmNlXG4gICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgd2FsbGV0X2lkOiB3YWxsZXRJZCxcbiAgICAgICAgdG9rZW5faWQ6IHRva2VuLFxuICAgICAgICAvLyB0b3RhbEFtb3VudFNlbnQgaXMgdGhlIHN1bSBvZiB0aGUgdmFsdWUgb2YgYWxsIG91dHB1dHMgb2YgdGhpcyB0b2tlbiBvbiB0aGUgdHggYmVpbmcgc2VudCB0byB0aGlzIGFkZHJlc3NcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgaXMgdGhlIFwidG90YWxfcmVjZWl2ZWRcIiBmb3IgdGhpcyB3YWxsZXRcbiAgICAgICAgdG90YWxfcmVjZWl2ZWQ6IHRva2VuQmFsYW5jZS50b3RhbEFtb3VudFNlbnQsXG4gICAgICAgIHVubG9ja2VkX2JhbGFuY2U6ICh0b2tlbkJhbGFuY2UudW5sb2NrZWRBbW91bnQgPCAwID8gMCA6IHRva2VuQmFsYW5jZS51bmxvY2tlZEFtb3VudCksXG4gICAgICAgIGxvY2tlZF9iYWxhbmNlOiB0b2tlbkJhbGFuY2UubG9ja2VkQW1vdW50LFxuICAgICAgICB1bmxvY2tlZF9hdXRob3JpdGllczogdG9rZW5CYWxhbmNlLnVubG9ja2VkQXV0aG9yaXRpZXMudG9VbnNpZ25lZEludGVnZXIoKSxcbiAgICAgICAgbG9ja2VkX2F1dGhvcml0aWVzOiB0b2tlbkJhbGFuY2UubG9ja2VkQXV0aG9yaXRpZXMudG9VbnNpZ25lZEludGVnZXIoKSxcbiAgICAgICAgdGltZWxvY2tfZXhwaXJlczogdG9rZW5CYWxhbmNlLmxvY2tFeHBpcmVzLFxuICAgICAgICB0cmFuc2FjdGlvbnM6IDEsXG4gICAgICB9O1xuXG4gICAgICAvLyBzYXZlIHRoZSBzbWFsbGVyIHZhbHVlIG9mIHRpbWVsb2NrX2V4cGlyZXMsIHdoZW4gbm90IG51bGxcbiAgICAgIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgICBgSU5TRVJUIElOVE8gd2FsbGV0X2JhbGFuY2VcbiAgICAgICAgICAgIFNFVCA/XG4gICAgICAgICAgICAgT04gRFVQTElDQVRFIEtFWVxuICAgICAgICAgVVBEQVRFIHRvdGFsX3JlY2VpdmVkID0gdG90YWxfcmVjZWl2ZWQgKyA/LFxuICAgICAgICAgICAgICAgIHVubG9ja2VkX2JhbGFuY2UgPSB1bmxvY2tlZF9iYWxhbmNlICsgPyxcbiAgICAgICAgICAgICAgICBsb2NrZWRfYmFsYW5jZSA9IGxvY2tlZF9iYWxhbmNlICsgPyxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMgKyAxLFxuICAgICAgICAgICAgICAgIHRpbWVsb2NrX2V4cGlyZXMgPSBDQVNFIFdIRU4gdGltZWxvY2tfZXhwaXJlcyBJUyBOVUxMIFRIRU4gVkFMVUVTKHRpbWVsb2NrX2V4cGlyZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0hFTiBWQUxVRVModGltZWxvY2tfZXhwaXJlcykgSVMgTlVMTCBUSEVOIHRpbWVsb2NrX2V4cGlyZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFTFNFIExFQVNUKHRpbWVsb2NrX2V4cGlyZXMsIFZBTFVFUyh0aW1lbG9ja19leHBpcmVzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRU5ELFxuICAgICAgICAgICAgICAgIHVubG9ja2VkX2F1dGhvcml0aWVzID0gKHVubG9ja2VkX2F1dGhvcml0aWVzIHwgVkFMVUVTKHVubG9ja2VkX2F1dGhvcml0aWVzKSksXG4gICAgICAgICAgICAgICAgbG9ja2VkX2F1dGhvcml0aWVzID0gbG9ja2VkX2F1dGhvcml0aWVzIHwgVkFMVUVTKGxvY2tlZF9hdXRob3JpdGllcylgLFxuICAgICAgICBbZW50cnksIHRva2VuQmFsYW5jZS50b3RhbEFtb3VudFNlbnQsIHRva2VuQmFsYW5jZS51bmxvY2tlZEFtb3VudCwgdG9rZW5CYWxhbmNlLmxvY2tlZEFtb3VudCwgd2FsbGV0SWQsIHRva2VuXSxcbiAgICAgICk7XG5cbiAgICAgIC8vIHNhbWUgbG9naWMgaGVyZSBhcyBpbiB0aGUgdXBkYXRlQWRkcmVzc1RhYmxlc1dpdGhUeCBmdW5jdGlvblxuICAgICAgaWYgKHRva2VuQmFsYW5jZS51bmxvY2tlZEF1dGhvcml0aWVzLmhhc05lZ2F0aXZlVmFsdWUoKSkge1xuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgaXQgbWVhbnMgdGhhdCB3ZSBzcGVudCBhbiBhdXRob3JpdHksIHNvIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSB0YWJsZSB0byByZWZyZXNoIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAvLyBUbyBkbyB0aGF0LCB3ZSBnZXQgYWxsIHVubG9ja2VkX2F1dGhvcml0aWVzIGZyb20gYWxsIGFkZHJlc3NlcyAocXVlcnlpbmcgYnkgd2FsbGV0IGFuZCB0b2tlbl9pZCkgYW5kXG4gICAgICAgIC8vIGJpdHdpc2UgT1IgdGhlbSB3aXRoIGVhY2ggb3RoZXIuXG4gICAgICAgIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgICAgIGBVUERBVEUgXFxgd2FsbGV0X2JhbGFuY2VcXGBcbiAgICAgICAgICAgICAgU0VUIFxcYHVubG9ja2VkX2F1dGhvcml0aWVzXFxgID0gKFxuICAgICAgICAgICAgICAgIFNFTEVDVCBCSVRfT1IoXFxgdW5sb2NrZWRfYXV0aG9yaXRpZXNcXGApXG4gICAgICAgICAgICAgICAgICBGUk9NIFxcYGFkZHJlc3NfYmFsYW5jZVxcYFxuICAgICAgICAgICAgICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgIElOIChcbiAgICAgICAgICAgICAgICAgICBTRUxFQ1QgXFxgYWRkcmVzc1xcYFxuICAgICAgICAgICAgICAgICAgICAgRlJPTSBcXGBhZGRyZXNzXFxgXG4gICAgICAgICAgICAgICAgICAgIFdIRVJFIFxcYHdhbGxldF9pZFxcYCA9ID8pXG4gICAgICAgICAgICAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gPylcbiAgICAgICAgICAgIFdIRVJFIFxcYHdhbGxldF9pZFxcYCA9ID9cbiAgICAgICAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gP2AsXG4gICAgICAgICAgW3dhbGxldElkLCB0b2tlbiwgd2FsbGV0SWQsIHRva2VuXSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZW50cmllcy5wdXNoKFt3YWxsZXRJZCwgdG9rZW4sIHR4SWQsIHRva2VuQmFsYW5jZS50b3RhbCgpLCB0aW1lc3RhbXBdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgICBgSU5TRVJUIElOVE8gXFxgd2FsbGV0X3R4X2hpc3RvcnlcXGAgKFxcYHdhbGxldF9pZFxcYCwgXFxgdG9rZW5faWRcXGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXGB0eF9pZFxcYCwgXFxgYmFsYW5jZVxcYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcYHRpbWVzdGFtcFxcYClcbiAgICAgICAgICAgIFZBTFVFUyA/YCxcbiAgICAgIFtlbnRyaWVzXSxcbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIHR4IG91dHB1dHMgdG8gdGhlIHV0eG8gdGFibGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgYSBsaXN0IG9mIG91dHB1dHMgYW5kIHN1cHBvc2VzIHRoZXkncmUgYWxsIGZyb20gdGhlIHNhbWUgYmxvY2tcbiAqIG9yIHRyYW5zYWN0aW9uLiBTbyBpZiBoZWlnaGxvY2sgaXMgc2V0LCBpdCdsbCBiZSBzZXQgdG8gYWxsIG91dHB1dHMuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHR4SWQgLSBUcmFuc2FjdGlvbiBpZFxuICogQHBhcmFtIG91dHB1dHMgLSBUaGUgdHJhbnNhY3Rpb24gb3V0cHV0c1xuICogQHBhcmFtIGhlaWdodGxvY2sgLSBCbG9jayBoZWlnaHRsb2NrXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRVdHhvcyA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgdHhJZDogc3RyaW5nLFxuICBvdXRwdXRzOiBUeE91dHB1dFdpdGhJbmRleFtdLFxuICBoZWlnaHRsb2NrOiBudW1iZXIgPSBudWxsLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIG91dHB1dHMgbWlnaHQgYmUgZW1wdHkgaWYgd2UncmUgZGVzdHJveWluZyBhdXRob3JpdGllc1xuICBpZiAob3V0cHV0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICBjb25zdCBlbnRyaWVzID0gb3V0cHV0cy5tYXAoXG4gICAgKG91dHB1dCkgPT4ge1xuICAgICAgbGV0IGF1dGhvcml0aWVzID0gMDtcbiAgICAgIGxldCB2YWx1ZSA9IG91dHB1dC52YWx1ZTtcblxuICAgICAgaWYgKGlzQXV0aG9yaXR5KG91dHB1dC50b2tlbl9kYXRhKSkge1xuICAgICAgICBhdXRob3JpdGllcyA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHR4SWQsXG4gICAgICAgIG91dHB1dC5pbmRleCxcbiAgICAgICAgb3V0cHV0LnRva2VuLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYXV0aG9yaXRpZXMsXG4gICAgICAgIG91dHB1dC5kZWNvZGVkLmFkZHJlc3MsXG4gICAgICAgIG91dHB1dC5kZWNvZGVkLnRpbWVsb2NrLFxuICAgICAgICBoZWlnaHRsb2NrLFxuICAgICAgICBvdXRwdXQubG9ja2VkLFxuICAgICAgXTtcbiAgICB9LFxuICApO1xuXG4gIC8vIHdlIGFyZSBzYWZlIHRvIGlnbm9yZSBkdXBsaWNhdGVzIGJlY2F1c2Ugb3VyIHRyYW5zYWN0aW9uIG1pZ2h0IGhhdmUgYWxyZWFkeSBiZWVuIGluIHRoZSBtZW1wb29sXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBJTlNFUlQgSU5UTyBcXGB0eF9vdXRwdXRcXGAgKFxcYHR4X2lkXFxgLCBcXGBpbmRleFxcYCwgXFxgdG9rZW5faWRcXGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcXGB2YWx1ZVxcYCwgXFxgYXV0aG9yaXRpZXNcXGAsIFxcYGFkZHJlc3NcXGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcXGB0aW1lbG9ja1xcYCwgXFxgaGVpZ2h0bG9ja1xcYCwgXFxgbG9ja2VkXFxgKVxuICAgICBWQUxVRVMgP1xuICAgICBPTiBEVVBMSUNBVEUgS0VZIFVQREFURSB0eF9pZD10eF9pZGAsXG4gICAgW2VudHJpZXNdLFxuICApO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgYWRkT3JVcGRhdGVUeFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG1ldGhvZCBpcyBzaW1wbHkgYW4gYWxpYXMgZm9yIGFkZE9yVXBkYXRlVHggaW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHR4SWQgLSBUcmFuc2FjdGlvbiBpZFxuICogQHBhcmFtIHRpbWVzdGFtcCAtIFRoZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIHRyYW5zYWN0aW9uIHZlcnNpb25cbiAqIEBwYXJhbSB3ZWlnaHQgLSBUaGUgdHJhbnNhY3Rpb24gd2VpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVUeCA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgdHhJZDogc3RyaW5nLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgdGltZXN0YW1wOiBudW1iZXIsXG4gIHZlcnNpb246IG51bWJlcixcbiAgd2VpZ2h0OiBudW1iZXIsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IGFkZE9yVXBkYXRlVHgobXlzcWwsIHR4SWQsIGhlaWdodCwgdGltZXN0YW1wLCB2ZXJzaW9uLCB3ZWlnaHQpO1xuXG4vKipcbiAqIEFkZCBhIHR4IHRvIHRoZSB0cmFuc2FjdGlvbiB0YWJsZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBtZXRob2QgYWRkcyBhIHRyYW5zYWN0aW9uIHRvIHRoZSB0cmFuc2FjdGlvbiB0YWJsZVxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eElkIC0gVHJhbnNhY3Rpb24gaWRcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUaGUgdHJhbnNhY3Rpb24gdGltZXN0YW1wXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB0cmFuc2FjdGlvbiB2ZXJzaW9uXG4gKiBAcGFyYW0gd2VpZ2h0IC0gdGhlIHRyYW5zYWN0aW9uIHdlaWdodFxuICovXG5leHBvcnQgY29uc3QgYWRkT3JVcGRhdGVUeCA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgdHhJZDogc3RyaW5nLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgdGltZXN0YW1wOiBudW1iZXIsXG4gIHZlcnNpb246IG51bWJlcixcbiAgd2VpZ2h0OiBudW1iZXIsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgZW50cmllcyA9IFtbdHhJZCwgaGVpZ2h0LCB0aW1lc3RhbXAsIHZlcnNpb24sIHdlaWdodF1dO1xuXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBJTlNFUlQgSU5UTyBcXGB0cmFuc2FjdGlvblxcYCAodHhfaWQsIGhlaWdodCwgdGltZXN0YW1wLCB2ZXJzaW9uLCB3ZWlnaHQpXG4gICAgIFZBTFVFUyA/XG4gICAgICAgICBPTiBEVVBMSUNBVEUgS0VZIFVQREFURSBoZWlnaHQgPSA/YCxcbiAgICBbZW50cmllcywgaGVpZ2h0XSxcbiAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgdHggaW5wdXRzIGZyb20gdGhlIHV0eG8gdGFibGUuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGlucHV0cyAtIFRoZSB0cmFuc2FjdGlvbiBpbnB1dHNcbiAqIEBwYXJhbSB0eElkIC0gVGhlIHRyYW5zYWN0aW9uIHRoYXQgc3BlbnQgdGhlc2UgdXR4b3NcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVR4T3V0cHV0U3BlbnRCeSA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCBpbnB1dHM6IFR4SW5wdXRbXSwgdHhJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4gW2lucHV0LnR4X2lkLCBpbnB1dC5pbmRleF0pO1xuICAvLyBlbnRyaWVzIG1pZ2h0IGJlIGVtcHR5IGlmIHRoZXJlIGFyZSBubyBpbnB1dHNcbiAgaWYgKGVudHJpZXMubGVuZ3RoKSB7XG4gICAgLy8gZ2V0IHRoZSByb3dzIGJlZm9yZSBkZWxldGluZ1xuXG4gICAgLyogV2UgYXJlIGZvcmNpbmcgdGhpcyBxdWVyeSB0byB1c2UgdGhlIFBSSU1BUlkgaW5kZXggYmVjYXVzZSBNeVNRTCBpcyBub3QgdXNpbmcgdGhlIGluZGV4IHdoZW4gdGhlcmUgaXNcbiAgICAgKiBtb3JlIHRoYW4gMTg1IGVsZW1lbnRzIGluIHRoZSBJTiBxdWVyeS4gSSBjb3VsZG4ndCBmaW5kIGEgcmVhc29uIGZvciB0aGF0LiBIZXJlIGlzIHRoZSBFWFBMQUlOIHdpdGggZXhhY3RseSAxODVcbiAgICAgKiBlbGVtZW50czpcbiAgICAgKiArLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLSstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0rLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tK1xuICAgICAqIHwgaWQgfCBzZWxlY3RfdHlwZSB8IHRhYmxlICAgICB8IHBhcnRpdGlvbnMgfCB0eXBlICB8IHBvc3NpYmxlX2tleXMgfCBrZXkgICAgIHwga2V5X2xlbiB8IHJlZiAgICAgICAgIHwgcm93cyB8XG4gICAgICogKy0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tKy0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLStcbiAgICAgKiB8ICAxIHwgVVBEQVRFICAgICAgfCB0eF9vdXRwdXQgfCBOVUxMICAgICAgIHwgcmFuZ2UgfCBQUklNQVJZICAgICAgIHwgUFJJTUFSWSB8IDI1OSAgICAgfCBjb25zdCxjb25zdCB8ICAyNTAgfFxuICAgICAqICstLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLSstLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0rXG4gICAgICpcbiAgICAgKiBBbmQgaGVyZSBpcyB0aGUgRVhQTEFJTiBxdWVyeSB3aXRoIGV4YWN0bHkgMTg2IGVsZW1lbnRzOlxuICAgICAqICstLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLSstLS0tLS0tLS0rLS0tLS0tKy0tLS0tLS0tLStcbiAgICAgKiB8IGlkIHwgc2VsZWN0X3R5cGUgfCB0YWJsZSAgICAgfCBwYXJ0aXRpb25zIHwgdHlwZSAgfCBwb3NzaWJsZV9rZXlzIHwga2V5ICAgICB8IGtleV9sZW4gfCByZWYgIHwgcm93cyAgICB8XG4gICAgICogKy0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tKy0tLS0tLS0tLSstLS0tLS0rLS0tLS0tLS0tK1xuICAgICAqIHwgIDEgfCBVUERBVEUgICAgICB8IHR4X291dHB1dCB8IE5VTEwgICAgICAgfCBpbmRleCB8IE5VTEwgICAgICAgICAgfCBQUklNQVJZIHwgMjU5ICAgICB8IE5VTEwgfCAxOTMzOTc5IHxcbiAgICAgKiArLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLSstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0rLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0tLS0rXG4gICAgICovXG4gICAgY29uc3QgcmVzdWx0OiBPa1BhY2tldCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgYFVQREFURSBcXGB0eF9vdXRwdXRcXGAgVVNFIElOREVYIChQUklNQVJZKVxuICAgICAgICAgIFNFVCBcXGBzcGVudF9ieVxcYCA9ID9cbiAgICAgICAgV0hFUkUgKFxcYHR4X2lkXFxgICxcXGBpbmRleFxcYClcbiAgICAgICAgICAgSU4gKD8pYCxcbiAgICAgIFt0eElkLCBlbnRyaWVzXSxcbiAgICApO1xuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKFxuICAgICAgcmVzdWx0LmFmZmVjdGVkUm93cyxcbiAgICAgIGlucHV0cy5sZW5ndGgsXG4gICAgICBuZXcgRXJyb3IoJ05vdCBhbGwgaW5mb3JtZWQgVVRYT3MgaGFkIHRoZWlyIHNwZW50QnkgdXBkYXRlZCcpLFxuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSByZXF1ZXN0ZWQgdHggb3V0cHV0LlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eElkIC0gVGhlIHR4IGlkIHRvIHNlYXJjaFxuICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIHNlYXJjaFxuICogQHBhcmFtIHNraXBTcGVudCAtIFNraXAgc3BlbnQgdHhfb3V0cHV0IChpZiB3ZSB3YW50IG9ubHkgdXR4b3MpXG4gKiBAcmV0dXJucyBUaGUgcmVxdWVzdGVkIHR4X291dHB1dCBvciBudWxsIGlmIGl0IGlzIG5vdCBmb3VuZFxuICovXG5leHBvcnQgY29uc3QgZ2V0VHhPdXRwdXQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4SWQ6IHN0cmluZyxcbiAgaW5kZXg6IG51bWJlcixcbiAgc2tpcFNwZW50OiBib29sZWFuLFxuKTogUHJvbWlzZTxEYlR4T3V0cHV0IHwgbnVsbD4gPT4ge1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgKlxuICAgICAgIEZST00gXFxgdHhfb3V0cHV0XFxgXG4gICAgICBXSEVSRSBcXGB0eF9pZFxcYCA9ID9cbiAgICAgICAgQU5EIFxcYGluZGV4XFxgID0gP1xuICAgICAgICAke3NraXBTcGVudCA/ICdBTkQgYHNwZW50X2J5YCBJUyBOVUxMJyA6ICcnfVxuICAgICAgICBBTkQgXFxgdm9pZGVkXFxgID0gRkFMU0VgLFxuICAgIFt0eElkLCBpbmRleF0sXG4gICk7XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCB8fCByZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1swXTtcblxuICBjb25zdCB0eE91dHB1dDogRGJUeE91dHB1dCA9IG1hcERiUmVzdWx0VG9EYlR4T3V0cHV0KHJlc3VsdCk7XG5cbiAgcmV0dXJuIHR4T3V0cHV0O1xufTtcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gdmFsaWQgYXV0aG9yaXR5IFVUWE8gZm9yIGEgZ2l2ZW4gdG9rZW5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbiBpZCB0byBzZWFyY2ggYXV0aG9yaXRpZXMgZm9yXG4gKiBAcGFyYW0gYXV0aG9yaXR5IC0gVGhlIGF1dGhvcml0eSB0byBzZWFyY2ggZm9yLCBjYW4gYmUgb25lIG9mIChUT0tFTl9NSU5UX01BU0ssIFRPS0VOX01FTFRfTUFTSylcbiAqXG4gKiBAcmV0dXJucyBUaGUgcmVxdWVzdGVkIFVUWE9cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF1dGhvcml0eVV0eG8gPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRva2VuSWQ6IHN0cmluZyxcbiAgYXV0aG9yaXR5OiBudW1iZXIsXG4pOiBQcm9taXNlPERiVHhPdXRwdXQgfCBudWxsPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCAqXG4gICAgICAgRlJPTSBcXGB0eF9vdXRwdXRcXGBcbiAgICAgIFdIRVJFIFxcYGF1dGhvcml0aWVzXFxgID0gP1xuICAgICAgICBBTkQgXFxgc3BlbnRfYnlcXGAgSVMgTlVMTFxuICAgICAgICBBTkQgXFxgdm9pZGVkXFxgID0gRkFMU0VcbiAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gP1xuICAgICAgTElNSVQgMWAsXG4gICAgW2F1dGhvcml0eSwgdG9rZW5JZF0sXG4gICk7XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCB8fCByZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1swXTtcbiAgY29uc3QgdXR4bzogRGJUeE91dHB1dCA9IG1hcERiUmVzdWx0VG9EYlR4T3V0cHV0KHJlc3VsdCk7XG5cbiAgcmV0dXJuIHV0eG87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcmVxdWVzdGVkIFVUWE9zLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB1dHhvc0tleXMgLSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgcXVlcmllZCBVVFhPcywgaW5jbHVkaW5nIHR4X2lkIGFuZCBpbmRleFxuICogQHJldHVybnMgQSBsaXN0IG9mIFVUWE9zIHdpdGggYWxsIHRoZWlyIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFV0eG9zID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB1dHhvc0luZm86IElXYWxsZXRJbnB1dFtdLFxuKTogUHJvbWlzZTxEYlR4T3V0cHV0W10+ID0+IHtcbiAgY29uc3QgZW50cmllcyA9IHV0eG9zSW5mby5tYXAoKHV0eG8pID0+IFt1dHhvLnR4SWQsIHV0eG8uaW5kZXhdKTtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUICpcbiAgICAgICBGUk9NIFxcYHR4X291dHB1dFxcYCBVU0UgSU5ERVggKFBSSU1BUlkpXG4gICAgICBXSEVSRSAoXFxgdHhfaWRcXGAsIFxcYGluZGV4XFxgKVxuICAgICAgICAgSU4gKD8pXG4gICAgICAgIEFORCBcXGBzcGVudF9ieVxcYCBJUyBOVUxMXG4gICAgICAgIEFORCBcXGB2b2lkZWRcXGAgPSBGQUxTRWAsXG4gICAgW2VudHJpZXNdLFxuICApO1xuXG4gIGNvbnN0IHV0eG9zID0gcmVzdWx0cy5tYXAobWFwRGJSZXN1bHRUb0RiVHhPdXRwdXQpO1xuXG4gIHJldHVybiB1dHhvcztcbn07XG5cbi8qKlxuICogR2V0IGEgd2FsbGV0J3MgVVRYT3MsIHNvcnRlZCBieSB2YWx1ZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogTG9ja2VkIGFuZCBhdXRob3JpdHkgVVRYT3MgYXJlIG5vdCBjb25zaWRlcmVkLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSB0b2tlbiAtIFRoZSB0b2tlbiBpZFxuICogQHJldHVybnMgQSBsaXN0IG9mIFVUWE9zIHdpdGggYWxsIHRoZWlyIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFdhbGxldFNvcnRlZFZhbHVlVXR4b3MgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHdhbGxldElkOiBzdHJpbmcsXG4gIHRva2VuSWQ6IHN0cmluZyxcbik6IFByb21pc2U8RGJUeE91dHB1dFtdPiA9PiB7XG4gIGNvbnN0IHV0eG9zID0gW107XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCAqXG4gICAgICAgRlJPTSBcXGB0eF9vdXRwdXRcXGBcbiAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgIElOIChcbiAgICAgICAgICAgU0VMRUNUIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgICAgICBGUk9NIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgICAgIFdIRVJFIFxcYHdhbGxldF9pZFxcYCA9ID9cbiAgICAgICAgIClcbiAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gP1xuICAgICAgICBBTkQgXFxgYXV0aG9yaXRpZXNcXGAgPSAwXG4gICAgICAgIEFORCBcXGBsb2NrZWRcXGAgPSBGQUxTRVxuICAgICAgICBBTkQgXFxgdHhfcHJvcG9zYWxcXGAgSVMgTlVMTFxuICAgICAgICBBTkQgXFxgc3BlbnRfYnlcXGAgSVMgTlVMTFxuICAgICAgICBBTkQgXFxgdm9pZGVkXFxgID0gRkFMU0VcbiAgIE9SREVSIEJZIFxcYHZhbHVlXFxgXG4gICAgICAgREVTQ2AsXG4gICAgW3dhbGxldElkLCB0b2tlbklkXSxcbiAgKTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGNvbnN0IHV0eG86IERiVHhPdXRwdXQgPSB7XG4gICAgICB0eElkOiByZXN1bHQudHhfaWQgYXMgc3RyaW5nLFxuICAgICAgaW5kZXg6IHJlc3VsdC5pbmRleCBhcyBudW1iZXIsXG4gICAgICB0b2tlbklkOiByZXN1bHQudG9rZW5faWQgYXMgc3RyaW5nLFxuICAgICAgYWRkcmVzczogcmVzdWx0LmFkZHJlc3MgYXMgc3RyaW5nLFxuICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSBhcyBudW1iZXIsXG4gICAgICBhdXRob3JpdGllczogcmVzdWx0LmF1dGhvcml0aWVzIGFzIG51bWJlcixcbiAgICAgIHRpbWVsb2NrOiByZXN1bHQudGltZWxvY2sgYXMgbnVtYmVyLFxuICAgICAgaGVpZ2h0bG9jazogcmVzdWx0LmhlaWdodGxvY2sgYXMgbnVtYmVyLFxuICAgICAgbG9ja2VkOiByZXN1bHQubG9ja2VkID4gMCxcbiAgICB9O1xuICAgIHV0eG9zLnB1c2godXR4byk7XG4gIH1cbiAgcmV0dXJuIHV0eG9zO1xufTtcblxuLyoqXG4gKiBNYXJrIFVUWE9zIGFzIHVubG9ja2VkLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB1dHhvcyAtIExpc3Qgb2YgVVRYT3MgdG8gdW5sb2NrXG4gKi9cbmV4cG9ydCBjb25zdCB1bmxvY2tVdHhvcyA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCB1dHhvczogRGJUeE91dHB1dFtdKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICh1dHhvcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgY29uc3QgZW50cmllcyA9IHV0eG9zLm1hcCgodXR4bykgPT4gW3V0eG8udHhJZCwgdXR4by5pbmRleF0pO1xuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgVVBEQVRFIFxcYHR4X291dHB1dFxcYFxuICAgICAgICBTRVQgXFxgbG9ja2VkXFxgID0gRkFMU0VcbiAgICAgIFdIRVJFIChcXGB0eF9pZFxcYCAsXFxgaW5kZXhcXGApXG4gICAgICAgICBJTiAoPylgLFxuICAgIFtlbnRyaWVzXSxcbiAgKTtcbn07XG5cbi8qKlxuICogR2V0IHR4IGlucHV0cyB0aGF0IGFyZSBzdGlsbCBtYXJrZWQgYXMgbG9ja2VkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBdCBmaXJzdCwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHRhbGsgYWJvdXQgbG9ja2VkIGlucHV0cy4gQW55IFVUWE8gY2FuIG9ubHkgYmUgc3BlbnQgYWZ0ZXJcbiAqIGl0J3MgdW5sb2NrZWQuIEhvd2V2ZXIsIGluIHRoaXMgc2VydmljZSwgd2UgaGF2ZSBhIFwibGF6eVwiIHVubG9jayBwb2xpY3ksIG9ubHkgdW5sb2NraW5nIHRoZSBVVFhPc1xuICogd2hlbiB0aGUgd2FsbGV0IG93bmVyIHJlcXVlc3RzIGl0cyBiYWxhbmNlLiBUaGVyZWZvcmUsIHdlIG1pZ2h0IHJlY2VpdmUgYSB0cmFuc2FjdGlvbiB3aXRoIGEgVVRYT1xuICogdGhhdCBpcyBzaWxsIG1hcmtlZCBhcyBsb2NrZWQgaW4gb3VyIGRhdGFiYXNlLiBUaGF0IG1pZ2h0IGhhcHBlbiBpZiB0aGUgdXNlciBzZW5kcyBoaXMgdHJhbnNhY3Rpb25cbiAqIHVzaW5nIGEgc2VydmljZSBvdGhlciB0aGFuIHRoaXMgb25lLiBPdGhlcndpc2UgdGhlIGxvY2tlZCBhbW91bnQgd291bGQgaGF2ZSBiZWVuIHVwZGF0ZWQgYmVmb3JlXG4gKiBzZW5kaW5nLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBpbnB1dHMgLSBUaGUgdHJhbnNhY3Rpb24gaW5wdXRzXG4gKiBAcmV0dXJucyBUaGUgbG9ja2VkIFVUWE9zXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMb2NrZWRVdHhvRnJvbUlucHV0cyA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCBpbnB1dHM6IFR4SW5wdXRbXSk6IFByb21pc2U8RGJUeE91dHB1dFtdPiA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4gW2lucHV0LnR4X2lkLCBpbnB1dC5pbmRleF0pO1xuICAvLyBlbnRyaWVzIG1pZ2h0IGJlIGVtcHR5IGlmIHRoZXJlIGFyZSBubyBpbnB1dHNcbiAgaWYgKGVudHJpZXMubGVuZ3RoKSB7XG4gICAgLy8gZ2V0IHRoZSByb3dzIGJlZm9yZSBkZWxldGluZ1xuICAgIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgICBgU0VMRUNUICpcbiAgICAgICAgIEZST00gXFxgdHhfb3V0cHV0XFxgIFVTRSBJTkRFWCAoUFJJTUFSWSlcbiAgICAgICAgV0hFUkUgKFxcYHR4X2lkXFxgICxcXGBpbmRleFxcYClcbiAgICAgICAgICAgSU4gKD8pXG4gICAgICAgICAgQU5EIFxcYGxvY2tlZFxcYCA9IFRSVUVcbiAgICAgICAgICBBTkQgXFxgc3BlbnRfYnlcXGAgSVMgTlVMTFxuICAgICAgICAgIEFORCBcXGB2b2lkZWRcXGAgPSBGQUxTRWAsXG4gICAgICBbZW50cmllc10sXG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHRzLm1hcCgodXR4bykgPT4gKHtcbiAgICAgIHR4SWQ6IHV0eG8udHhfaWQgYXMgc3RyaW5nLFxuICAgICAgaW5kZXg6IHV0eG8uaW5kZXggYXMgbnVtYmVyLFxuICAgICAgdG9rZW5JZDogdXR4by50b2tlbl9pZCBhcyBzdHJpbmcsXG4gICAgICBhZGRyZXNzOiB1dHhvLmFkZHJlc3MgYXMgc3RyaW5nLFxuICAgICAgdmFsdWU6IHV0eG8udmFsdWUgYXMgbnVtYmVyLFxuICAgICAgYXV0aG9yaXRpZXM6IHV0eG8uYXV0aG9yaXRpZXMgYXMgbnVtYmVyLFxuICAgICAgdGltZWxvY2s6IHV0eG8udGltZWxvY2sgYXMgbnVtYmVyLFxuICAgICAgaGVpZ2h0bG9jazogdXR4by5oZWlnaHRsb2NrIGFzIG51bWJlcixcbiAgICAgIGxvY2tlZDogKHV0eG8ubG9ja2VkID4gMCksXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYWRkcmVzc2VzIHRhYmxlcyB3aXRoIGEgbmV3IHRyYW5zYWN0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBXaGVuIGEgbmV3IHRyYW5zYWN0aW9uIGFycml2ZXMsIGl0IHdpbGwgY2hhbmdlIHRoZSBiYWxhbmNlIGFuZCB0eCBoaXN0b3J5IGZvciBhZGRyZXNzZXMuIFRoaXMgZnVuY3Rpb25cbiAqIHVwZGF0ZXMgdGhlIGFkZHJlc3MsIGFkZHJlc3NfYmFsYW5jZSBhbmQgYWRkcmVzc190eF9oaXN0b3J5IHRhYmxlcyB3aXRoIGluZm9ybWF0aW9uIGZyb20gdGhpcyB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHhJZCAtIFRyYW5zYWN0aW9uIGlkXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gVHJhbnNhY3Rpb24gdGltZXN0YW1wXG4gKiBAcGFyYW0gYWRkcmVzc0JhbGFuY2VNYXAgLSBNYXAgd2l0aCB0aGUgdHJhbnNhY3Rpb24ncyBiYWxhbmNlIGZvciBlYWNoIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUFkZHJlc3NUYWJsZXNXaXRoVHggPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4SWQ6IHN0cmluZyxcbiAgdGltZXN0YW1wOiBudW1iZXIsXG4gIGFkZHJlc3NCYWxhbmNlTWFwOiBTdHJpbmdNYXA8VG9rZW5CYWxhbmNlTWFwPixcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAvKlxuICAgKiB1cGRhdGUgYWRkcmVzcyB0YWJsZVxuICAgKlxuICAgKiBJZiBhbiBhZGRyZXNzIGlzIG5vdCB5ZXQgcHJlc2VudCwgYWRkIGVudHJ5IHdpdGggaW5kZXggPSBudWxsLCB3YWxsZXRJZCA9IG51bGwgYW5kIHRyYW5zYWN0aW9ucyA9IDEuXG4gICAqIExhdGVyLCB3aGVuIHRoZSBjb3JyZXNwb25kaW5nIHdhbGxldCBpcyBzdGFydGVkLCBpbmRleCBhbmQgd2FsbGV0SWQgd2lsbCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBJZiBhZGRyZXNzIGlzIGFscmVhZHkgcHJlc2VudCwganVzdCBpbmNyZW1lbnQgdGhlIHRyYW5zYWN0aW9ucyBjb3VudGVyLlxuICAgKi9cbiAgY29uc3QgYWRkcmVzc0VudHJpZXMgPSBPYmplY3Qua2V5cyhhZGRyZXNzQmFsYW5jZU1hcCkubWFwKChhZGRyZXNzKSA9PiBbYWRkcmVzcywgMV0pO1xuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgSU5TRVJUIElOVE8gXFxgYWRkcmVzc1xcYChcXGBhZGRyZXNzXFxgLCBcXGB0cmFuc2FjdGlvbnNcXGApXG4gICAgICAgICAgVkFMVUVTID9cbiAgICAgICAgICAgICAgT04gRFVQTElDQVRFIEtFWSBVUERBVEUgdHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zICsgMWAsXG4gICAgW2FkZHJlc3NFbnRyaWVzXSxcbiAgKTtcblxuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGZvciAoY29uc3QgW2FkZHJlc3MsIHRva2VuTWFwXSBvZiBPYmplY3QuZW50cmllcyhhZGRyZXNzQmFsYW5jZU1hcCkpIHtcbiAgICBmb3IgKGNvbnN0IFt0b2tlbiwgdG9rZW5CYWxhbmNlXSBvZiB0b2tlbk1hcC5pdGVyYXRvcigpKSB7XG4gICAgICAvLyB1cGRhdGUgYWRkcmVzc19iYWxhbmNlIHRhYmxlIG9yIHVwZGF0ZSBiYWxhbmNlIGFuZCB0cmFuc2FjdGlvbnMgaWYgdGhlcmUncyBhbiBlbnRyeSBhbHJlYWR5XG4gICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgdG9rZW5faWQ6IHRva2VuLFxuICAgICAgICAvLyB0b3RhbEFtb3VudFNlbnQgaXMgdGhlIHN1bSBvZiB0aGUgdmFsdWUgb2YgYWxsIG91dHB1dHMgb2YgdGhpcyB0b2tlbiBvbiB0aGUgdHggYmVpbmcgc2VudCB0byB0aGlzIGFkZHJlc3NcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgaXMgdGhlIFwidG90YWxfcmVjZWl2ZWRcIiBmb3IgdGhpcyBhZGRyZXNzXG4gICAgICAgIHRvdGFsX3JlY2VpdmVkOiB0b2tlbkJhbGFuY2UudG90YWxBbW91bnRTZW50LFxuICAgICAgICAvLyBpZiBpdCdzIDwgMCwgdGhlcmUgbXVzdCBiZSBhbiBlbnRyeSBhbHJlYWR5LCBzbyBpdCB3aWxsIGV4ZWN1dGUgXCJPTiBEVVBMSUNBVEUgS0VZIFVQREFURVwiIGluc3RlYWQgb2Ygc2V0dGluZyBpdCB0byAwXG4gICAgICAgIHVubG9ja2VkX2JhbGFuY2U6ICh0b2tlbkJhbGFuY2UudW5sb2NrZWRBbW91bnQgPCAwID8gMCA6IHRva2VuQmFsYW5jZS51bmxvY2tlZEFtb3VudCksXG4gICAgICAgIC8vIHRoaXMgaXMgbmV2ZXIgbGVzcyB0aGFuIDAsIGFzIGxvY2tlZCBiYWxhbmNlIG9ubHkgY2hhbmdlcyB3aGVuIGEgdHggaXMgdW5sb2NrZWRcbiAgICAgICAgbG9ja2VkX2JhbGFuY2U6IHRva2VuQmFsYW5jZS5sb2NrZWRBbW91bnQsXG4gICAgICAgIHVubG9ja2VkX2F1dGhvcml0aWVzOiB0b2tlbkJhbGFuY2UudW5sb2NrZWRBdXRob3JpdGllcy50b1Vuc2lnbmVkSW50ZWdlcigpLFxuICAgICAgICBsb2NrZWRfYXV0aG9yaXRpZXM6IHRva2VuQmFsYW5jZS5sb2NrZWRBdXRob3JpdGllcy50b1Vuc2lnbmVkSW50ZWdlcigpLFxuICAgICAgICB0aW1lbG9ja19leHBpcmVzOiB0b2tlbkJhbGFuY2UubG9ja0V4cGlyZXMsXG4gICAgICAgIHRyYW5zYWN0aW9uczogMSxcbiAgICAgIH07XG4gICAgICAvLyBzYXZlIHRoZSBzbWFsbGVyIHZhbHVlIG9mIHRpbWVsb2NrX2V4cGlyZXMsIHdoZW4gbm90IG51bGxcbiAgICAgIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgICBgSU5TRVJUIElOVE8gYWRkcmVzc19iYWxhbmNlXG4gICAgICAgICAgICAgICAgIFNFVCA/XG4gICAgICAgICAgICAgICAgICBPTiBEVVBMSUNBVEUgS0VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVVBEQVRFIHRvdGFsX3JlY2VpdmVkID0gdG90YWxfcmVjZWl2ZWQgKyA/LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmxvY2tlZF9iYWxhbmNlID0gdW5sb2NrZWRfYmFsYW5jZSArID8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tlZF9iYWxhbmNlID0gbG9ja2VkX2JhbGFuY2UgKyA/LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbG9ja19leHBpcmVzID0gQ0FTRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXSEVOIHRpbWVsb2NrX2V4cGlyZXMgSVMgTlVMTCBUSEVOIFZBTFVFUyh0aW1lbG9ja19leHBpcmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXSEVOIFZBTFVFUyh0aW1lbG9ja19leHBpcmVzKSBJUyBOVUxMIFRIRU4gdGltZWxvY2tfZXhwaXJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFTFNFIExFQVNUKHRpbWVsb2NrX2V4cGlyZXMsIFZBTFVFUyh0aW1lbG9ja19leHBpcmVzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVORCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5sb2NrZWRfYXV0aG9yaXRpZXMgPSAodW5sb2NrZWRfYXV0aG9yaXRpZXMgfCBWQUxVRVModW5sb2NrZWRfYXV0aG9yaXRpZXMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ja2VkX2F1dGhvcml0aWVzID0gbG9ja2VkX2F1dGhvcml0aWVzIHwgVkFMVUVTKGxvY2tlZF9hdXRob3JpdGllcylgLFxuICAgICAgICBbZW50cnksIHRva2VuQmFsYW5jZS50b3RhbEFtb3VudFNlbnQsIHRva2VuQmFsYW5jZS51bmxvY2tlZEFtb3VudCwgdG9rZW5CYWxhbmNlLmxvY2tlZEFtb3VudCwgYWRkcmVzcywgdG9rZW5dLFxuICAgICAgKTtcblxuICAgICAgLy8gaWYgd2UncmUgcmVtb3ZpbmcgYW55IG9mIHRoZSBhdXRob3JpdGllcywgd2UgbmVlZCB0byByZWZyZXNoIHRoZSBhdXRob3JpdHkgY29sdW1ucy4gVW5saWtlIHRoZSB2YWx1ZXMsXG4gICAgICAvLyB3ZSBjYW5ub3Qgb25seSBzdW0vc3VidHJhY3QsIGFzIGF1dGhvcml0aWVzIGFyZSBiaW5hcnk6IHlvdSBoYXZlIGl0IG9yIHlvdSBkb24ndC4gV2UgbWlnaHQgYmUgc3BlbmRpbmdcbiAgICAgIC8vIGFuIGF1dGhvcml0eSBvdXRwdXQgaW4gdGhpcyB0eCB3aXRob3V0IGNyZWF0aW5nIGEgbmV3IG9uZSwgYnV0IGl0IGRvZXNuJ3QgbWVhbiB0aGlzIGFkZHJlc3MgZG9lcyBub3RcbiAgICAgIC8vIGhhdmUgdGhpcyBhdXRob3JpdHkgYW55bW9yZSwgYXMgaXQgbWlnaHQgaGF2ZSBvdGhlciBhdXRob3JpdHkgb3V0cHV0c1xuICAgICAgaWYgKHRva2VuQmFsYW5jZS51bmxvY2tlZEF1dGhvcml0aWVzLmhhc05lZ2F0aXZlVmFsdWUoKSkge1xuICAgICAgICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAgICAgICBgVVBEQVRFIFxcYGFkZHJlc3NfYmFsYW5jZVxcYFxuICAgICAgICAgICAgICBTRVQgXFxgdW5sb2NrZWRfYXV0aG9yaXRpZXNcXGAgPSAoXG4gICAgICAgICAgICAgICAgU0VMRUNUIEJJVF9PUihcXGBhdXRob3JpdGllc1xcYClcbiAgICAgICAgICAgICAgICAgIEZST00gXFxgdHhfb3V0cHV0XFxgXG4gICAgICAgICAgICAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGAgPSA/XG4gICAgICAgICAgICAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gP1xuICAgICAgICAgICAgICAgICAgIEFORCBcXGBsb2NrZWRcXGAgPSBGQUxTRVxuICAgICAgICAgICAgICAgICAgIEFORCBcXGBzcGVudF9ieVxcYCBJUyBOVUxMXG4gICAgICAgICAgICAgICAgICAgQU5EIFxcYHZvaWRlZFxcYCA9IEZBTFNFXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGAgPSA/XG4gICAgICAgICAgICAgIEFORCBcXGB0b2tlbl9pZFxcYCA9ID9gLFxuICAgICAgICAgIFthZGRyZXNzLCB0b2tlbiwgYWRkcmVzcywgdG9rZW5dLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gZm9yIGxvY2tlZCBhdXRob3JpdGllcywgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHBlcmZvcm0gdGhlIHNhbWUgb3BlcmF0aW9uLiBUaGUgYXV0aG9yaXR5IG5lZWRzIHRvIGJlXG4gICAgICAvLyB1bmxvY2tlZCBiZWZvcmUgaXQgY2FuIGJlIHNwZW50LiBJbiBjYXNlIHdlJ3JlIGp1c3QgYWRkaW5nIG5ldyBsb2NrZWQgYXV0aG9yaXRpZXMsIHRoaXMgd2lsbCBiZSB0YWtlblxuICAgICAgLy8gY2FyZSBieSB0aGUgZmlyc3Qgc3FsIHF1ZXJ5LlxuXG4gICAgICAvLyB1cGRhdGUgYWRkcmVzc190eF9oaXN0b3J5IHdpdGggb25lIGVudHJ5IGZvciBlYWNoIHBhaXIgKGFkZHJlc3MsIHRva2VuKVxuICAgICAgZW50cmllcy5wdXNoKFthZGRyZXNzLCB0eElkLCB0b2tlbiwgdG9rZW5CYWxhbmNlLnRvdGFsKCksIHRpbWVzdGFtcF0pO1xuICAgIH1cbiAgfVxuXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBJTlNFUlQgSU5UTyBcXGBhZGRyZXNzX3R4X2hpc3RvcnlcXGAoXFxgYWRkcmVzc1xcYCwgXFxgdHhfaWRcXGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxgdG9rZW5faWRcXGAsIFxcYGJhbGFuY2VcXGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxgdGltZXN0YW1wXFxgKVxuICAgICBWQUxVRVMgP2AsXG4gICAgW2VudHJpZXNdLFxuICApO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHVubG9ja2VkIGFuZCBsb2NrZWQgYmFsYW5jZXMgZm9yIGFkZHJlc3Nlcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGJhbGFuY2Ugb2YgYW4gYWRkcmVzcyBtaWdodCBjaGFuZ2UgYXMgYSBsb2NrZWQgYW1vdW50IGJlY29tZXMgdW5sb2NrZWQuIFRoaXMgZnVuY3Rpb24gdXBkYXRlc1xuICogdGhlIGFkZHJlc3NfYmFsYW5jZSB0YWJsZSwgc3VidHJhY3RpbmcgZnJvbSB0aGUgbG9ja2VkIGNvbHVtbiBhbmQgYWRkaW5nIHRvIHRoZSB1bmxvY2tlZCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGFkZHJlc3NCYWxhbmNlTWFwIC0gQSBtYXAgb2YgYWRkcmVzc2VzIGFuZCB0aGUgdW5sb2NrZWQgYmFsYW5jZXNcbiAqIEBwYXJhbSB1cGRhdGVUaW1lbG9jayAtIElmIHRoaXMgdXBkYXRlIGlzIHRyaWdnZXJlZCBieSBhIHRpbWVsb2NrIGV4cGlyaW5nLCB1cGRhdGUgdGhlIG5leHQgZXhwaXJlIHRpbWVzdGFtcFxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlQWRkcmVzc0xvY2tlZEJhbGFuY2UgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIGFkZHJlc3NCYWxhbmNlTWFwOiBTdHJpbmdNYXA8VG9rZW5CYWxhbmNlTWFwPixcbiAgdXBkYXRlVGltZWxvY2tzID0gZmFsc2UsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgZm9yIChjb25zdCBbYWRkcmVzcywgdG9rZW5CYWxhbmNlTWFwXSBvZiBPYmplY3QuZW50cmllcyhhZGRyZXNzQmFsYW5jZU1hcCkpIHtcbiAgICBmb3IgKGNvbnN0IFt0b2tlbiwgdG9rZW5CYWxhbmNlXSBvZiB0b2tlbkJhbGFuY2VNYXAuaXRlcmF0b3IoKSkge1xuICAgICAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgICAgIGBVUERBVEUgXFxgYWRkcmVzc19iYWxhbmNlXFxgXG4gICAgICAgICAgICBTRVQgXFxgdW5sb2NrZWRfYmFsYW5jZVxcYCA9IFxcYHVubG9ja2VkX2JhbGFuY2VcXGAgKyA/LFxuICAgICAgICAgICAgICAgIFxcYGxvY2tlZF9iYWxhbmNlXFxgID0gXFxgbG9ja2VkX2JhbGFuY2VcXGAgLSA/LFxuICAgICAgICAgICAgICAgIFxcYHVubG9ja2VkX2F1dGhvcml0aWVzXFxgID0gKHVubG9ja2VkX2F1dGhvcml0aWVzIHwgPylcbiAgICAgICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgID0gP1xuICAgICAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gP2AsIFtcbiAgICAgICAgICB0b2tlbkJhbGFuY2UudW5sb2NrZWRBbW91bnQsXG4gICAgICAgICAgdG9rZW5CYWxhbmNlLnVubG9ja2VkQW1vdW50LFxuICAgICAgICAgIHRva2VuQmFsYW5jZS51bmxvY2tlZEF1dGhvcml0aWVzLnRvSW50ZWdlcigpLFxuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgIF0sXG4gICAgICApO1xuXG4gICAgICAvLyBpZiBhbnkgYXV0aG9yaXR5IGhhcyBiZWVuIHVubG9ja2VkLCB3ZSBoYXZlIHRvIHJlZnJlc2ggdGhlIGxvY2tlZCBhdXRob3JpdGllc1xuICAgICAgaWYgKHRva2VuQmFsYW5jZS51bmxvY2tlZEF1dGhvcml0aWVzLnRvSW50ZWdlcigpID4gMCkge1xuICAgICAgICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAgICAgICBgVVBEQVRFIFxcYGFkZHJlc3NfYmFsYW5jZVxcYFxuICAgICAgICAgICAgICBTRVQgXFxgbG9ja2VkX2F1dGhvcml0aWVzXFxgID0gKFxuICAgICAgICAgICAgICAgIFNFTEVDVCBCSVRfT1IoXFxgYXV0aG9yaXRpZXNcXGApXG4gICAgICAgICAgICAgICAgICBGUk9NIFxcYHR4X291dHB1dFxcYFxuICAgICAgICAgICAgICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgID0gP1xuICAgICAgICAgICAgICAgICAgIEFORCBcXGB0b2tlbl9pZFxcYCA9ID9cbiAgICAgICAgICAgICAgICAgICBBTkQgXFxgbG9ja2VkXFxgID0gVFJVRVxuICAgICAgICAgICAgICAgICAgIEFORCBcXGBzcGVudF9ieVxcYCBJUyBOVUxMXG4gICAgICAgICAgICAgICAgICAgQU5EIFxcYHZvaWRlZFxcYCA9IEZBTFNFKVxuICAgICAgICAgICAgICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgID0gP1xuICAgICAgICAgICAgICAgICAgIEFORCBcXGB0b2tlbl9pZFxcYCA9ID9gLFxuICAgICAgICAgIFthZGRyZXNzLCB0b2tlbiwgYWRkcmVzcywgdG9rZW5dLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGlzIGlzIGJlaW5nIHVubG9ja2VkIGR1ZSB0byBhIHRpbWVsb2NrLCBhbHNvIHVwZGF0ZSB0aGUgdGltZWxvY2tfZXhwaXJlcyBjb2x1bW5cbiAgICAgIGlmICh1cGRhdGVUaW1lbG9ja3MpIHtcbiAgICAgICAgYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgICAgICAgIFVQREFURSBcXGBhZGRyZXNzX2JhbGFuY2VcXGBcbiAgICAgICAgICAgICBTRVQgXFxgdGltZWxvY2tfZXhwaXJlc1xcYCA9IChcbiAgICAgICAgICAgICAgIFNFTEVDVCBNSU4oXFxgdGltZWxvY2tcXGApXG4gICAgICAgICAgICAgICAgIEZST00gXFxgdHhfb3V0cHV0XFxgXG4gICAgICAgICAgICAgICAgV0hFUkUgXFxgYWRkcmVzc1xcYCA9ID9cbiAgICAgICAgICAgICAgICAgIEFORCBcXGB0b2tlbl9pZFxcYCA9ID9cbiAgICAgICAgICAgICAgICAgIEFORCBcXGBsb2NrZWRcXGAgPSBUUlVFXG4gICAgICAgICAgICAgICAgICBBTkQgXFxgc3BlbnRfYnlcXGAgSVMgTlVMTFxuICAgICAgICAgICAgICAgICAgQU5EIFxcYHZvaWRlZFxcYCA9IEZBTFNFXG4gICAgICAgICAgICAgKVxuICAgICAgICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgID0gP1xuICAgICAgICAgICAgIEFORCBcXGB0b2tlbl9pZFxcYCA9ID9gLFxuICAgICAgICBbYWRkcmVzcywgdG9rZW4sIGFkZHJlc3MsIHRva2VuXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdW5sb2NrZWQgYW5kIGxvY2tlZCBiYWxhbmNlcyBmb3Igd2FsbGV0cy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGJhbGFuY2Ugb2YgYSB3YWxsZXQgbWlnaHQgY2hhbmdlIGFzIGEgbG9ja2VkIGFtb3VudCBiZWNvbWVzIHVubG9ja2VkLiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXNcbiAqIHRoZSB3YWxsZXRfYmFsYW5jZSB0YWJsZSwgc3VidHJhY3RpbmcgZnJvbSB0aGUgbG9ja2VkIGNvbHVtbiBhbmQgYWRkaW5nIHRvIHRoZSB1bmxvY2tlZCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHdhbGxldEJhbGFuY2VNYXAgLSBBIG1hcCBvZiB3YWxsZXRJZCBhbmQgdGhlIHVubG9ja2VkIGJhbGFuY2VzXG4gKiBAcGFyYW0gdXBkYXRlVGltZWxvY2tzIC0gSWYgdGhpcyB1cGRhdGUgaXMgdHJpZ2dlcmVkIGJ5IGEgdGltZWxvY2sgZXhwaXJpbmcsIHVwZGF0ZSB0aGUgbmV4dCBsb2NrIGV4cGlyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVdhbGxldExvY2tlZEJhbGFuY2UgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHdhbGxldEJhbGFuY2VNYXA6IFN0cmluZ01hcDxUb2tlbkJhbGFuY2VNYXA+LFxuICB1cGRhdGVUaW1lbG9ja3MgPSBmYWxzZSxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBmb3IgKGNvbnN0IFt3YWxsZXRJZCwgdG9rZW5CYWxhbmNlTWFwXSBvZiBPYmplY3QuZW50cmllcyh3YWxsZXRCYWxhbmNlTWFwKSkge1xuICAgIGZvciAoY29uc3QgW3Rva2VuLCB0b2tlbkJhbGFuY2VdIG9mIHRva2VuQmFsYW5jZU1hcC5pdGVyYXRvcigpKSB7XG4gICAgICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAgICAgYFVQREFURSBcXGB3YWxsZXRfYmFsYW5jZVxcYFxuICAgICAgICAgICAgU0VUIFxcYHVubG9ja2VkX2JhbGFuY2VcXGAgPSBcXGB1bmxvY2tlZF9iYWxhbmNlXFxgICsgPyxcbiAgICAgICAgICAgICAgICBcXGBsb2NrZWRfYmFsYW5jZVxcYCA9IFxcYGxvY2tlZF9iYWxhbmNlXFxgIC0gPyxcbiAgICAgICAgICAgICAgICBcXGB1bmxvY2tlZF9hdXRob3JpdGllc1xcYCA9IChcXGB1bmxvY2tlZF9hdXRob3JpdGllc1xcYCB8ID8pXG4gICAgICAgICAgV0hFUkUgXFxgd2FsbGV0X2lkXFxgID0gP1xuICAgICAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gP2AsXG4gICAgICAgIFt0b2tlbkJhbGFuY2UudW5sb2NrZWRBbW91bnQsIHRva2VuQmFsYW5jZS51bmxvY2tlZEFtb3VudCxcbiAgICAgICAgICB0b2tlbkJhbGFuY2UudW5sb2NrZWRBdXRob3JpdGllcy50b0ludGVnZXIoKSwgd2FsbGV0SWQsIHRva2VuXSxcbiAgICAgICk7XG5cbiAgICAgIC8vIGlmIGFueSBhdXRob3JpdHkgaGFzIGJlZW4gdW5sb2NrZWQsIHdlIGhhdmUgdG8gcmVmcmVzaCB0aGUgbG9ja2VkIGF1dGhvcml0aWVzXG4gICAgICBpZiAodG9rZW5CYWxhbmNlLnVubG9ja2VkQXV0aG9yaXRpZXMudG9JbnRlZ2VyKCkgPiAwKSB7XG4gICAgICAgIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgICAgIGBVUERBVEUgXFxgd2FsbGV0X2JhbGFuY2VcXGBcbiAgICAgICAgICAgICAgU0VUIFxcYGxvY2tlZF9hdXRob3JpdGllc1xcYCA9IChcbiAgICAgICAgICAgICAgICBTRUxFQ1QgQklUX09SKFxcYGxvY2tlZF9hdXRob3JpdGllc1xcYClcbiAgICAgICAgICAgICAgICAgIEZST00gXFxgYWRkcmVzc19iYWxhbmNlXFxgXG4gICAgICAgICAgICAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGAgSU4gKFxuICAgICAgICAgICAgICAgICAgIFNFTEVDVCBcXGBhZGRyZXNzXFxgXG4gICAgICAgICAgICAgICAgICAgICBGUk9NIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgICAgICAgICAgICAgV0hFUkUgXFxgd2FsbGV0X2lkXFxgID0gPylcbiAgICAgICAgICAgICAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gPylcbiAgICAgICAgICAgIFdIRVJFIFxcYHdhbGxldF9pZFxcYCA9ID9cbiAgICAgICAgICAgICAgQU5EIFxcYHRva2VuX2lkXFxgID0gP2AsXG4gICAgICAgICAgW3dhbGxldElkLCB0b2tlbiwgd2FsbGV0SWQsIHRva2VuXSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhpcyBpcyBiZWluZyB1bmxvY2tlZCBkdWUgdG8gYSB0aW1lbG9jaywgYWxzbyB1cGRhdGUgdGhlIHRpbWVsb2NrX2V4cGlyZXMgY29sdW1uXG4gICAgICBpZiAodXBkYXRlVGltZWxvY2tzKSB7XG4gICAgICAgIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgICAgIGBVUERBVEUgXFxgd2FsbGV0X2JhbGFuY2VcXGBcbiAgICAgICAgICAgICAgU0VUIFxcYHRpbWVsb2NrX2V4cGlyZXNcXGAgPSAoXG4gICAgICAgICAgICAgICAgU0VMRUNUIE1JTihcXGB0aW1lbG9ja19leHBpcmVzXFxgKVxuICAgICAgICAgICAgICAgICAgRlJPTSBcXGBhZGRyZXNzX2JhbGFuY2VcXGBcbiAgICAgICAgICAgICAgICAgV0hFUkUgXFxgYWRkcmVzc1xcYFxuICAgICAgICAgICAgICAgICAgICBJTiAoXG4gICAgICAgICAgICAgICAgICAgICAgU0VMRUNUIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgICAgICAgICAgICAgICAgIEZST00gXFxgYWRkcmVzc1xcYFxuICAgICAgICAgICAgICAgICAgICAgICBXSEVSRSBcXGB3YWxsZXRfaWRcXGAgPSA/KVxuICAgICAgICAgICAgICAgICAgIEFORCBcXGB0b2tlbl9pZFxcYCA9ID8pXG4gICAgICAgICAgICBXSEVSRSBcXGB3YWxsZXRfaWRcXGAgPSA/IEFORCBcXGB0b2tlbl9pZFxcYCA9ID9gLFxuICAgICAgICAgIFt3YWxsZXRJZCwgdG9rZW4sIHdhbGxldElkLCB0b2tlbl0sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIHdhbGxldCdzIGFkZHJlc3Nlcy5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gd2FsbGV0SWQgLSBXYWxsZXQgaWRcbiAqIEBwYXJhbSBmaWx0ZXJBZGRyZXNzZXMgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gZmlsdGVyIGFkZHJlc3NlcyBmcm9tIHRoZSBsaXN0XG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgYWRkcmVzc2VzIGFuZCB0aGVpciBpbmZvIChpbmRleCBhbmQgdHJhbnNhY3Rpb25zKVxuICovXG5leHBvcnQgY29uc3QgZ2V0V2FsbGV0QWRkcmVzc2VzID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsIHdhbGxldElkOiBzdHJpbmcsIGZpbHRlckFkZHJlc3Nlcz86IHN0cmluZ1tdKTogUHJvbWlzZTxBZGRyZXNzSW5mb1tdPiA9PiB7XG4gIGNvbnN0IGFkZHJlc3NlczogQWRkcmVzc0luZm9bXSA9IFtdO1xuICBjb25zdCBzdWJRdWVyeSA9IGZpbHRlckFkZHJlc3NlcyA/IGBcbiAgICBBTkQgXFxgYWRkcmVzc1xcYCBJTiAoPylcbiAgYCA6ICcnO1xuXG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgIFNFTEVDVCAqXG4gICAgICBGUk9NIFxcYGFkZHJlc3NcXGBcbiAgICAgV0hFUkUgXFxgd2FsbGV0X2lkXFxgID0gP1xuICAgICAgJHtzdWJRdWVyeX1cbiAgT1JERVIgQlkgXFxgaW5kZXhcXGBcbiAgICAgICBBU0NgLCBbd2FsbGV0SWQsIGZpbHRlckFkZHJlc3Nlc10pO1xuXG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBjb25zdCBhZGRyZXNzID0ge1xuICAgICAgYWRkcmVzczogcmVzdWx0LmFkZHJlc3MgYXMgc3RyaW5nLFxuICAgICAgaW5kZXg6IHJlc3VsdC5pbmRleCBhcyBudW1iZXIsXG4gICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMgYXMgbnVtYmVyLFxuICAgIH07XG4gICAgYWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XG4gIH1cbiAgcmV0dXJuIGFkZHJlc3Nlcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBlbXB0eSBhZGRyZXNzZXMgb2YgYSB3YWxsZXQgYWZ0ZXIgdGhlIGxhc3QgdXNlZCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHdhbGxldElkIC0gV2FsbGV0IGlkXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgYWRkcmVzc2VzIGFuZCB0aGVpciBpbmRleGVzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXROZXdBZGRyZXNzZXMgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgd2FsbGV0SWQ6IHN0cmluZyk6IFByb21pc2U8U2hvcnRBZGRyZXNzSW5mb1tdPiA9PiB7XG4gIGNvbnN0IGFkZHJlc3NlczogU2hvcnRBZGRyZXNzSW5mb1tdID0gW107XG4gIGNvbnN0IHJlc3VsdHNXYWxsZXQ6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoJ1NFTEVDVCAqIEZST00gYHdhbGxldGAgV0hFUkUgYGlkYCA9ID8nLCB3YWxsZXRJZCk7XG4gIGlmIChyZXN1bHRzV2FsbGV0Lmxlbmd0aCkge1xuICAgIGNvbnN0IGdhcExpbWl0ID0gcmVzdWx0c1dhbGxldFswXS5tYXhfZ2FwIGFzIG51bWJlcjtcbiAgICBjb25zdCBsYXRlc3RVc2VkSW5kZXggPSByZXN1bHRzV2FsbGV0WzBdLmxhc3RfdXNlZF9hZGRyZXNzX2luZGV4IGFzIG51bWJlcjtcbiAgICAvLyBTZWxlY3QgYWxsIGFkZHJlc3NlcyB0aGF0IGFyZSBlbXB0eSBhbmQgdGhlIGluZGV4IGlzIGJpZ2dlciB0aGFuIHRoZSBsYXN0IHVzZWQgYWRkcmVzcyBpbmRleFxuICAgIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgICAgU0VMRUNUICpcbiAgICAgICAgRlJPTSBcXGBhZGRyZXNzXFxgXG4gICAgICAgV0hFUkUgXFxgd2FsbGV0X2lkXFxgID0gP1xuICAgICAgICAgQU5EIFxcYHRyYW5zYWN0aW9uc1xcYCA9IDBcbiAgICAgICAgIEFORCBcXGBpbmRleFxcYCA+ID9cbiAgICBPUkRFUiBCWSBcXGBpbmRleFxcYFxuICAgICAgICAgQVNDXG4gICAgTElNSVQgP2AsIFt3YWxsZXRJZCwgbGF0ZXN0VXNlZEluZGV4LCBnYXBMaW1pdF0pO1xuXG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgY29uc3QgaW5kZXggPSByZXN1bHQuaW5kZXggYXMgbnVtYmVyO1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHtcbiAgICAgICAgYWRkcmVzczogcmVzdWx0LmFkZHJlc3MgYXMgc3RyaW5nLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgYWRkcmVzc1BhdGg6IGdldEFkZHJlc3NQYXRoKGluZGV4KSxcbiAgICAgIH07XG4gICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZHJlc3Nlcztcbn07XG5cbi8qKlxuICogR2V0IGEgd2FsbGV0J3MgYmFsYW5jZXMuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRva2VuSWRzIGlzIGdpdmVuLCBnZXQgdGhlIGJhbGFuY2UgZm9yIGp1c3QgdGhvc2UgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFdhbGxldCBpZFxuICogQHBhcmFtIHRva2VuSWRzIC0gQSBsaXN0IG9mIHRva2VuIGlkc1xuICogQHJldHVybnMgQSBsaXN0IG9mIGJhbGFuY2VzLlxuICovXG5leHBvcnQgY29uc3QgZ2V0V2FsbGV0QmFsYW5jZXMgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgd2FsbGV0SWQ6IHN0cmluZywgdG9rZW5JZHM6IHN0cmluZ1tdID0gW10pOiBQcm9taXNlPFdhbGxldFRva2VuQmFsYW5jZVtdPiA9PiB7XG4gIGNvbnN0IGJhbGFuY2VzOiBXYWxsZXRUb2tlbkJhbGFuY2VbXSA9IFtdO1xuICBsZXQgc3VicXVlcnkgPSAnU0VMRUNUICogRlJPTSBgd2FsbGV0X2JhbGFuY2VgIFdIRVJFIGB3YWxsZXRfaWRgID0gPyc7XG4gIGNvbnN0IHBhcmFtczogdW5rbm93bltdID0gW3dhbGxldElkXTtcbiAgaWYgKHRva2VuSWRzLmxlbmd0aCA+IDApIHtcbiAgICBzdWJxdWVyeSArPSAnIEFORCBgdG9rZW5faWRgIElOICg/KSc7XG4gICAgcGFyYW1zLnB1c2godG9rZW5JZHMpO1xuICB9XG5cbiAgY29uc3QgcXVlcnkgPSBgXG4gICAgU0VMRUNUIHcudG90YWxfcmVjZWl2ZWQgQVMgdG90YWxfcmVjZWl2ZWQsXG4gICAgICAgICAgIHcudW5sb2NrZWRfYmFsYW5jZSBBUyB1bmxvY2tlZF9iYWxhbmNlLFxuICAgICAgICAgICB3LmxvY2tlZF9iYWxhbmNlIEFTIGxvY2tlZF9iYWxhbmNlLFxuICAgICAgICAgICB3LnVubG9ja2VkX2F1dGhvcml0aWVzIEFTIHVubG9ja2VkX2F1dGhvcml0aWVzLFxuICAgICAgICAgICB3LmxvY2tlZF9hdXRob3JpdGllcyBBUyBsb2NrZWRfYXV0aG9yaXRpZXMsXG4gICAgICAgICAgIHcudGltZWxvY2tfZXhwaXJlcyBBUyB0aW1lbG9ja19leHBpcmVzLFxuICAgICAgICAgICB3LnRyYW5zYWN0aW9ucyBBUyB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgIHcudG9rZW5faWQgQVMgdG9rZW5faWQsXG4gICAgICAgICAgIHRva2VuLm5hbWUgQVMgbmFtZSxcbiAgICAgICAgICAgdG9rZW4uc3ltYm9sIEFTIHN5bWJvbFxuICAgICAgRlJPTSAoJHtzdWJxdWVyeX0pIHdcbklOTkVSIEpPSU4gdG9rZW4gT04gdy50b2tlbl9pZCA9IHRva2VuLmlkXG4gIGA7XG5cbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShxdWVyeSwgcGFyYW1zKTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGNvbnN0IHRvdGFsQW1vdW50ID0gcmVzdWx0LnRvdGFsX3JlY2VpdmVkIGFzIG51bWJlcjtcbiAgICBjb25zdCB1bmxvY2tlZEJhbGFuY2UgPSByZXN1bHQudW5sb2NrZWRfYmFsYW5jZSBhcyBudW1iZXI7XG4gICAgY29uc3QgbG9ja2VkQmFsYW5jZSA9IHJlc3VsdC5sb2NrZWRfYmFsYW5jZSBhcyBudW1iZXI7XG4gICAgY29uc3QgdW5sb2NrZWRBdXRob3JpdGllcyA9IG5ldyBBdXRob3JpdGllcyhyZXN1bHQudW5sb2NrZWRfYXV0aG9yaXRpZXMgYXMgbnVtYmVyKTtcbiAgICBjb25zdCBsb2NrZWRBdXRob3JpdGllcyA9IG5ldyBBdXRob3JpdGllcyhyZXN1bHQubG9ja2VkX2F1dGhvcml0aWVzIGFzIG51bWJlcik7XG4gICAgY29uc3QgdGltZWxvY2tFeHBpcmVzID0gcmVzdWx0LnRpbWVsb2NrX2V4cGlyZXMgYXMgbnVtYmVyO1xuXG4gICAgY29uc3QgYmFsYW5jZSA9IG5ldyBXYWxsZXRUb2tlbkJhbGFuY2UoXG4gICAgICBuZXcgVG9rZW5JbmZvKHJlc3VsdC50b2tlbl9pZCBhcyBzdHJpbmcsIHJlc3VsdC5uYW1lIGFzIHN0cmluZywgcmVzdWx0LnN5bWJvbCBhcyBzdHJpbmcpLFxuICAgICAgbmV3IEJhbGFuY2UodG90YWxBbW91bnQsIHVubG9ja2VkQmFsYW5jZSwgbG9ja2VkQmFsYW5jZSwgdGltZWxvY2tFeHBpcmVzLCB1bmxvY2tlZEF1dGhvcml0aWVzLCBsb2NrZWRBdXRob3JpdGllcyksXG4gICAgICByZXN1bHQudHJhbnNhY3Rpb25zIGFzIG51bWJlcixcbiAgICApO1xuICAgIGJhbGFuY2VzLnB1c2goYmFsYW5jZSk7XG4gIH1cblxuICByZXR1cm4gYmFsYW5jZXM7XG59O1xuXG4vKipcbiAqIEdldHMgYSBsaXN0IG9mIHRva2VucyB0aGF0IGEgZ2l2ZW4gd2FsbGV0IGhhcyBldmVyIGludGVyYWN0ZWQgd2l0aFxuICpcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiB0b2tlbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRXYWxsZXRUb2tlbnMgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHdhbGxldElkOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZ1tdPiA9PiB7XG4gIGNvbnN0IHRva2VuTGlzdDogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUIERJU1RJTkNUKHRva2VuX2lkKVxuICAgICAgIEZST00gXFxgd2FsbGV0X3R4X2hpc3RvcnlcXGBcbiAgICAgIFdIRVJFIFxcYHdhbGxldF9pZFxcYCA9ID9gLFxuICAgIFt3YWxsZXRJZF0sXG4gICk7XG5cbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIHRva2VuTGlzdC5wdXNoKDxzdHJpbmc+IHJlc3VsdC50b2tlbl9pZCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5MaXN0O1xufTtcblxuLyoqXG4gKiBHZXQgYSB3YWxsZXQncyB0cmFuc2FjdGlvbiBoaXN0b3J5IGZvciBhIHRva2VuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUcmFuc2FjdGlvbnMgYXJlIG9yZGVyZWQgYnkgdGltZXN0YW1wIGRlc2NlbmRpbmcgLSBpLmUuIG1vc3QgcmVjZW50IGZpcnN0LlxuICpcbiAqICdza2lwJyBkZXRlcm1pbmVzIGhvdyBtYW55IHRyYW5zYWN0aW9ucyB3aWxsIGJlIHNraXBwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICpcbiAqICdjb3VudCcgZGV0ZXJtaW5lcyBob3cgbWFueSB0cmFuc2FjdGlvbnMgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gd2FsbGV0SWQgLSBXYWxsZXQgaWRcbiAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWRcbiAqIEBwYXJhbSBza2lwIC0gTnVtYmVyIG9mIHRyYW5zYWN0aW9ucyB0byBza2lwXG4gKiBAcGFyYW0gY291bnQgLSBOdW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRvIHJldHVyblxuICogQHJldHVybnMgQSBsaXN0IG9mIGJhbGFuY2VzLlxuICovXG5leHBvcnQgY29uc3QgZ2V0V2FsbGV0VHhIaXN0b3J5ID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICB0b2tlbklkOiBzdHJpbmcsXG4gIHNraXA6IG51bWJlcixcbiAgY291bnQ6IG51bWJlcixcbik6IFByb21pc2U8VHhUb2tlbkJhbGFuY2VbXT4gPT4ge1xuICBjb25zdCBoaXN0b3J5OiBUeFRva2VuQmFsYW5jZVtdID0gW107XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgIFNFTEVDVCB3YWxsZXRfdHhfaGlzdG9yeS5iYWxhbmNlIEFTIGJhbGFuY2UsXG4gICAgICAgICAgIHdhbGxldF90eF9oaXN0b3J5LnRpbWVzdGFtcCBBUyB0aW1lc3RhbXAsXG4gICAgICAgICAgIHdhbGxldF90eF9oaXN0b3J5LnRva2VuX2lkIEFTIHRva2VuX2lkLFxuICAgICAgICAgICB3YWxsZXRfdHhfaGlzdG9yeS50eF9pZCBBUyB0eF9pZCxcbiAgICAgICAgICAgd2FsbGV0X3R4X2hpc3Rvcnkudm9pZGVkIEFTIHZvaWRlZCxcbiAgICAgICAgICAgd2FsbGV0X3R4X2hpc3Rvcnkud2FsbGV0X2lkIEFTIHdhbGxldF9pZCxcbiAgICAgICAgICAgdHJhbnNhY3Rpb24udmVyc2lvbiBBUyB2ZXJzaW9uXG4gICAgICBGUk9NIHdhbGxldF90eF9oaXN0b3J5XG5MRUZUIE9VVEVSIEpPSU4gdHJhbnNhY3Rpb24gT04gdHJhbnNhY3Rpb24udHhfaWQgPSB3YWxsZXRfdHhfaGlzdG9yeS50eF9pZFxuICAgICBXSEVSRSB3YWxsZXRfaWQgPSA/XG4gICAgICAgQU5EIHRva2VuX2lkID0gP1xuICBPUkRFUiBCWSB3YWxsZXRfdHhfaGlzdG9yeS50aW1lc3RhbXBcbiAgICAgIERFU0NcbiAgICAgTElNSVQgPywgP2AsXG4gIFt3YWxsZXRJZCwgdG9rZW5JZCwgc2tpcCwgY291bnRdKTtcblxuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgY29uc3QgdHg6IFR4VG9rZW5CYWxhbmNlID0ge1xuICAgICAgdHhJZDogPHN0cmluZz5yZXN1bHQudHhfaWQsXG4gICAgICB0aW1lc3RhbXA6IDxudW1iZXI+cmVzdWx0LnRpbWVzdGFtcCxcbiAgICAgIHZvaWRlZDogPGJvb2xlYW4+cmVzdWx0LnZvaWRlZCxcbiAgICAgIGJhbGFuY2U6IDxCYWxhbmNlPnJlc3VsdC5iYWxhbmNlLFxuICAgICAgdmVyc2lvbjogPG51bWJlcj5yZXN1bHQudmVyc2lvbixcbiAgICB9O1xuICAgIGhpc3RvcnkucHVzaCh0eCk7XG4gIH1cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdXR4b3MgdGhhdCBhcmUgbG9ja2VkIGF0IGEgY2VydGFpbiBoZWlnaHQuXG4gKlxuICogQHJlbWFya3NcbiAqIFVUWE9zIGZyb20gYmxvY2tzIGFyZSBsb2NrZWQgYnkgaGVpZ2h0LiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIG9uZXMgdGhhdCBhcmUgbG9ja2VkIGF0IHRoZSBnaXZlbiBoZWlnaHQuXG4gKlxuICogQWxzbywgdGhlc2UgVVRYT3MgbWlnaHQgaGF2ZSBhIHRpbWVsb2NrLiBFdmVuIHRob3VnaCB0aGlzIGlzIG5vdCBjb21tb24sIGl0IGlzIGFsc28gY29uc2lkZXJlZC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gbm93IC0gQ3VycmVudCB0aW1lc3RhbXBcbiAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgYmxvY2sgaGVpZ2h0IHF1ZXJpZWRcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBVVFhPcyBsb2NrZWQgYXQgdGhlIGdpdmVuIGhlaWdodFxuICovXG5leHBvcnQgY29uc3QgZ2V0VXR4b3NMb2NrZWRBdEhlaWdodCA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgbm93OiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuKTogUHJvbWlzZTxEYlR4T3V0cHV0W10+ID0+IHtcbiAgY29uc3QgdXR4b3MgPSBbXTtcbiAgaWYgKGhlaWdodCA+PSAwKSB7XG4gICAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAgIGBTRUxFQ1QgKlxuICAgICAgICAgRlJPTSBcXGB0eF9vdXRwdXRcXGBcbiAgICAgICAgV0hFUkUgXFxgaGVpZ2h0bG9ja1xcYCA9ID9cbiAgICAgICAgICBBTkQgXFxgc3BlbnRfYnlcXGAgSVMgTlVMTFxuICAgICAgICAgIEFORCBcXGB2b2lkZWRcXGAgPSBGQUxTRVxuICAgICAgICAgIEFORCAoXFxgdGltZWxvY2tcXGAgPD0gP1xuICAgICAgICAgICAgICAgT1IgXFxgdGltZWxvY2tcXGAgaXMgTlVMTClcbiAgICAgICAgICBBTkQgXFxgbG9ja2VkXFxgID0gMWAsXG4gICAgICBbaGVpZ2h0LCBub3ddLFxuICAgICk7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgY29uc3QgdXR4bzogRGJUeE91dHB1dCA9IHtcbiAgICAgICAgdHhJZDogcmVzdWx0LnR4X2lkIGFzIHN0cmluZyxcbiAgICAgICAgaW5kZXg6IHJlc3VsdC5pbmRleCBhcyBudW1iZXIsXG4gICAgICAgIHRva2VuSWQ6IHJlc3VsdC50b2tlbl9pZCBhcyBzdHJpbmcsXG4gICAgICAgIGFkZHJlc3M6IHJlc3VsdC5hZGRyZXNzIGFzIHN0cmluZyxcbiAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSBhcyBudW1iZXIsXG4gICAgICAgIGF1dGhvcml0aWVzOiByZXN1bHQuYXV0aG9yaXRpZXMgYXMgbnVtYmVyLFxuICAgICAgICB0aW1lbG9jazogcmVzdWx0LnRpbWVsb2NrIGFzIG51bWJlcixcbiAgICAgICAgaGVpZ2h0bG9jazogcmVzdWx0LmhlaWdodGxvY2sgYXMgbnVtYmVyLFxuICAgICAgICBsb2NrZWQ6IHJlc3VsdC5sb2NrZWQgPiAwLFxuICAgICAgfTtcbiAgICAgIHV0eG9zLnB1c2godXR4byk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1dHhvcztcbn07XG5cbi8qKlxuICogR2V0IFVUWE9zIHRoYXQgY2FuIGJlIHVubG9ja2VkIGZvciBhIGdpdmVuIHdhbGxldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogR2V0IHRoZSBVVFhPcyB0aGF0IGFyZSBzdGlsbCBtYXJrZWQgYXMgbG9ja2VkIGluIHRoZSB1dHhvIHRhYmxlIGJ1dCB3aG9zZSBsb2NrcyAoaGVpZ2h0IGFuZCB0aW1lKVxuICogaGF2ZSBhbHJlYWR5IGV4cGlyZWQuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHdhbGxldElkIC0gVGhlIHdhbGxldCdzIGlkXG4gKiBAcGFyYW0gbm93IC0gVGhlIGN1cnJlbnQgdGltZXN0YW1wXG4gKiBAcGFyYW0gY3VycmVudEhlaWdodCAtIExhdGVzdCBibG9jayBoZWlnaHRcbiAqIEByZXR1cm5zIFRoZSBsYXRlc3QgaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRXYWxsZXRVbmxvY2tlZFV0eG9zID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICBub3c6IG51bWJlcixcbiAgY3VycmVudEhlaWdodDogbnVtYmVyLFxuKTogUHJvbWlzZTxEYlR4T3V0cHV0W10+ID0+IHtcbiAgY29uc3QgdXR4b3MgPSBbXTtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUICpcbiAgICAgICBGUk9NIFxcYHR4X291dHB1dFxcYFxuICAgICAgV0hFUkUgKFxcYGhlaWdodGxvY2tcXGAgPD0gP1xuICAgICAgICAgICAgIE9SIFxcYGhlaWdodGxvY2tcXGAgaXMgTlVMTClcbiAgICAgICAgQU5EIChcXGB0aW1lbG9ja1xcYCA8PSA/XG4gICAgICAgICAgICAgT1IgXFxgdGltZWxvY2tcXGAgaXMgTlVMTClcbiAgICAgICAgQU5EIFxcYGxvY2tlZFxcYCA9IDFcbiAgICAgICAgQU5EIFxcYHNwZW50X2J5XFxgIElTIE5VTExcbiAgICAgICAgQU5EIFxcYHZvaWRlZFxcYCA9IEZBTFNFXG4gICAgICAgIEFORCBcXGBhZGRyZXNzXFxgIElOIChcbiAgICAgICAgICBTRUxFQ1QgXFxgYWRkcmVzc1xcYFxuICAgICAgICAgICAgRlJPTSBcXGBhZGRyZXNzXFxgXG4gICAgICAgICAgIFdIRVJFIFxcYHdhbGxldF9pZFxcYCA9ID8pYCxcbiAgICBbY3VycmVudEhlaWdodCwgbm93LCB3YWxsZXRJZF0sXG4gICk7XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBjb25zdCB1dHhvOiBEYlR4T3V0cHV0ID0ge1xuICAgICAgdHhJZDogcmVzdWx0LnR4X2lkIGFzIHN0cmluZyxcbiAgICAgIGluZGV4OiByZXN1bHQuaW5kZXggYXMgbnVtYmVyLFxuICAgICAgdG9rZW5JZDogcmVzdWx0LnRva2VuX2lkIGFzIHN0cmluZyxcbiAgICAgIGFkZHJlc3M6IHJlc3VsdC5hZGRyZXNzIGFzIHN0cmluZyxcbiAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUgYXMgbnVtYmVyLFxuICAgICAgYXV0aG9yaXRpZXM6IHJlc3VsdC5hdXRob3JpdGllcyBhcyBudW1iZXIsXG4gICAgICB0aW1lbG9jazogcmVzdWx0LnRpbWVsb2NrIGFzIG51bWJlcixcbiAgICAgIGhlaWdodGxvY2s6IHJlc3VsdC5oZWlnaHRsb2NrIGFzIG51bWJlcixcbiAgICAgIGxvY2tlZDogcmVzdWx0LmxvY2tlZCA+IDAsXG4gICAgfTtcbiAgICB1dHhvcy5wdXNoKHV0eG8pO1xuICB9XG4gIHJldHVybiB1dHhvcztcbn07XG5cbi8qKlxuICogVXBkYXRlIGxhdGVzdCB2ZXJzaW9uX2RhdGEgb24gdGhlIGRhdGFiYXNlXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGRhdGEgLSBMYXRlc3QgdmVyc2lvbiBkYXRhIHRvIHN0b3JlXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVWZXJzaW9uRGF0YSA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCBkYXRhOiBGdWxsTm9kZVZlcnNpb25EYXRhKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkOiAxLFxuICAgIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAsXG4gICAgdmVyc2lvbjogZGF0YS52ZXJzaW9uLFxuICAgIG5ldHdvcms6IGRhdGEubmV0d29yayxcbiAgICBtaW5fd2VpZ2h0OiBkYXRhLm1pbldlaWdodCxcbiAgICBtaW5fdHhfd2VpZ2h0OiBkYXRhLm1pblR4V2VpZ2h0LFxuICAgIG1pbl90eF93ZWlnaHRfY29lZmZpY2llbnQ6IGRhdGEubWluVHhXZWlnaHRDb2VmZmljaWVudCxcbiAgICBtaW5fdHhfd2VpZ2h0X2s6IGRhdGEubWluVHhXZWlnaHRLLFxuICAgIHRva2VuX2RlcG9zaXRfcGVyY2VudGFnZTogZGF0YS50b2tlbkRlcG9zaXRQZXJjZW50YWdlLFxuICAgIHJld2FyZF9zcGVuZF9taW5fYmxvY2tzOiBkYXRhLnJld2FyZFNwZW5kTWluQmxvY2tzLFxuICAgIG1heF9udW1iZXJfaW5wdXRzOiBkYXRhLm1heE51bWJlcklucHV0cyxcbiAgICBtYXhfbnVtYmVyX291dHB1dHM6IGRhdGEubWF4TnVtYmVyT3V0cHV0cyxcbiAgfTtcblxuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAnSU5TRVJUIElOVE8gYHZlcnNpb25fZGF0YWAgU0VUID8gT04gRFVQTElDQVRFIEtFWSBVUERBVEUgPycsXG4gICAgW2VudHJ5LCBlbnRyeV0sXG4gICk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBsYXRlc3QgdmVyc2lvbl9jaGVjayB0aW1lXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFZlcnNpb25EYXRhID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwpOiBQcm9taXNlPEZ1bGxOb2RlVmVyc2lvbkRhdGEgfCBudWxsPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoJ1NFTEVDVCAqIEZST00gYHZlcnNpb25fZGF0YWAgV0hFUkUgaWQgPSAxIExJTUlUIDE7Jyk7XG5cbiAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGRhdGEgPSByZXN1bHRzWzBdO1xuXG4gICAgY29uc3QgZW50cnk6IEZ1bGxOb2RlVmVyc2lvbkRhdGEgPSB7XG4gICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wIGFzIG51bWJlcixcbiAgICAgIHZlcnNpb246IGRhdGEudmVyc2lvbiBhcyBzdHJpbmcsXG4gICAgICBuZXR3b3JrOiBkYXRhLm5ldHdvcmsgYXMgc3RyaW5nLFxuICAgICAgbWluV2VpZ2h0OiBkYXRhLm1pbl93ZWlnaHQgYXMgbnVtYmVyLFxuICAgICAgbWluVHhXZWlnaHQ6IGRhdGEubWluX3R4X3dlaWdodCBhcyBudW1iZXIsXG4gICAgICBtaW5UeFdlaWdodENvZWZmaWNpZW50OiBkYXRhLm1pbl90eF93ZWlnaHRfY29lZmZpY2llbnQgYXMgbnVtYmVyLFxuICAgICAgbWluVHhXZWlnaHRLOiBkYXRhLm1pbl90eF93ZWlnaHRfayBhcyBudW1iZXIsXG4gICAgICB0b2tlbkRlcG9zaXRQZXJjZW50YWdlOiBkYXRhLnRva2VuX2RlcG9zaXRfcGVyY2VudGFnZSBhcyBudW1iZXIsXG4gICAgICByZXdhcmRTcGVuZE1pbkJsb2NrczogZGF0YS5yZXdhcmRfc3BlbmRfbWluX2Jsb2NrcyBhcyBudW1iZXIsXG4gICAgICBtYXhOdW1iZXJJbnB1dHM6IGRhdGEubWF4X251bWJlcl9pbnB1dHMgYXMgbnVtYmVyLFxuICAgICAgbWF4TnVtYmVyT3V0cHV0czogZGF0YS5tYXhfbnVtYmVyX291dHB1dHMgYXMgbnVtYmVyLFxuICAgIH07XG5cbiAgICByZXR1cm4gZW50cnk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGhlaWdodCBpbmZvIGZyb20gZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHJldHVybnMgVGhlIGxhdGVzdCBoZWlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldExhdGVzdEhlaWdodCA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUIFxcYGhlaWdodFxcYCBBUyB2YWx1ZVxuICAgICAgIEZST00gXFxgdHJhbnNhY3Rpb25cXGBcbiAgICAgIFdIRVJFIHZlcnNpb25cbiAgICAgICAgIElOICg/KVxuICAgICAgT1JERVIgQlkgaGVpZ2h0XG4gICAgICAgREVTQ1xuICAgICAgTElNSVQgMWAsIFtCTE9DS19WRVJTSU9OXSxcbiAgKTtcblxuICBpZiAocmVzdWx0cy5sZW5ndGggPiAwICYmIHJlc3VsdHNbMF0udmFsdWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0c1swXS52YWx1ZSBhcyBudW1iZXI7XG4gIH1cblxuICAvLyBpdCBzaG91bGQgbmV2ZXIgY29tZSBoZXJlLCBhcyBnZW5lc2lzIGJsb2NrIHNob3VsZCBiZSBhZGRlZCBhdCBzdGFydHVwXG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBiZXN0IGJsb2NrIGZyb20gdGhlIGRhdGFiYXNlXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIFRoZSBsYXRlc3QgaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMYXRlc3RCbG9ja0J5SGVpZ2h0ID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwpOiBQcm9taXNlPEJsb2NrPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCAqXG4gICAgICAgRlJPTSBcXGB0cmFuc2FjdGlvblxcYFxuICAgICAgV0hFUkUgXFxgdmVyc2lvblxcYCBJTiAoPylcbiAgICAgIE9SREVSIEJZIGhlaWdodCBERVNDXG4gICAgICBMSU1JVCAxYCwgW0JMT0NLX1ZFUlNJT05dLFxuICApO1xuXG4gIGlmIChyZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHhJZDogcmVzdWx0c1swXS50eF9pZCBhcyBzdHJpbmcsXG4gICAgICBoZWlnaHQ6IHJlc3VsdHNbMF0uaGVpZ2h0IGFzIG51bWJlcixcbiAgICAgIHRpbWVzdGFtcDogcmVzdWx0c1swXS50aW1lc3RhbXAgYXMgbnVtYmVyLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGJsb2NrIGJ5IGhlaWdodFxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIHF1ZXJ5XG4gKlxuICogQHJldHVybnMgVGhlIGxhdGVzdCBoZWlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJsb2NrQnlIZWlnaHQgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgaGVpZ2h0OiBudW1iZXIpOiBQcm9taXNlPEJsb2NrPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCAqXG4gICAgICAgRlJPTSBcXGB0cmFuc2FjdGlvblxcYFxuICAgICAgV0hFUkUgXFxgaGVpZ2h0XFxgID0gP1xuICAgICAgICBBTkQgXFxgdmVyc2lvblxcYCBJTiAoPylcbiAgICAgIExJTUlUIDFgLCBbaGVpZ2h0LCBCTE9DS19WRVJTSU9OXSxcbiAgKTtcblxuICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SWQ6IHJlc3VsdHNbMF0udHhfaWQgYXMgc3RyaW5nLFxuICAgICAgaGVpZ2h0OiByZXN1bHRzWzBdLmhlaWdodCBhcyBudW1iZXIsXG4gICAgICB0aW1lc3RhbXA6IHJlc3VsdHNbMF0udGltZXN0YW1wIGFzIG51bWJlcixcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFN0b3JlIHRoZSB0b2tlbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbidzIGlkXG4gKiBAcGFyYW0gdG9rZW5OYW1lIC0gVGhlIHRva2VuJ3MgbmFtZVxuICogQHBhcmFtIHRva2VuU3ltYm9sIC0gVGhlIHRva2VuJ3Mgc3ltYm9sXG4gKi9cbmV4cG9ydCBjb25zdCBzdG9yZVRva2VuSW5mb3JtYXRpb24gPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRva2VuSWQ6IHN0cmluZyxcbiAgdG9rZW5OYW1lOiBzdHJpbmcsXG4gIHRva2VuU3ltYm9sOiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgZW50cnkgPSB7IGlkOiB0b2tlbklkLCBuYW1lOiB0b2tlbk5hbWUsIHN5bWJvbDogdG9rZW5TeW1ib2wgfTtcbiAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgJ0lOU0VSVCBJTlRPIGB0b2tlbmAgU0VUID8nLFxuICAgIFtlbnRyeV0sXG4gICk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdG9rZW4gaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHRva2VuSWQgLSBUaGUgdG9rZW4ncyBpZFxuICogQHJldHVybnMgVGhlIHRva2VuIGluZm9ybWF0aW9uIChvciBudWxsIGlmIGlkIGlzIG5vdCBmb3VuZClcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRva2VuSW5mb3JtYXRpb24gPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRva2VuSWQ6IHN0cmluZyxcbik6IFByb21pc2U8VG9rZW5JbmZvPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgJ1NFTEVDVCAqIEZST00gYHRva2VuYCBXSEVSRSBgaWRgID0gPycsXG4gICAgW3Rva2VuSWRdLFxuICApO1xuICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4gbmV3IFRva2VuSW5mbyh0b2tlbklkLCByZXN1bHRzWzBdLm5hbWUgYXMgc3RyaW5nLCByZXN1bHRzWzBdLnN5bWJvbCBhcyBzdHJpbmcpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHVudXNlZCBhZGRyZXNzZXMgZm9yIGEgd2FsbGV0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBBbiB1bnN1ZWQgYWRkcmVzcyBpcyBhbiBhZGRyZXNzIHdpdGggMCB0cmFuc2FjdGlvbnMuIEFkZHJlc3NlcyBhcmUgb3JkZXJlZCBieSBpbmRleCwgYXNjZW5kaW5nLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQncyBpZFxuICogQHJldHVybnMgTGlzdCBvZiB1bnVzZWQgYWRkcmVzc2VzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVbnVzZWRBZGRyZXNzZXMgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgd2FsbGV0SWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgJ1NFTEVDVCBgYWRkcmVzc2AgRlJPTSBgYWRkcmVzc2AgV0hFUkUgYHdhbGxldF9pZGAgPSA/IEFORCBgdHJhbnNhY3Rpb25zYCA9IDAgT1JERVIgQlkgYGluZGV4YCBBU0MnLFxuICAgIFt3YWxsZXRJZF0sXG4gICk7XG5cbiAgZm9yIChjb25zdCBlbnRyeSBvZiByZXN1bHRzKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IGVudHJ5LmFkZHJlc3MgYXMgc3RyaW5nO1xuICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICB9XG4gIHJldHVybiBhZGRyZXNzZXM7XG59O1xuXG4vKipcbiAqIE1hcmsgdGhlIGdpdmVuIFVUWE9zIHdpdGggdGhlIHR4UHJvcG9zYWxJZC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHhQcm9wb3NhbElkIC0gVGhlIHRyYW5zYWN0aW9uIHByb3Bvc2FsIGlkXG4gKiBAcGFyYW0gdXR4b3MgLSBUaGUgVVRYT3MgdG8gYmUgbWFya2VkIHdpdGggdGhlIHByb3Bvc2FsIGlkXG4gKi9cbmV4cG9ydCBjb25zdCBtYXJrVXR4b3NXaXRoUHJvcG9zYWxJZCA9IGFzeW5jIChteXNxbDogU2VydmVybGVzc015c3FsLCB0eFByb3Bvc2FsSWQ6IHN0cmluZywgdXR4b3M6IERiVHhPdXRwdXRbXSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBlbnRyaWVzID0gdXR4b3MubWFwKCh1dHhvLCBpbmRleCkgPT4gKFt1dHhvLnR4SWQsIHV0eG8uaW5kZXgsICcnLCAnJywgMCwgMCwgbnVsbCwgbnVsbCwgZmFsc2UsIHR4UHJvcG9zYWxJZCwgaW5kZXgsIG51bGwsIDBdKSk7XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBJTlNFUlQgSU5UTyBcXGB0eF9vdXRwdXRcXGBcbiAgICAgICAgICBWQUxVRVMgP1xuICAgICAgICAgICAgICBPTiBEVVBMSUNBVEUgS0VZXFxcbiAgICAgICAgICBVUERBVEUgXFxgdHhfcHJvcG9zYWxcXGAgPSBWQUxVRVMoXFxgdHhfcHJvcG9zYWxcXGApLFxuICAgICAgICAgICAgICAgICBcXGB0eF9wcm9wb3NhbF9pbmRleFxcYCA9IFZBTFVFUyhcXGB0eF9wcm9wb3NhbF9pbmRleFxcYClgLFxuICAgIFtlbnRyaWVzXSxcbiAgKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgdHggcHJvcG9zYWwgb24gdGhlIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eFByb3Bvc2FsSWQgLSBUaGUgdHJhbnNhY3Rpb24gcHJvcG9zYWwgaWRcbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHJvcG9zYWxcbiAqIEBwYXJhbSBub3cgLSBUaGUgY3VycmVudCB0aW1lc3RhbXBcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVR4UHJvcG9zYWwgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4UHJvcG9zYWxJZDogc3RyaW5nLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICBub3c6IG51bWJlcixcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBlbnRyeSA9IHsgaWQ6IHR4UHJvcG9zYWxJZCwgd2FsbGV0X2lkOiB3YWxsZXRJZCwgc3RhdHVzOiBUeFByb3Bvc2FsU3RhdHVzLk9QRU4sIGNyZWF0ZWRfYXQ6IG5vdyB9O1xuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAnSU5TRVJUIElOVE8gYHR4X3Byb3Bvc2FsYCBTRVQgPycsXG4gICAgW2VudHJ5XSxcbiAgKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgbGlzdCBvZiB0eCBwcm9wb3NhbHMuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHR4UHJvcG9zYWxJZHMgLSBUaGUgdHJhbnNhY3Rpb24gcHJvcG9zYWwgaWRzXG4gKiBAcGFyYW0gbm93IC0gVGhlIGN1cnJlbnQgdGltZXN0YW1wXG4gKiBAcGFyYW0gc3RhdHVzIC0gVGhlIG5ldyBzdGF0dXNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVR4UHJvcG9zYWwgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4UHJvcG9zYWxJZHM6IHN0cmluZ1tdLFxuICBub3c6IG51bWJlcixcbiAgc3RhdHVzOiBUeFByb3Bvc2FsU3RhdHVzLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KGBcbiAgICBVUERBVEUgXFxgdHhfcHJvcG9zYWxcXGBcbiAgICAgICBTRVQgXFxgdXBkYXRlZF9hdFxcYCA9ID8sXG4gICAgICAgICAgIFxcYHN0YXR1c1xcYCA9ID9cbiAgICAgV0hFUkUgXFxgaWRcXGAgSU4gKD8pYCwgW1xuICAgIG5vdyxcbiAgICBzdGF0dXMsXG4gICAgdHhQcm9wb3NhbElkcyxcbiAgXSk7XG59O1xuXG4vKipcbiAqIEdldCBhIHR4IHByb3Bvc2FsLlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eFByb3Bvc2FsSWQgLSBUaGUgdHJhbnNhY3Rpb24gcHJvcG9zYWwgaWRcbiAqIEBwYXJhbSBub3cgLSBUaGUgY3VycmVudCB0aW1lc3RhbXBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFR4UHJvcG9zYWwgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4UHJvcG9zYWxJZDogc3RyaW5nLFxuKTogUHJvbWlzZTxUeFByb3Bvc2FsPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgJ1NFTEVDVCAqIEZST00gYHR4X3Byb3Bvc2FsYCBXSEVSRSBgaWRgID0gPycsXG4gICAgW3R4UHJvcG9zYWxJZF0sXG4gICk7XG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgaWQ6IHR4UHJvcG9zYWxJZCxcbiAgICB3YWxsZXRJZDogcmVzdWx0c1swXS53YWxsZXRfaWQgYXMgc3RyaW5nLFxuICAgIHN0YXR1czogcmVzdWx0c1swXS5zdGF0dXMgYXMgVHhQcm9wb3NhbFN0YXR1cyxcbiAgICBjcmVhdGVkQXQ6IHJlc3VsdHNbMF0uY3JlYXRlZF9hdCBhcyBudW1iZXIsXG4gICAgdXBkYXRlZEF0OiByZXN1bHRzWzBdLnVwZGF0ZWRfYXQgYXMgbnVtYmVyLFxuICB9O1xufTtcblxuLyoqXG4gKiBXaGVuIGEgdHggcHJvcG9zYWwgaXMgY2FuY2VsbGVkIHdlIG11c3QgcmVsZWFzZSB0aGUgdXR4b3MgdG8gYmUgdXNlZCBieSBvdGhlcnNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHhQcm9wb3NhbElkIC0gVGhlIHRyYW5zYWN0aW9uIHByb3Bvc2FsIGlkXG4gKi9cbmV4cG9ydCBjb25zdCByZWxlYXNlVHhQcm9wb3NhbFV0eG9zID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB0eFByb3Bvc2FsSWRzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCByZXN1bHQ6IE9rUGFja2V0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFVQREFURSBcXGB0eF9vdXRwdXRcXGBcbiAgICAgICAgU0VUIFxcYHR4X3Byb3Bvc2FsXFxgID0gTlVMTCxcbiAgICAgICAgICAgIFxcYHR4X3Byb3Bvc2FsX2luZGV4XFxgID0gTlVMTFxuICAgICAgV0hFUkUgXFxgdHhfcHJvcG9zYWxcXGAgSU4gKD8pYCxcbiAgICBbdHhQcm9wb3NhbElkc10sXG4gICk7XG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsKFxuICAgIHJlc3VsdC5hZmZlY3RlZFJvd3MsXG4gICAgdHhQcm9wb3NhbElkcy5sZW5ndGgsXG4gICAgJ05vdCBhbGwgdXR4b3Mgd2VyZSBjb3JyZWN0bHkgdXBkYXRlZCcsXG4gICk7XG59O1xuXG4vKipcbiAqIEdldCB0eHMgYWZ0ZXIgYSBnaXZlbiBoZWlnaHRcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBzZWFyY2hcblxuICogQHJldHVybnMgQSBsaXN0IG9mIHR4c1xuICovXG5leHBvcnQgY29uc3QgZ2V0VHhzQWZ0ZXJIZWlnaHQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIGhlaWdodDogbnVtYmVyLFxuKTogUHJvbWlzZTxUeFtdPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCAqXG4gICAgICAgRlJPTSBcXGB0cmFuc2FjdGlvblxcYFxuICAgICAgV0hFUkUgXFxgaGVpZ2h0XFxgID4gP1xuICAgICAgICBBTkQgXFxgdm9pZGVkXFxgID0gRkFMU0VgLFxuICAgIFtoZWlnaHRdLFxuICApO1xuXG4gIHJldHVybiBnZXRUeHNGcm9tREJSZXN1bHQocmVzdWx0cyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIHR4IG91dHB1dHMgZnJvbSB0cmFuc2FjdGlvbnNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25zIC0gVGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zXG5cbiAqIEByZXR1cm5zIEEgbGlzdCBvZiB0eCBvdXRwdXRzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUeE91dHB1dHMgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRyYW5zYWN0aW9uczogVHhbXSxcbik6IFByb21pc2U8RGJUeE91dHB1dFtdPiA9PiB7XG4gIGNvbnN0IHR4SWRzID0gdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHR4LnR4SWQpO1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgKlxuICAgICAgIEZST00gXFxgdHhfb3V0cHV0XFxgXG4gICAgICBXSEVSRSBcXGB0eF9pZFxcYCBJTiAoPylgLFxuICAgIFt0eElkc10sXG4gICk7XG5cbiAgY29uc3QgdXR4b3MgPSBbXTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGNvbnN0IHV0eG86IERiVHhPdXRwdXQgPSB7XG4gICAgICB0eElkOiByZXN1bHQudHhfaWQgYXMgc3RyaW5nLFxuICAgICAgaW5kZXg6IHJlc3VsdC5pbmRleCBhcyBudW1iZXIsXG4gICAgICB0b2tlbklkOiByZXN1bHQudG9rZW5faWQgYXMgc3RyaW5nLFxuICAgICAgYWRkcmVzczogcmVzdWx0LmFkZHJlc3MgYXMgc3RyaW5nLFxuICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSBhcyBudW1iZXIsXG4gICAgICBhdXRob3JpdGllczogcmVzdWx0LmF1dGhvcml0aWVzIGFzIG51bWJlcixcbiAgICAgIHRpbWVsb2NrOiByZXN1bHQudGltZWxvY2sgYXMgbnVtYmVyLFxuICAgICAgaGVpZ2h0bG9jazogcmVzdWx0LmhlaWdodGxvY2sgYXMgbnVtYmVyLFxuICAgICAgbG9ja2VkOiByZXN1bHQubG9ja2VkID4gMCxcbiAgICAgIHR4UHJvcG9zYWxJZDogcmVzdWx0LnR4X3Byb3Bvc2FsIGFzIHN0cmluZyxcbiAgICAgIHR4UHJvcG9zYWxJbmRleDogcmVzdWx0LnR4X3Byb3Bvc2FsX2luZGV4IGFzIG51bWJlcixcbiAgICAgIHNwZW50Qnk6IHJlc3VsdC5zcGVudF9ieSA/IHJlc3VsdC5zcGVudF9ieSBhcyBzdHJpbmcgOiBudWxsLFxuICAgIH07XG4gICAgdXR4b3MucHVzaCh1dHhvKTtcbiAgfVxuXG4gIHJldHVybiB1dHhvcztcbn07XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgZnJvbSB0aGVpciB0eElkc1xuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eElkcyAtIFRoZSBsaXN0IG9mIHRyYW5zYWN0aW9uIGlkc1xuXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUcmFuc2FjdGlvbnNCeUlkID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB0eElkczogc3RyaW5nW10sXG4pOiBQcm9taXNlPFR4W10+ID0+IHtcbiAgaWYgKHR4SWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCAqXG4gICAgICAgRlJPTSBcXGB0cmFuc2FjdGlvblxcYFxuICAgICAgV0hFUkUgXFxgdHhfaWRcXGAgSU4gKD8pXG4gICAgICAgIEFORCBcXGB2b2lkZWRcXGAgPSBGQUxTRWAsXG4gICAgW3R4SWRzXSxcbiAgKTtcblxuICByZXR1cm4gZ2V0VHhzRnJvbURCUmVzdWx0KHJlc3VsdHMpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIHR4IG91dHB1dHMgZnJvbSB0aGVpciBzcGVudF9ieSB0eElkXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHR4SWRzIC0gVGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIHRoYXQgc3BlbnQgdGhlIHR4X291dHB1dHMgd2UgYXJlIHF1ZXJ5aW5nXG5cbiAqIEByZXR1cm5zIEEgbGlzdCBvZiB0eF9vdXRwdXRzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUeE91dHB1dHNCeVNwZW50ID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB0eElkczogc3RyaW5nW10sXG4pOiBQcm9taXNlPERiVHhPdXRwdXRbXT4gPT4ge1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgKlxuICAgICAgIEZST00gXFxgdHhfb3V0cHV0XFxgXG4gICAgICBXSEVSRSBcXGBzcGVudF9ieVxcYCBJTiAoPylgLFxuICAgIFt0eElkc10sXG4gICk7XG5cbiAgY29uc3QgdXR4b3MgPSBbXTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGNvbnN0IHV0eG86IERiVHhPdXRwdXQgPSB7XG4gICAgICB0eElkOiByZXN1bHQudHhfaWQgYXMgc3RyaW5nLFxuICAgICAgaW5kZXg6IHJlc3VsdC5pbmRleCBhcyBudW1iZXIsXG4gICAgICB0b2tlbklkOiByZXN1bHQudG9rZW5faWQgYXMgc3RyaW5nLFxuICAgICAgYWRkcmVzczogcmVzdWx0LmFkZHJlc3MgYXMgc3RyaW5nLFxuICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSBhcyBudW1iZXIsXG4gICAgICBhdXRob3JpdGllczogcmVzdWx0LmF1dGhvcml0aWVzIGFzIG51bWJlcixcbiAgICAgIHRpbWVsb2NrOiByZXN1bHQudGltZWxvY2sgYXMgbnVtYmVyLFxuICAgICAgaGVpZ2h0bG9jazogcmVzdWx0LmhlaWdodGxvY2sgYXMgbnVtYmVyLFxuICAgICAgbG9ja2VkOiByZXN1bHQubG9ja2VkID4gMCxcbiAgICAgIHR4UHJvcG9zYWxJZDogcmVzdWx0LnR4X3Byb3Bvc2FsIGFzIHN0cmluZyxcbiAgICAgIHR4UHJvcG9zYWxJbmRleDogcmVzdWx0LnR4X3Byb3Bvc2FsX2luZGV4IGFzIG51bWJlcixcbiAgICAgIHNwZW50Qnk6IHJlc3VsdC5zcGVudF9ieSA/IHJlc3VsdC5zcGVudF9ieSBhcyBzdHJpbmcgOiBudWxsLFxuICAgIH07XG5cbiAgICB1dHhvcy5wdXNoKHV0eG8pO1xuICB9XG5cbiAgcmV0dXJuIHV0eG9zO1xufTtcblxuLyoqXG4gKiBTZXQgYSBsaXN0IG9mIHR4X291dHB1dHMgYXMgdW5zcGVudFxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eE91dHB1dHMgLSBUaGUgbGlzdCBvZiB0eF9vdXRwdXRzIHRvIHVuc3BlbmRcbiAqL1xuZXhwb3J0IGNvbnN0IHVuc3BlbmRVdHhvcyA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgdHhPdXRwdXRzOiBEYlR4T3V0cHV0W10sXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgdHhJZEluZGV4TGlzdCA9IHR4T3V0cHV0cy5tYXAoKHR4T3V0cHV0KSA9PiBbdHhPdXRwdXQudHhJZCwgdHhPdXRwdXQuaW5kZXhdKTtcblxuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgVVBEQVRFIFxcYHR4X291dHB1dFxcYFxuICAgICAgICBTRVQgXFxgc3BlbnRfYnlcXGAgPSBOVUxMXG4gICAgICBXSEVSRSAoXFxgdHhfaWRcXGAsIFxcYGluZGV4XFxgKSBJTiAoPylgLFxuICAgIFt0eElkSW5kZXhMaXN0XSxcbiAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlaWdodCBmcm9tIHRyYW5zYWN0aW9ucyB3ZSB3YW50IHRvIHNlbmQgYmFjayB0byB0aGUgYG1lbXBvb2xgXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHR4cyAtIFRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyB0byByZW1vdmUgaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVUeHNIZWlnaHQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4czogVHhbXSxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCB0eElkcyA9IHR4cy5tYXAoKHR4KSA9PiB0eC50eElkKTtcblxuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgVVBEQVRFIFxcYHRyYW5zYWN0aW9uXFxgXG4gICAgICAgIFNFVCBcXGBoZWlnaHRcXGAgPSBOVUxMXG4gICAgICBXSEVSRSBcXGB0eF9pZFxcYCBJTiAoPylgLFxuICAgIFt0eElkc10sXG4gICk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgdXR4b3MgZnJvbSB0aGUgdHhfb3V0cHV0cyB0YWJsZVxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB1dHhvcyAtIFRoZSBsaXN0IG9mIHV0eG9zIHRvIGRlbGV0ZSBmcm9tIHRoZSBkYXRhYmFzZVxuICovXG5leHBvcnQgY29uc3QgbWFya1V0eG9zQXNWb2lkZWQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHV0eG9zOiBEYlR4T3V0cHV0W10sXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgdHhJZHMgPSB1dHhvcy5tYXAoKHR4KSA9PiB0eC50eElkKTtcblxuICBhd2FpdCBteXNxbC5xdWVyeShgXG4gICAgVVBEQVRFIFxcYHR4X291dHB1dFxcYFxuICAgICAgIFNFVCBcXGB2b2lkZWRcXGAgPSBUUlVFXG4gICAgIFdIRVJFIFxcYHR4X2lkXFxgIElOICg/KWAsXG4gIFt0eElkc10pO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYWxsIGJsb2NrcyBzdGFydGluZyBmcm9tIGEgZ2l2ZW4gaGVpZ2h0XG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gc3RhcnQgZGVsZXRpbmcgZnJvbVxuICovXG5leHBvcnQgY29uc3QgZGVsZXRlQmxvY2tzQWZ0ZXJIZWlnaHQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIGhlaWdodDogbnVtYmVyLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBERUxFVEUgRlJPTSBcXGB0cmFuc2FjdGlvblxcYFxuICAgICAgV0hFUkUgaGVpZ2h0ID4gP1xuICAgICAgICBBTkQgdmVyc2lvbiBJTiAoPylgLFxuICAgIFtoZWlnaHQsIEJMT0NLX1ZFUlNJT05dLFxuICApO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0cmFuc2FjdGlvbnMgYXMgdm9pZGVkIG9uIHRoZSBkYXRhYmFzZVxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgLSBUaGUgbGlzdCBvZiB0cmFuc2FjdGlvbnMgdG8gcmVtb3ZlIGZyb20gZGF0YWJhc2VcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcmtUeHNBc1ZvaWRlZCA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgdHJhbnNhY3Rpb25zOiBUeFtdLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IHR4SWRzID0gdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHR4LnR4SWQpO1xuXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBVUERBVEUgXFxgdHJhbnNhY3Rpb25cXGBcbiAgICAgICAgU0VUIFxcYHZvaWRlZFxcYCA9IFRSVUVcbiAgICAgIFdIRVJFIFxcYHR4X2lkXFxgIElOICg/KWAsXG4gICAgW3R4SWRzXSxcbiAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCByZWNvcmRzIGZyb20gYWRkcmVzc190eF9oaXN0b3J5IHRoYXQgYmVsb25nIHRvIHRoZSB0cmFuc2FjdGlvbiBsaXN0XG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHRyYW5zYWN0aW9ucyAtIFRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyB0byBzZWFyY2hcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcmtBZGRyZXNzVHhIaXN0b3J5QXNWb2lkZWQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRyYW5zYWN0aW9uczogVHhbXSxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCB0eElkcyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB0eC50eElkKTtcblxuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgVVBEQVRFIFxcYGFkZHJlc3NfdHhfaGlzdG9yeVxcYFxuICAgICAgICBTRVQgXFxgdm9pZGVkXFxgID0gVFJVRVxuICAgICAgV0hFUkUgXFxgdHhfaWRcXGAgSU4gKD8pYCxcbiAgICBbdHhJZHNdLFxuICApO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIHJlY29yZHMgZnJvbSB3YWxsZXRfdHhfaGlzdG9yeSB0aGF0IGJlbG9uZyB0byB0aGUgdHJhbnNhY3Rpb24gbGlzdFxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgLSBUaGUgbGlzdCBvZiB0cmFuc2FjdGlvbnMgdG8gc2VhcmNoXG4gKi9cbmV4cG9ydCBjb25zdCBtYXJrV2FsbGV0VHhIaXN0b3J5QXNWb2lkZWQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRyYW5zYWN0aW9uczogVHhbXSxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCB0eElkcyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB0eC50eElkKTtcblxuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgVVBEQVRFIFxcYHdhbGxldF90eF9oaXN0b3J5XFxgXG4gICAgICAgIFNFVCBcXGB2b2lkZWRcXGAgPSBUUlVFXG4gICAgICBXSEVSRSBcXGB0eF9pZFxcYCBJTiAoPylgLFxuICAgIFt0eElkc10sXG4gICk7XG59O1xuXG4vKipcbiAqIFJlYnVpbGRzIHRoZSBhZGRyZXNzX2JhbGFuY2UgdGFibGUgZm9yIHRoZSBnaXZlbiBhZGRyZXNzZXMgZnJvbVxuICogdGhlIHR4X291dHB1dCB0YWJsZVxuXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gYWRkcmVzc2VzIC0gVGhlIGxpc3Qgb2YgYWRkcmVzc2VzIHRvIHJlYnVpbGRcbiAqIEBwYXJhbSB0eExpc3QgLSBUaGUgbGlzdCBvZiBhZmZlY3RlZCB0cmFuc2FjdGlvbnMsIHRvIHJlYnVpbGQgdGhlIHRyYW5zYWN0aW9uIGNvdW50XG4gKi9cbmV4cG9ydCBjb25zdCByZWJ1aWxkQWRkcmVzc0JhbGFuY2VzRnJvbVV0eG9zID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICBhZGRyZXNzZXM6IHN0cmluZ1tdLFxuICB0eExpc3Q6IHN0cmluZ1tdLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICh0eExpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB3ZSBzaG91bGQgdGhyb3cgc28gdGhlIHJlLW9yZyBpcyByb2xsZWQgYmFja1xuICAgIC8vIGFuZCBhbiBlcnJvciBpcyB0cmlnZ2VyZWQgZm9yIG1hbnVhbCBpbnNwZWN0aW9uXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gcmVidWlsZCBhZGRyZXNzIGJhbGFuY2VzIGJ1dCBubyB0cmFuc2FjdGlvbnMgd2VyZSBhZmZlY3RlZCcpO1xuICB9XG4gIC8vIGZpcnN0IHdlIG5lZWQgdG8gc3RvcmUgdGhlIHRyYW5zYWN0aW9ucyBjb3VudCBiZWZvcmUgZGVsZXRpbmdcbiAgY29uc3Qgb2xkQWRkcmVzc1Rva2VuVHJhbnNhY3Rpb25zOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgXFxgYWRkcmVzc1xcYCwgXFxgdG9rZW5faWRcXGAgQVMgdG9rZW5JZCwgXFxgdHJhbnNhY3Rpb25zXFxgLCBcXGB0b3RhbF9yZWNlaXZlZFxcYCBhcyBcXGB0b3RhbFJlY2VpdmVkXFxgXG4gICAgICAgRlJPTSBcXGBhZGRyZXNzX2JhbGFuY2VcXGBcbiAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGAgSU4gKD8pYCxcbiAgICBbYWRkcmVzc2VzXSxcbiAgKTtcblxuICAvLyBkZWxldGUgYWZmZWN0ZWQgYWRkcmVzc19iYWxhbmNlc1xuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgVVBEQVRFIFxcYGFkZHJlc3NfYmFsYW5jZVxcYFxuICAgICAgICBTRVQgXFxgdW5sb2NrZWRfYmFsYW5jZVxcYCA9IDAsXG4gICAgICAgICAgICBcXGBsb2NrZWRfYmFsYW5jZVxcYCA9IDAsXG4gICAgICAgICAgICBcXGBsb2NrZWRfYXV0aG9yaXRpZXNcXGAgPSAwLFxuICAgICAgICAgICAgXFxgdW5sb2NrZWRfYXV0aG9yaXRpZXNcXGAgPSAwLFxuICAgICAgICAgICAgXFxgdGltZWxvY2tfZXhwaXJlc1xcYCA9IE5VTEwsXG4gICAgICAgICAgICBcXGB0cmFuc2FjdGlvbnNcXGAgPSAwXG4gICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgIElOICg/KWAsXG4gICAgW2FkZHJlc3Nlc10sXG4gICk7XG5cbiAgLy8gdXBkYXRlIGFkZHJlc3MgYmFsYW5jZXMgd2l0aCB1bmxvY2tlZCB1dHhvc1xuICBhd2FpdCBteXNxbC5xdWVyeShgXG4gICAgSU5TRVJUIElOVE8gYWRkcmVzc19iYWxhbmNlIChcbiAgICAgIFxcYGFkZHJlc3NcXGAsXG4gICAgICBcXGB0b2tlbl9pZFxcYCxcbiAgICAgIFxcYHVubG9ja2VkX2JhbGFuY2VcXGAsXG4gICAgICBcXGBsb2NrZWRfYmFsYW5jZVxcYCxcbiAgICAgIFxcYHVubG9ja2VkX2F1dGhvcml0aWVzXFxgLFxuICAgICAgXFxgbG9ja2VkX2F1dGhvcml0aWVzXFxgLFxuICAgICAgXFxgdGltZWxvY2tfZXhwaXJlc1xcYCxcbiAgICAgIFxcYHRyYW5zYWN0aW9uc1xcYFxuICAgIClcbiAgICAgICAgU0VMRUNUIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG9rZW5faWQsXG4gICAgICAgICAgICAgICAgU1VNKFxcYHZhbHVlXFxgKSwgLS0gdW5sb2NrZWRfYmFsYW5jZVxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgQklUX09SKFxcYGF1dGhvcml0aWVzXFxgKSwgLS0gdW5sb2NrZWRfYXV0aG9yaXRpZXNcbiAgICAgICAgICAgICAgICAwLCAtLSBsb2NrZWRfYXV0aG9yaXRpZXNcbiAgICAgICAgICAgICAgICBOVUxMLCAtLSB0aW1lbG9ja19leHBpcmVzXG4gICAgICAgICAgICAgICAgMCAtLSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICBGUk9NIFxcYHR4X291dHB1dFxcYFxuICAgICAgICAgV0hFUkUgc3BlbnRfYnkgSVMgTlVMTFxuICAgICAgICAgICBBTkQgdm9pZGVkID0gRkFMU0VcbiAgICAgICAgICAgQU5EIGxvY2tlZCA9IEZBTFNFXG4gICAgICAgICAgIEFORCBhZGRyZXNzIElOICg/KVxuICAgICAgR1JPVVAgQlkgYWRkcmVzcywgdG9rZW5faWRcbiAgIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFXG4gICAgdW5sb2NrZWRfYmFsYW5jZSA9IFZBTFVFUyh1bmxvY2tlZF9iYWxhbmNlKSxcbiAgICB1bmxvY2tlZF9hdXRob3JpdGllcyA9IFZBTFVFUyh1bmxvY2tlZF9hdXRob3JpdGllcylcbiAgYCwgW2FkZHJlc3Nlc10pO1xuXG4gIC8vIHVwZGF0ZSBhZGRyZXNzIGJhbGFuY2VzIHdpdGggbG9ja2VkIHV0eG9zXG4gIGF3YWl0IG15c3FsLnF1ZXJ5KGBcbiAgICBJTlNFUlQgSU5UTyBcXGBhZGRyZXNzX2JhbGFuY2VcXGAgKFxuICAgICAgXFxgYWRkcmVzc1xcYCxcbiAgICAgIFxcYHRva2VuX2lkXFxgLFxuICAgICAgXFxgdW5sb2NrZWRfYmFsYW5jZVxcYCxcbiAgICAgIFxcYGxvY2tlZF9iYWxhbmNlXFxgLFxuICAgICAgXFxgbG9ja2VkX2F1dGhvcml0aWVzXFxgLFxuICAgICAgXFxgdGltZWxvY2tfZXhwaXJlc1xcYCxcbiAgICAgIFxcYHRyYW5zYWN0aW9uc1xcYFxuICAgIClcbiAgICAgICBTRUxFQ1QgYWRkcmVzcyxcbiAgICAgICAgICAgICAgdG9rZW5faWQsXG4gICAgICAgICAgICAgIDAgQVMgdW5sb2NrZWRfYmFsYW5jZSxcbiAgICAgICAgICAgICAgU1VNKFxcYHZhbHVlXFxgKSBBUyBsb2NrZWRfYmFsYW5jZSxcbiAgICAgICAgICAgICAgQklUX09SKFxcYGF1dGhvcml0aWVzXFxgKSBBUyBsb2NrZWRfYXV0aG9yaXRpZXMsXG4gICAgICAgICAgICAgIE1JTihcXGB0aW1lbG9ja1xcYCkgQVMgdGltZWxvY2tfZXhwaXJlcyxcbiAgICAgICAgICAgICAgMCAtLSB0cmFuc2FjdGlvbnNcbiAgICAgICAgIEZST00gXFxgdHhfb3V0cHV0XFxgXG4gICAgICAgIFdIRVJFIHNwZW50X2J5IElTIE5VTExcbiAgICAgICAgICBBTkQgdm9pZGVkID0gRkFMU0VcbiAgICAgICAgICBBTkQgbG9ja2VkID0gVFJVRVxuICAgICAgICAgIEFORCBhZGRyZXNzIElOICg/KVxuICAgICBHUk9VUCBCWSBcXGBhZGRyZXNzXFxgLCBcXGB0b2tlbl9pZFxcYFxuICAgT04gRFVQTElDQVRFIEtFWSBVUERBVEVcbiAgICBsb2NrZWRfYmFsYW5jZSA9IFZBTFVFUyhsb2NrZWRfYmFsYW5jZSksXG4gICAgbG9ja2VkX2F1dGhvcml0aWVzID0gVkFMVUVTKGxvY2tlZF9hdXRob3JpdGllcyksXG4gICAgdGltZWxvY2tfZXhwaXJlcyA9IFZBTFVFUyh0aW1lbG9ja19leHBpcmVzKVxuICAgYCwgW2FkZHJlc3Nlc10pO1xuXG4gIGNvbnN0IGFkZHJlc3NUcmFuc2FjdGlvbkNvdW50OiBTdHJpbmdNYXA8bnVtYmVyPiA9IGF3YWl0IGdldEFmZmVjdGVkQWRkcmVzc1R4Q291bnRGcm9tVHhMaXN0KG15c3FsLCB0eExpc3QpO1xuICBjb25zdCBhZGRyZXNzVG90YWxSZWNlaXZlZDogU3RyaW5nTWFwPG51bWJlcj4gPSBhd2FpdCBnZXRBZmZlY3RlZEFkZHJlc3NUb3RhbFJlY2VpdmVkRnJvbVR4TGlzdChteXNxbCwgdHhMaXN0KTtcbiAgY29uc3QgdG9rZW5UcmFuc2FjdGlvbkNvdW50OiBTdHJpbmdNYXA8bnVtYmVyPiA9IGF3YWl0IGdldEFmZmVjdGVkVG9rZW5UeENvdW50RnJvbVR4TGlzdChteXNxbCwgdHhMaXN0KTtcblxuICBjb25zdCBmaW5hbFZhbHVlcyA9IG9sZEFkZHJlc3NUb2tlblRyYW5zYWN0aW9ucy5tYXAoKHsgYWRkcmVzcywgdG9rZW5JZCwgdHJhbnNhY3Rpb25zLCB0b3RhbFJlY2VpdmVkIH0pID0+IHtcbiAgICBjb25zdCBkaWZmVHJhbnNhY3Rpb25zID0gYWRkcmVzc1RyYW5zYWN0aW9uQ291bnRbYCR7YWRkcmVzc31fJHt0b2tlbklkfWBdIHx8IDA7XG4gICAgY29uc3QgZGlmZlRvdGFsUmVjZWl2ZWQgPSBhZGRyZXNzVG90YWxSZWNlaXZlZFtgJHthZGRyZXNzfV8ke3Rva2VuSWR9YF0gfHwgMDtcblxuICAgIHJldHVybiBbdHJhbnNhY3Rpb25zIGFzIG51bWJlciAtIGRpZmZUcmFuc2FjdGlvbnMsIHRvdGFsUmVjZWl2ZWQgYXMgbnVtYmVyIC0gZGlmZlRvdGFsUmVjZWl2ZWQsIGFkZHJlc3MsIHRva2VuSWRdO1xuICB9KTtcblxuICAvLyB1cGRhdGUgYWRkcmVzcyBiYWxhbmNlcyB3aXRoIHRoZSBjb3JyZWN0IGFtb3VudCBvZiB0cmFuc2FjdGlvbnNcbiAgLy8gV2UgaGF2ZSB0byBydW4gbXVsdGlwbGUgdXBkYXRlcyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gaW5zZXJ0IG5ldyByb3dzIHRvIHRoZSB0YWJsZSAod2hpY2ggd291bGQgYmUgZG9uZVxuICAvLyBpZiB3ZSB1c2VkIHRoZSBJTlNFUlQgLi4uIE9OIENPTkZMSUNUIHN5bnRheClcbiAgZm9yIChjb25zdCBpdGVtIG9mIGZpbmFsVmFsdWVzKSB7XG4gICAgYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgICAgVVBEQVRFIFxcYGFkZHJlc3NfYmFsYW5jZVxcYFxuICAgICAgICBTRVQgXFxgdHJhbnNhY3Rpb25zXFxgID0gPyxcbiAgICAgICAgICAgIFxcYHRvdGFsX3JlY2VpdmVkXFxgID0gP1xuICAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGAgPSA/XG4gICAgICAgICBBTkQgXFxgdG9rZW5faWRcXGAgPSA/XG4gICAgYCwgaXRlbSk7XG4gIH1cblxuICAvLyB1cGRhdGUgdG9rZW4gdGFibGUgd2l0aCB0aGUgY29ycmVjdCBhbW91bnQgb2YgdHJhbnNhY3Rpb25zXG4gIGZvciAoY29uc3QgdG9rZW4gb2YgT2JqZWN0LmtleXModG9rZW5UcmFuc2FjdGlvbkNvdW50KSkge1xuICAgIGF3YWl0IG15c3FsLnF1ZXJ5KGBcbiAgICAgIFVQREFURSBcXGB0b2tlblxcYFxuICAgICAgICBTRVQgXFxgdHJhbnNhY3Rpb25zXFxgID0gXFxgdHJhbnNhY3Rpb25zXFxgIC0gP1xuICAgICAgIFdIRVJFIFxcYGlkXFxgID0gP1xuICAgIGAsIFt0b2tlblRyYW5zYWN0aW9uQ291bnRbdG9rZW5dLCB0b2tlbl0pO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIHRyYW5zYWN0aW9uIGZyb20gdGhlIGRhdGFiYXNlIGdpdmVuIGEgdHhJZFxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eElkIC0gVGhlIHRyYW5zYWN0aW9uIGlkIHRvIHNlYXJjaCBmb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoVHggPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4SWQ6IHN0cmluZyxcbik6IFByb21pc2U8VHg+ID0+IHtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUICpcbiAgICAgICBGUk9NIFxcYHRyYW5zYWN0aW9uXFxgXG4gICAgICBXSEVSRSBcXGB0eF9pZFxcYCA9ID9cbiAgICAgICAgQU5EIFxcYHZvaWRlZFxcYCA9IEZBTFNFYCxcbiAgICBbdHhJZF0sXG4gICk7XG5cbiAgY29uc3QgdHhSZXN1bHQgPSBnZXRUeHNGcm9tREJSZXN1bHQocmVzdWx0cyk7XG4gIHJldHVybiBnZXQodHhSZXN1bHQsICdbMF0nLCBudWxsKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgbGlzdCBvZiBgQWRkcmVzc0JhbGFuY2VgcyBmcm9tIGEgbGlzdCBvZiBhZGRyZXNzZXNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gYWRkcmVzc2VzIC0gVGhlIGFkZHJlc3NlcyB0byBxdWVyeVxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hBZGRyZXNzQmFsYW5jZSA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgYWRkcmVzc2VzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8QWRkcmVzc0JhbGFuY2VbXT4gPT4ge1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgKlxuICAgICAgIEZST00gXFxgYWRkcmVzc19iYWxhbmNlXFxgXG4gICAgICBXSEVSRSBcXGBhZGRyZXNzXFxgIElOICg/KVxuICAgT1JERVIgQlkgXFxgYWRkcmVzc1xcYCwgXFxgdG9rZW5faWRcXGBgLFxuICAgIFthZGRyZXNzZXNdLFxuICApO1xuXG4gIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KTogQWRkcmVzc0JhbGFuY2UgPT4gKHtcbiAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzcyBhcyBzdHJpbmcsXG4gICAgdG9rZW5JZDogcmVzdWx0LnRva2VuX2lkIGFzIHN0cmluZyxcbiAgICB1bmxvY2tlZEJhbGFuY2U6IHJlc3VsdC51bmxvY2tlZF9iYWxhbmNlIGFzIG51bWJlcixcbiAgICBsb2NrZWRCYWxhbmNlOiByZXN1bHQubG9ja2VkX2JhbGFuY2UgYXMgbnVtYmVyLFxuICAgIGxvY2tlZEF1dGhvcml0aWVzOiByZXN1bHQubG9ja2VkX2F1dGhvcml0aWVzIGFzIG51bWJlcixcbiAgICB1bmxvY2tlZEF1dGhvcml0aWVzOiByZXN1bHQudW5sb2NrZWRfYXV0aG9yaXRpZXMgYXMgbnVtYmVyLFxuICAgIHRpbWVsb2NrRXhwaXJlczogcmVzdWx0LnRpbWVsb2NrX2V4cGlyZXMgYXMgbnVtYmVyLFxuICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucyBhcyBudW1iZXIsXG4gIH0pKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgbGlzdCBvZiBgQWRkcmVzc1RvdGFsQmFsYW5jZWBzIGZyb20gYSBsaXN0IG9mIGFkZHJlc3Nlc1xuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBhZGRyZXNzZXMgLSBUaGUgYWRkcmVzc2VzIHRvIHF1ZXJ5XG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEFkZHJlc3NUeEhpc3RvcnlTdW0gPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIGFkZHJlc3Nlczogc3RyaW5nW10sXG4pOiBQcm9taXNlPEFkZHJlc3NUb3RhbEJhbGFuY2VbXT4gPT4ge1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBTRUxFQ1QgYWRkcmVzcyxcbiAgICAgICAgICAgIHRva2VuX2lkLFxuICAgICAgICAgICAgU1VNKFxcYGJhbGFuY2VcXGApIEFTIGJhbGFuY2UsXG4gICAgICAgICAgICBDT1VOVChcXGB0eF9pZFxcYCkgQVMgdHJhbnNhY3Rpb25zXG4gICAgICAgRlJPTSBcXGBhZGRyZXNzX3R4X2hpc3RvcnlcXGBcbiAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGAgSU4gKD8pXG4gICAgICAgIEFORCBcXGB2b2lkZWRcXGAgPSBGQUxTRVxuICAgR1JPVVAgQlkgYWRkcmVzcywgdG9rZW5faWRcbiAgIE9SREVSIEJZIGFkZHJlc3MsIHRva2VuX2lkYCxcbiAgICBbYWRkcmVzc2VzXSxcbiAgKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCk6IEFkZHJlc3NUb3RhbEJhbGFuY2UgPT4gKHtcbiAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzcyBhcyBzdHJpbmcsXG4gICAgdG9rZW5JZDogcmVzdWx0LnRva2VuX2lkIGFzIHN0cmluZyxcbiAgICBiYWxhbmNlOiByZXN1bHQuYmFsYW5jZSBhcyBudW1iZXIsXG4gICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zIGFzIG51bWJlcixcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBmaWx0ZXJlZCBsaXN0IG9mIHR4X291dHB1dHNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gZmlsdGVycyAtIEZpbHRlcnMgdG8gYXBwbHkgb24gdGhlIHR4X291dHB1dCBxdWVyeVxuICovXG5leHBvcnQgY29uc3QgZmlsdGVyVHhPdXRwdXRzID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICBmaWx0ZXJzOiBJRmlsdGVyVHhPdXRwdXQgPSB7IGFkZHJlc3NlczogW10gfSxcbik6IFByb21pc2U8RGJUeE91dHB1dFtdPiA9PiB7XG4gIGNvbnN0IGZpbmFsRmlsdGVycyA9IHtcbiAgICBhZGRyZXNzZXM6IFtdLFxuICAgIHRva2VuSWQ6ICcwMCcsXG4gICAgYXV0aG9yaXR5OiAwLFxuICAgIGlnbm9yZUxvY2tlZDogZmFsc2UsXG4gICAgc2tpcFNwZW50OiB0cnVlLFxuICAgIGJpZ2dlclRoYW46IC0xLFxuICAgIHNtYWxsZXJUaGFuOiBjb25zdGFudHMuTUFYX09VVFBVVF9WQUxVRSArIDEsXG4gICAgLi4uZmlsdGVycyxcbiAgfTtcblxuICBpZiAoZmluYWxGaWx0ZXJzLmFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3NlcyBjYW5cXCd0IGJlIGVtcHR5LicpO1xuICB9XG5cbiAgY29uc3QgcXVlcnlQYXJhbXM6IGFueVtdID0gW1xuICAgIGZpbmFsRmlsdGVycy5hZGRyZXNzZXMsXG4gICAgZmluYWxGaWx0ZXJzLnRva2VuSWQsXG4gIF07XG5cbiAgaWYgKGZpbmFsRmlsdGVycy5hdXRob3JpdHkgPT09IDApIHtcbiAgICBxdWVyeVBhcmFtcy5wdXNoKGZpbmFsRmlsdGVycy5zbWFsbGVyVGhhbik7XG4gICAgcXVlcnlQYXJhbXMucHVzaChmaW5hbEZpbHRlcnMuYmlnZ2VyVGhhbik7XG4gIH0gZWxzZSB7XG4gICAgcXVlcnlQYXJhbXMucHVzaChmaW5hbEZpbHRlcnMuYXV0aG9yaXR5KTtcbiAgfVxuXG4gIHF1ZXJ5UGFyYW1zLnB1c2goZmluYWxGaWx0ZXJzLm1heE91dHB1dHMpO1xuXG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFNFTEVDVCAqXG4gICAgICAgRlJPTSBcXGB0eF9vdXRwdXRcXGBcbiAgICAgIFdIRVJFIFxcYGFkZHJlc3NcXGBcbiAgICAgICAgIElOICg/KVxuICAgICAgICBBTkQgXFxgdG9rZW5faWRcXGAgPSA/XG4gICAgICAgICR7ZmluYWxGaWx0ZXJzLmF1dGhvcml0eSAhPT0gMCA/ICdBTkQgYGF1dGhvcml0aWVzYCAmID8gPiAwJyA6ICdBTkQgYGF1dGhvcml0aWVzYCA9IDAnfVxuICAgICAgICAke2ZpbmFsRmlsdGVycy5pZ25vcmVMb2NrZWQgPyAnQU5EIGBsb2NrZWRgID0gRkFMU0UnIDogJyd9XG4gICAgICAgICR7ZmluYWxGaWx0ZXJzLmF1dGhvcml0eSA9PT0gMCA/ICdBTkQgdmFsdWUgPCA/JyA6ICcnfVxuICAgICAgICAke2ZpbmFsRmlsdGVycy5hdXRob3JpdHkgPT09IDAgPyAnQU5EIHZhbHVlID4gPycgOiAnJ31cbiAgICAgICAgJHtmaW5hbEZpbHRlcnMuc2tpcFNwZW50ID8gJ0FORCBgc3BlbnRfYnlgIElTIE5VTEwnIDogJyd9XG4gICAgICAgICR7ZmluYWxGaWx0ZXJzLnNraXBTcGVudCA/ICdBTkQgYHR4X3Byb3Bvc2FsYCBJUyBOVUxMJyA6ICcnfVxuICAgICAgICBBTkQgXFxgdm9pZGVkXFxgID0gRkFMU0VcbiAgIE9SREVSIEJZIFxcYHZhbHVlXFxgIERFU0NcbiAgICAgICAgJHtmaW5hbEZpbHRlcnMubWF4T3V0cHV0cyA/ICdMSU1JVCA/JyA6ICcnfVxuICAgICAgIGAsXG4gICAgcXVlcnlQYXJhbXMsXG4gICk7XG5cbiAgY29uc3QgdXR4b3M6IERiVHhPdXRwdXRbXSA9IHJlc3VsdHMubWFwKG1hcERiUmVzdWx0VG9EYlR4T3V0cHV0KTtcblxuICByZXR1cm4gdXR4b3M7XG59O1xuXG4vKipcbiAqIE1hcHMgdGhlIHJlc3VsdCBmcm9tIHRoZSBkYXRhYmFzZSB0byBEYlR4T3V0cHV0XG4gKlxuICogQHBhcmFtIHJlc3VsdHMgLSBUaGUgdHhfb3V0cHV0IHJlc3VsdHMgZnJvbSB0aGUgZGF0YWJhc2VcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiB0eF9vdXRwdXRzIG1hcHBlZCB0byB0aGUgRGJUeE91dHB1dCB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBEYlJlc3VsdFRvRGJUeE91dHB1dCA9IChyZXN1bHQ6IGFueSk6IERiVHhPdXRwdXQgPT4gKHtcbiAgdHhJZDogcmVzdWx0LnR4X2lkIGFzIHN0cmluZyxcbiAgaW5kZXg6IHJlc3VsdC5pbmRleCBhcyBudW1iZXIsXG4gIHRva2VuSWQ6IHJlc3VsdC50b2tlbl9pZCBhcyBzdHJpbmcsXG4gIGFkZHJlc3M6IHJlc3VsdC5hZGRyZXNzIGFzIHN0cmluZyxcbiAgdmFsdWU6IHJlc3VsdC52YWx1ZSBhcyBudW1iZXIsXG4gIGF1dGhvcml0aWVzOiByZXN1bHQuYXV0aG9yaXRpZXMgYXMgbnVtYmVyLFxuICB0aW1lbG9jazogcmVzdWx0LnRpbWVsb2NrIGFzIG51bWJlcixcbiAgaGVpZ2h0bG9jazogcmVzdWx0LmhlaWdodGxvY2sgYXMgbnVtYmVyLFxuICBsb2NrZWQ6IHJlc3VsdC5sb2NrZWQgPiAwLFxuICB0eFByb3Bvc2FsSWQ6IHJlc3VsdC50eF9wcm9wb3NhbCBhcyBzdHJpbmcsXG4gIHR4UHJvcG9zYWxJbmRleDogcmVzdWx0LnR4X3Byb3Bvc2FsX2luZGV4IGFzIG51bWJlcixcbiAgc3BlbnRCeTogcmVzdWx0LnNwZW50X2J5IGFzIHN0cmluZyxcbn0pO1xuXG4vKipcbiAqIEdldCB0eCBwcm9wb3NhbCBpbnB1dHMuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBpbnB1dHMgYXJlIHRha2VuIGZyb20gdGhlIHV0eG8gdGFibGUuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHR4UHJvcG9zYWxJZCAtIFRoZSB0cmFuc2FjdGlvbiBwcm9wb3NhbCBpZFxuICogQHJldHVybnMgQSBsaXN0IG9mIGlucHV0cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFR4UHJvcG9zYWxJbnB1dHMgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4UHJvcG9zYWxJZDogc3RyaW5nLFxuKTogUHJvbWlzZTxJV2FsbGV0SW5wdXRbXT4gPT4ge1xuICBjb25zdCBpbnB1dHMgPSBbXTtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICAnU0VMRUNUICogRlJPTSBgdHhfb3V0cHV0YCBXSEVSRSBgdHhfcHJvcG9zYWxgID0gPyBPUkRFUiBCWSBgdHhfcHJvcG9zYWxfaW5kZXhgIEFTQycsXG4gICAgW3R4UHJvcG9zYWxJZF0sXG4gICk7XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBjb25zdCBpbnB1dDogSVdhbGxldElucHV0ID0ge1xuICAgICAgdHhJZDogcmVzdWx0LnR4X2lkIGFzIHN0cmluZyxcbiAgICAgIGluZGV4OiByZXN1bHQuaW5kZXggYXMgbnVtYmVyLFxuICAgIH07XG4gICAgaW5wdXRzLnB1c2goaW5wdXQpO1xuICB9XG4gIHJldHVybiBpbnB1dHM7XG59O1xuXG4vKipcbiAqIEdldCBtZW1wb29sIHR4cyBiZWZvcmUgYSBkYXRlXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBzZWFyY2ggZm9yXG5cbiAqIEByZXR1cm5zIEEgbGlzdCBvZiB0eHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE1lbXBvb2xUcmFuc2FjdGlvbnNCZWZvcmVEYXRlID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICBkYXRlOiBudW1iZXIsXG4pOiBQcm9taXNlPFR4W10+ID0+IHtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgU0VMRUNUICpcbiAgICAgICBGUk9NIFxcYHRyYW5zYWN0aW9uXFxgXG4gICAgICBXSEVSRSBcXGB0aW1lc3RhbXBcXGAgPCA/XG4gICAgICAgIEFORCBcXGB2b2lkZWRcXGAgPSBGQUxTRVxuICAgICAgICBBTkQgXFxgaGVpZ2h0XFxgIElTIE5VTExgLFxuICAgIFtkYXRlXSxcbiAgKTtcblxuICByZXR1cm4gZ2V0VHhzRnJvbURCUmVzdWx0KHJlc3VsdHMpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBtaW5lciB0byB0aGUgZGF0YWJhc2VcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRNaW5lciA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgYWRkcmVzczogc3RyaW5nLFxuICB0eElkOiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYElOU0VSVCBJTlRPIFxcYG1pbmVyXFxgIChhZGRyZXNzLCBmaXJzdF9ibG9jaywgbGFzdF9ibG9jaywgY291bnQpXG4gICAgIFZBTFVFUyAoPywgPywgPywgMSlcbiAgICAgICAgIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFIGxhc3RfYmxvY2sgPSA/LCBjb3VudCA9IGNvdW50ICsgMWAsXG4gICAgW2FkZHJlc3MsIHR4SWQsIHR4SWQsIHR4SWRdLFxuICApO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxpc3Qgb2YgbWluZXJzIG9uIGRhdGFiYXNlXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2Ygc3RyaW5ncyB3aXRoIG1pbmVycyBhZGRyZXNzZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE1pbmVyc0xpc3QgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4pOiBQcm9taXNlPE1pbmVyW10+ID0+IHtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShgXG4gICAgU0VMRUNUIGFkZHJlc3MsIGZpcnN0X2Jsb2NrLCBsYXN0X2Jsb2NrLCBjb3VudFxuICAgICAgRlJPTSBtaW5lcjtcbiAgYCk7XG5cbiAgY29uc3QgbWluZXJMaXN0OiBNaW5lcltdID0gW107XG5cbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIG1pbmVyTGlzdC5wdXNoKHtcbiAgICAgIGFkZHJlc3M6IHJlc3VsdC5hZGRyZXNzIGFzIHN0cmluZyxcbiAgICAgIGZpcnN0QmxvY2s6IHJlc3VsdC5maXJzdF9ibG9jayBhcyBzdHJpbmcsXG4gICAgICBsYXN0QmxvY2s6IHJlc3VsdC5sYXN0X2Jsb2NrIGFzIHN0cmluZyxcbiAgICAgIGNvdW50OiByZXN1bHQuY291bnQgYXMgbnVtYmVyLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1pbmVyTGlzdDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0b3RhbCBzdW0gb2YgYSB0b2tlbidzIHV0eG9zLCBleGNsdWRpbmcgdGhlIGJ1cm5lZCBhbmQgdm9pZGVkIG9uZXNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG5cbiAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIHN1bVxuICovXG5leHBvcnQgY29uc3QgZ2V0VG90YWxTdXBwbHkgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRva2VuSWQ6IHN0cmluZyxcbik6IFByb21pc2U8bnVtYmVyPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgIFNFTEVDVCBTVU0odmFsdWUpIGFzIHZhbHVlXG4gICAgICBGUk9NIHR4X291dHB1dFxuICAgICBXSEVSRSBzcGVudF9ieSBJUyBOVUxMXG4gICAgICAgQU5EIHRva2VuX2lkID0gP1xuICAgICAgIEFORCB2b2lkZWQgPSBGQUxTRVxuICAgICAgIEFORCBhZGRyZXNzICE9ICcke0JVUk5fQUREUkVTU30nXG4gIGAsIFt0b2tlbklkXSk7XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICBhd2FpdCBhZGRBbGVydChcbiAgICAgICdUb3RhbCBzdXBwbHkgcXVlcnkgcmV0dXJuZWQgbm8gcmVzdWx0cycsXG4gICAgICAnLScsXG4gICAgICBTZXZlcml0eS5NSU5PUixcbiAgICAgIHsgdG9rZW5JZCB9LFxuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb3RhbCBzdXBwbHkgcXVlcnkgcmV0dXJuZWQgbm8gcmVzdWx0cycpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHNbMF0udmFsdWUgYXMgbnVtYmVyO1xufTtcblxuLyoqXG4gKiBHZXQgZnJvbSBkYXRhYmFzZSB1dHhvcyB0aGF0IG11c3QgYmUgdW5sb2NrZWQgYmVjYXVzZSB0aGVpciB0aW1lbG9ja3MgZXhwaXJlZFxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBub3cgLSBDdXJyZW50IHRpbWVzdGFtcFxuXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgdGltZWxvY2tlZCB1dHhvc1xuICovXG5leHBvcnQgY29uc3QgZ2V0RXhwaXJlZFRpbWVsb2Nrc1V0eG9zID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICBub3c6IG51bWJlcixcbik6IFByb21pc2U8RGJUeE91dHB1dFtdPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgIFNFTEVDVCAqXG4gICAgICBGUk9NIHR4X291dHB1dFxuICAgICBXSEVSRSBsb2NrZWQgPSBUUlVFXG4gICAgICAgQU5EIHRpbWVsb2NrIElTIE5PVCBOVUxMXG4gICAgICAgQU5EIHRpbWVsb2NrIDwgP1xuICBgLCBbbm93XSk7XG5cbiAgY29uc3QgbG9ja2VkVXR4b3M6IERiVHhPdXRwdXRbXSA9IHJlc3VsdHMubWFwKG1hcERiUmVzdWx0VG9EYlR4T3V0cHV0KTtcblxuICByZXR1cm4gbG9ja2VkVXR4b3M7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdG90YWwgc3VtIG9mIHRyYW5zYWN0aW9ucyBmb3IgYSBnaXZlbiB0b2tlbklkXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHRva2VuSWQgLSBUaGUgdG9rZW4gaWQgdG8gZmV0Y2ggdHJhbnNhY3Rpb25zXG5cbiAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIHRvdGFsIHN1bSBvZiB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRvdGFsVHJhbnNhY3Rpb25zID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB0b2tlbklkOiBzdHJpbmcsXG4pOiBQcm9taXNlPG51bWJlcj4gPT4ge1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KGBcbiAgICBTRUxFQ1QgQ09VTlQoRElTVElOQ1QodHhfaWQpKSBBUyBjb3VudFxuICAgICAgRlJPTSBhZGRyZXNzX3R4X2hpc3RvcnlcbiAgICAgV0hFUkUgdG9rZW5faWQgPSA/XG4gICAgICAgQU5EIHZvaWRlZCA9IEZBTFNFXG4gIGAsIFt0b2tlbklkXSk7XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICBhd2FpdCBhZGRBbGVydChcbiAgICAgICdUb3RhbCB0cmFuc2FjdGlvbnMgcXVlcnkgcmV0dXJuZWQgbm8gcmVzdWx0cycsXG4gICAgICAnLScsXG4gICAgICBTZXZlcml0eS5NSU5PUixcbiAgICAgIHsgdG9rZW5JZCB9LFxuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb3RhbCB0cmFuc2FjdGlvbnMgcXVlcnkgcmV0dXJuZWQgbm8gcmVzdWx0cycpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHNbMF0uY291bnQgYXMgbnVtYmVyO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGF2YWlsYWJsZSBhdXRob3JpdHkgdXR4b3MgZm9yIGEgZ2l2ZW4gdG9rZW5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbiBpZCB0byBmZXRjaCBhdXRob3JpdGllc1xuXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgYXV0aG9yaXR5IHV0eG9zXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdmFpbGFibGVBdXRob3JpdGllcyA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgdG9rZW5JZDogc3RyaW5nLFxuKTogUHJvbWlzZTxEYlR4T3V0cHV0W10+ID0+IHtcbiAgLyogV2Ugc2hvdWxkIHNldCB0aGUgTElNSVQgdG8gYSByZWFzb25hYmxlIHZhbHVlIHRvIHByZXZlbnQgdXNlcnMgZnJvbSBhYnVzaW5nXG4gICAqIHRoaXMgQVBJIGJ5IGNyZWF0aW5nIHRob3VzYW5kcyBvZiBhdXRob3JpdHkgb3V0cHV0cyBhbmQgcXVlcnlpbmcgdGhpc1xuICAgKlxuICAgKiBDdXJyZW50bHkgdGhlIG9ubHkgdXNlIGZvciB0aGlzIHF1ZXJ5IGlzIG9uIHRoZSB3YWxsZXQtZGVza3RvcCB0byBkaXNwbGF5XG4gICAqIGlmIHRoZSB0b2tlbiBpcyBcIm1pbnRhYmxlXCIgYW5kL29yXCJtZWx0YWJsZVwiLCB3ZSBkb24ndCBkaXNwbGF5IGEgbGlzdCBvZiB0aG9zZVxuICAgKiB1dHhvcyBzbyBpdCBpcyBzYWZlIHRvIHNldCB0aGlzIGxpbWl0LlxuICAgKi9cbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShgXG4gIFNFTEVDVCAqXG4gICAgRlJPTSB0eF9vdXRwdXRcbiAgIFdIRVJFIGF1dGhvcml0aWVzID4gMFxuICAgICBBTkQgdG9rZW5faWQgPSA/XG4gICAgIEFORCB2b2lkZWQgPSBGQUxTRVxuICAgICBBTkQgbG9ja2VkID0gRkFMU0VcbiAgICAgQU5EIHNwZW50X2J5IElTIE5VTExcbiAgYCwgW3Rva2VuSWRdKTtcblxuICBjb25zdCB1dHhvcyA9IHJlc3VsdHMubWFwKG1hcERiUmVzdWx0VG9EYlR4T3V0cHV0KTtcblxuICByZXR1cm4gdXR4b3M7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBmb3IgZWFjaCB0b2tlbiBmcm9tIHRoZSBhZGRyZXNzX3R4X2hpc3RvcnkgdGFibGVcbiAqIGdpdmVuIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHhMaXN0IC0gQSBsaXN0IG9mIGFmZmVjdGVkIHRyYW5zYWN0aW9ucyB0byBnZXQgdGhlIGFkZHJlc3NlcyB0b2tlbiB0cmFuc2FjdGlvbiBjb3VudFxuXG4gKiBAcmV0dXJucyBBIE1hcCB3aXRoIGFkZHJlc3NfdG9rZW5JZCBhcyBrZXkgYW5kIHRoZSB0cmFuc2FjdGlvbiBjb3VudCBhcyB2YWx1ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFmZmVjdGVkQWRkcmVzc1R4Q291bnRGcm9tVHhMaXN0ID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB0eExpc3Q6IHN0cmluZ1tdLFxuKTogUHJvbWlzZTxTdHJpbmdNYXA8bnVtYmVyPj4gPT4ge1xuICBjb25zdCByZXN1bHRzOiBEYlNlbGVjdFJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5KGBcbiAgICBTRUxFQ1QgYWRkcmVzcywgQ09VTlQoRElTVElOQ1QodHhfaWQpKSBBUyB0eENvdW50LCB0b2tlbl9pZCBhcyB0b2tlbklkXG4gICAgICBGUk9NIGFkZHJlc3NfdHhfaGlzdG9yeVxuICAgICBXSEVSRSB0eF9pZCBJTiAoPylcbiAgICAgICBBTkQgdm9pZGVkID0gVFJVRVxuICBHUk9VUCBCWSBhZGRyZXNzLCB0b2tlbl9pZFxuICBgLCBbdHhMaXN0XSk7XG5cbiAgY29uc3QgYWRkcmVzc1RyYW5zYWN0aW9ucyA9IHJlc3VsdHMucmVkdWNlKChhY2MsIHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IGFkZHJlc3MgPSByZXN1bHQuYWRkcmVzcyBhcyBzdHJpbmc7XG4gICAgY29uc3QgdHhDb3VudCA9IHJlc3VsdC50eENvdW50IGFzIG51bWJlcjtcbiAgICBjb25zdCB0b2tlbklkID0gcmVzdWx0LnRva2VuSWQgYXMgc3RyaW5nO1xuXG4gICAgYWNjW2Ake2FkZHJlc3N9XyR7dG9rZW5JZH1gXSA9IHR4Q291bnQ7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIGFkZHJlc3NUcmFuc2FjdGlvbnMgYXMgU3RyaW5nTWFwPG51bWJlcj47XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGFmZmVjdGVkIHRyYW5zYWN0aW9ucyBmb3IgZWFjaCB0b2tlbiBmcm9tIHRoZSBhZGRyZXNzX3R4X2hpc3RvcnkgdGFibGVcbiAqIGdpdmVuIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHhMaXN0IC0gQSBsaXN0IG9mIGFmZmVjdGVkIHRyYW5zYWN0aW9ucyB0byBnZXQgdGhlIHRva2VuIHR4IGNvdW50XG5cbiAqIEByZXR1cm5zIEEgTWFwIHdpdGggdG9rZW5JZCBhcyBrZXkgYW5kIHRoZSB0cmFuc2FjdGlvbiBjb3VudCBhcyB2YWx1ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFmZmVjdGVkVG9rZW5UeENvdW50RnJvbVR4TGlzdCA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgdHhMaXN0OiBzdHJpbmdbXSxcbik6IFByb21pc2U8U3RyaW5nTWFwPG51bWJlcj4+ID0+IHtcbiAgY29uc3QgcmVzdWx0czogRGJTZWxlY3RSZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShgXG4gICAgU0VMRUNUIHRva2VuX2lkIEFTIHRva2VuSWQsIENPVU5UKERJU1RJTkNUKHR4X2lkKSkgQVMgdHhDb3VudFxuICAgICAgRlJPTSBhZGRyZXNzX3R4X2hpc3RvcnlcbiAgICAgV0hFUkUgdHhfaWQgSU4gKD8pXG4gICAgICAgQU5EIHZvaWRlZCA9IFRSVUVcbiAgR1JPVVAgQlkgdG9rZW5faWRcbiAgYCwgW3R4TGlzdF0pO1xuXG4gIGNvbnN0IHRva2VuVHJhbnNhY3Rpb25zID0gcmVzdWx0cy5yZWR1Y2UoKGFjYywgcmVzdWx0KSA9PiB7XG4gICAgY29uc3QgdG9rZW5JZCA9IHJlc3VsdC50b2tlbklkIGFzIHN0cmluZztcbiAgICBjb25zdCB0eENvdW50ID0gcmVzdWx0LnR4Q291bnQgYXMgbnVtYmVyO1xuXG4gICAgYWNjW3Rva2VuSWRdID0gdHhDb3VudDtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gdG9rZW5UcmFuc2FjdGlvbnMgYXMgU3RyaW5nTWFwPG51bWJlcj47XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYWZmZWN0ZWQgdG90YWxfcmVjZWl2ZWQgZm9yIGVhY2ggYWRkcmVzcy90b2tlbiBwYWlyIGdpdmVuIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnNcbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gdHhMaXN0IC0gQSBsaXN0IG9mIGFmZmVjdGVkIHRyYW5zYWN0aW9uc1xuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTdHJpbmdNYXA8bnVtYmVyPj59IEEgTWFwIHdpdGggYWRkcmVzc190b2tlbklkIGFzIGtleSBhbmQgdGhlIGFmZmVjdGVkIHRvdGFsX3JlY2VpdmVkIGFzIHZhbHVlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0QWZmZWN0ZWRBZGRyZXNzVG90YWxSZWNlaXZlZEZyb21UeExpc3QgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4TGlzdDogc3RyaW5nW10sXG4pOiBQcm9taXNlPFN0cmluZ01hcDxudW1iZXI+PiA9PiB7XG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgIFNFTEVDVCBhZGRyZXNzLCB0b2tlbl9pZCBhcyB0b2tlbklkLCBTVU0odmFsdWUpIGFzIHRvdGFsXG4gICAgICBGUk9NIHR4X291dHB1dFxuICAgICBXSEVSRSB0eF9pZCBJTiAoPylcbiAgICAgICBBTkQgdm9pZGVkID0gVFJVRVxuICBHUk9VUCBCWSBhZGRyZXNzLCB0b2tlbl9pZFxuICBgLCBbdHhMaXN0XSk7XG5cbiAgY29uc3QgYWRkcmVzc1RvdGFsUmVjZWl2ZWRNYXAgPSByZXN1bHRzLnJlZHVjZSgoYWNjLCByZXN1bHQpID0+IHtcbiAgICBjb25zdCBhZGRyZXNzID0gcmVzdWx0LmFkZHJlc3MgYXMgc3RyaW5nO1xuICAgIGNvbnN0IHRvdGFsID0gcmVzdWx0LnRvdGFsIGFzIG51bWJlcjtcbiAgICBjb25zdCB0b2tlbklkID0gcmVzdWx0LnRva2VuSWQgYXMgc3RyaW5nO1xuXG4gICAgYWNjW2Ake2FkZHJlc3N9XyR7dG9rZW5JZH1gXSA9IHRvdGFsO1xuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIHJldHVybiBhZGRyZXNzVG90YWxSZWNlaXZlZE1hcCBhcyBTdHJpbmdNYXA8bnVtYmVyPjtcbn07XG5cbi8qKlxuICogSW5jcmVtZW50IGEgbGlzdCBvZiB0b2tlbnMgdHJhbnNhY3Rpb25zIGNvdW50XG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHRva2VuTGlzdCAtIFRoZSBsaXN0IG9mIHRva2VucyB0byBpbmNyZW1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGluY3JlbWVudFRva2Vuc1R4Q291bnQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHRva2VuTGlzdDogc3RyaW5nW10sXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgbXlzcWwucXVlcnkoYFxuICAgIFVQREFURSBcXGB0b2tlblxcYFxuICAgICAgIFNFVCBcXGB0cmFuc2FjdGlvbnNcXGAgPSBcXGB0cmFuc2FjdGlvbnNcXGAgKyAxXG4gICAgIFdIRVJFIFxcYGlkXFxgIElOICg/KVxuICBgLCBbdG9rZW5MaXN0XSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIGEgZGV2aWNlIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gd2FsbGV0LlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBkZXZpY2VJZCAtIFRoZSBkZXZpY2UgdG8gdmVyaWZ5IGV4aXN0ZW5jZVxuICogQHBhcmFtIHdhbGxldElkIC0gVGhlIHdhbGxldCBsaW5rZWQgdG8gZGV2aWNlXG4gKi9cbmV4cG9ydCBjb25zdCBleGlzdHNQdXNoRGV2aWNlID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICBkZXZpY2VJZDogc3RyaW5nLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuKSA6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICBjb25zdCBbeyBjb3VudCB9XSA9IGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBcbiAgICBTRUxFQ1QgQ09VTlQoMSkgYXMgXFxgY291bnRcXGBcbiAgICAgIEZST00gXFxgcHVzaF9kZXZpY2VzXFxgIHBkXG4gICAgIFdIRVJFIGRldmljZV9pZCA9ID9cbiAgICAgICBBTkQgd2FsbGV0X2lkID0gP2AsXG4gICAgW2RldmljZUlkLCB3YWxsZXRJZF0sXG4gICkgYXMgdW5rbm93biBhcyBBcnJheTx7Y291bnR9PjtcblxuICByZXR1cm4gY291bnQgPiAwO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGRldmljZSB0byBhIHdhbGxldCBmb3IgcHVzaCBub3RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGlucHV0IC0gSW5wdXQgb2YgcHVzaCBkZXZpY2UgcmVnaXN0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyUHVzaERldmljZSA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbiAgaW5wdXQ6IHtcbiAgICBkZXZpY2VJZDogc3RyaW5nLFxuICAgIHdhbGxldElkOiBzdHJpbmcsXG4gICAgcHVzaFByb3ZpZGVyOiBzdHJpbmcsXG4gICAgZW5hYmxlUHVzaDogYm9vbGVhbixcbiAgICBlbmFibGVTaG93QW1vdW50czogYm9vbGVhbixcbiAgfSxcbikgOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFxuICAgIElOU0VSVFxuICAgICAgSU5UTyBcXGBwdXNoX2RldmljZXNcXGAgKFxuICAgICAgICAgICBkZXZpY2VfaWRcbiAgICAgICAgICwgd2FsbGV0X2lkXG4gICAgICAgICAsIHB1c2hfcHJvdmlkZXJcbiAgICAgICAgICwgZW5hYmxlX3B1c2hcbiAgICAgICAgICwgZW5hYmxlX3Nob3dfYW1vdW50cylcbiAgICBWQUxVRVMgKD8sID8sID8sID8sID8pXG4gICAgICAgIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFXG4gICAgICAgICAgIHVwZGF0ZWRfYXQgPSBDVVJSRU5UX1RJTUVTVEFNUGAsXG4gICAgW2lucHV0LmRldmljZUlkLCBpbnB1dC53YWxsZXRJZCwgaW5wdXQucHVzaFByb3ZpZGVyLCBpbnB1dC5lbmFibGVQdXNoLCBpbnB1dC5lbmFibGVTaG93QW1vdW50c10sXG4gICk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbnkgcmVjb3JkIG9mIHB1c2ggbm90aWZpY2F0aW9uIGRldmljZSBnaXZlbiBhIGRldmljZSBJRC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gZGV2aWNlSWQgLSBUaGUgZGV2aWNlIElEXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVBbGxQdXNoRGV2aWNlc0J5RGV2aWNlSWQgPSBhc3luYyAobXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgZGV2aWNlSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgXG4gICAgIERFTEVURVxuICAgICAgIEZST00gXFxgcHVzaF9kZXZpY2VzXFxgXG4gICAgICBXSEVSRVxuICBkZXZpY2VfaWQgPSA/XG4gICAgYCxcbiAgICBbZGV2aWNlSWRdLFxuICApO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZXhpc3RpbmcgcHVzaCBkZXZpY2UgZ2l2ZW4gYSB3YWxsZXQuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGlucHV0IC0gSW5wdXQgb2YgcHVzaCBkZXZpY2UgcmVnaXN0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVB1c2hEZXZpY2UgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIGlucHV0OiB7XG4gICAgZGV2aWNlSWQ6IHN0cmluZyxcbiAgICB3YWxsZXRJZDogc3RyaW5nLFxuICAgIGVuYWJsZVB1c2g6IGJvb2xlYW4sXG4gICAgZW5hYmxlU2hvd0Ftb3VudHM6IGJvb2xlYW4sXG4gIH0sXG4pIDogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgIGBcbiAgICBVUERBVEUgXFxgcHVzaF9kZXZpY2VzXFxgXG4gICAgICAgU0VUIGVuYWJsZV9wdXNoID0gP1xuICAgICAgICAgLCBlbmFibGVfc2hvd19hbW91bnRzID0gP1xuICAgICBXSEVSRSBkZXZpY2VfaWQgPSA/XG4gICAgICAgQU5EIHdhbGxldF9pZCA9ID9gLFxuICAgIFtpbnB1dC5lbmFibGVQdXNoLCBpbnB1dC5lbmFibGVTaG93QW1vdW50cywgaW5wdXQuZGV2aWNlSWQsIGlucHV0LndhbGxldElkXSxcbiAgKTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBwdXNoIGRldmljZSBmb3IgYSBnaXZlbiB3YWxsZXQuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIGRldmljZUlkIC0gVGhlIGRldmljZSB0byB1bnJlZ2lzdGVyXG4gKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IGxpbmtlZCB0byBkZXZpY2VcbiAqL1xuZXhwb3J0IGNvbnN0IHVucmVnaXN0ZXJQdXNoRGV2aWNlID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICBkZXZpY2VJZDogc3RyaW5nLFxuICB3YWxsZXRJZD86IHN0cmluZyxcbikgOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKHdhbGxldElkKSB7XG4gICAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgICBgXG4gICAgICBERUxFVEVcbiAgICAgICAgRlJPTSBcXGBwdXNoX2RldmljZXNcXGBcbiAgICAgICBXSEVSRSBkZXZpY2VfaWQgPSA/XG4gICAgICAgICBBTkQgd2FsbGV0X2lkID0gP2AsXG4gICAgICBbZGV2aWNlSWQsIHdhbGxldElkXSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IG15c3FsLnF1ZXJ5KFxuICAgICAgYFxuICAgICAgREVMRVRFXG4gICAgICAgIEZST00gXFxgcHVzaF9kZXZpY2VzXFxgXG4gICAgICAgV0hFUkUgZGV2aWNlX2lkID0gP2AsXG4gICAgICBbZGV2aWNlSWRdLFxuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgdHJhbnNhY3Rpb24gYnkgaXRzIElELlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB0eElkIC0gQSB0cmFuc2FjdGlvbiBJRFxuICogQHBhcmFtIHdhbGxldElkIC0gVGhlIHdhbGxldCByZWxhdGVkIHRvIHRoZSB0cmFuc2FjdGlvblxuICogQHJldHVybnMgQSBsaXN0IG9mIHRva2VucyBmb3IgYSB0cmFuc2FjdGlvbiBpZiBmb3VuZCwgcmV0dXJuIGFuIGVtcHR5IGxpc3Qgb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUcmFuc2FjdGlvbkJ5SWQgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4SWQ6IHN0cmluZyxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbik6IFByb21pc2U8VHhCeUlkVG9rZW5bXT4gPT4ge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBteXNxbC5xdWVyeShgXG4gICAgICAgU0VMRUNUXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnR4X2lkIEFTIHR4X2lkXG4gICAgICAgICAgICAsIHRyYW5zYWN0aW9uLnRpbWVzdGFtcCBBUyB0aW1lc3RhbXBcbiAgICAgICAgICAgICwgdHJhbnNhY3Rpb24udmVyc2lvbiBBUyB2ZXJzaW9uXG4gICAgICAgICAgICAsIHRyYW5zYWN0aW9uLnZvaWRlZCBBUyB2b2lkZWRcbiAgICAgICAgICAgICwgdHJhbnNhY3Rpb24uaGVpZ2h0IEFTIGhlaWdodFxuICAgICAgICAgICAgLCB0cmFuc2FjdGlvbi53ZWlnaHQgQVMgd2VpZ2h0XG4gICAgICAgICAgICAsIHdhbGxldF90eF9oaXN0b3J5LmJhbGFuY2UgQVMgYmFsYW5jZVxuICAgICAgICAgICAgLCB3YWxsZXRfdHhfaGlzdG9yeS50b2tlbl9pZCBBUyB0b2tlbl9pZFxuICAgICAgICAgICAgLCB0b2tlbi5uYW1lIEFTIG5hbWVcbiAgICAgICAgICAgICwgdG9rZW4uc3ltYm9sIEFTIHN5bWJvbFxuICAgICAgICAgRlJPTSB3YWxsZXRfdHhfaGlzdG9yeVxuICAgSU5ORVIgSk9JTiB0cmFuc2FjdGlvbiBPTiB0cmFuc2FjdGlvbi50eF9pZCA9IHdhbGxldF90eF9oaXN0b3J5LnR4X2lkXG4gICBJTk5FUiBKT0lOIHRva2VuIE9OIHdhbGxldF90eF9oaXN0b3J5LnRva2VuX2lkID0gdG9rZW4uaWRcbiAgICAgICAgV0hFUkUgdHJhbnNhY3Rpb24udHhfaWQgPSA/XG4gICAgICAgICAgQU5EIHRyYW5zYWN0aW9uLnZvaWRlZCA9IEZBTFNFXG4gICAgICAgICAgQU5EIHdhbGxldF90eF9oaXN0b3J5LndhbGxldF9pZCA9ID9gLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIFt0eElkLCB3YWxsZXRJZF0pIGFzIEFycmF5PHt0eF9pZCwgdGltZXN0YW1wLCB2ZXJzaW9uLCB2b2lkZWQsIHdlaWdodCwgYmFsYW5jZSwgdG9rZW5faWQsIG5hbWUsIHN5bWJvbCB9PjtcblxuICBjb25zdCB0eFRva2VucyA9IFtdO1xuICByZXN1bHQuZm9yRWFjaCgoZWFjaFR4VG9rZW4pID0+IHtcbiAgICBjb25zdCB0eFRva2VuID0ge1xuICAgICAgdHhJZDogZWFjaFR4VG9rZW4udHhfaWQsXG4gICAgICB0aW1lc3RhbXA6IGVhY2hUeFRva2VuLnRpbWVzdGFtcCxcbiAgICAgIHZlcnNpb246IGVhY2hUeFRva2VuLnZlcnNpb24sXG4gICAgICB2b2lkZWQ6ICEhZWFjaFR4VG9rZW4udm9pZGVkLFxuICAgICAgd2VpZ2h0OiBlYWNoVHhUb2tlbi53ZWlnaHQsXG4gICAgICBiYWxhbmNlOiBlYWNoVHhUb2tlbi5iYWxhbmNlLFxuICAgICAgdG9rZW5JZDogZWFjaFR4VG9rZW4udG9rZW5faWQsXG4gICAgICB0b2tlbk5hbWU6IGVhY2hUeFRva2VuLm5hbWUsXG4gICAgICB0b2tlblN5bWJvbDogZWFjaFR4VG9rZW4uc3ltYm9sLFxuICAgIH0gYXMgVHhCeUlkVG9rZW47XG4gICAgdHhUb2tlbnMucHVzaCh0eFRva2VuKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHR4VG9rZW5zO1xufTtcblxuLyoqXG4qIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIGEgd2FsbGV0IGJ5IGl0cyBJRC5cbipcbiogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IGxpbmtlZCB0byBkZXZpY2VcbiovXG5leHBvcnQgY29uc3QgZXhpc3RzV2FsbGV0ID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuKSA6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICBjb25zdCBbeyBjb3VudCB9XSA9IChhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgXG4gICAgU0VMRUNUIENPVU5UKDEpIGFzIFxcYGNvdW50XFxgXG4gICAgICBGUk9NIFxcYHdhbGxldFxcYCBwZFxuICAgICBXSEVSRSBpZCA9ID9gLFxuICAgIFt3YWxsZXRJZF0sXG4gICkpIGFzIHVua25vd24gYXMgQXJyYXk8eyBjb3VudCB9PjtcblxuICByZXR1cm4gY291bnQgPiAwO1xufTtcblxuLyoqXG4gKiBHZXQgcmVnaXN0ZXJlZCBwdXNoIGRldmljZSBieSBkZXZpY2VJZC5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gZGV2aWNlSWQgLSBUaGUgZGV2aWNlIHRvIHZlcmlmeSBleGlzdGVuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFB1c2hEZXZpY2UgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIGRldmljZUlkOiBzdHJpbmcsXG4pIDogUHJvbWlzZTxQdXNoRGV2aWNlfG51bGw+ID0+IHtcbiAgY29uc3QgW3B1c2hEZXZpY2VdID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFxuICAgIFNFTEVDVCAqXG4gICAgICBGUk9NIFxcYHB1c2hfZGV2aWNlc1xcYFxuICAgICBXSEVSRSBkZXZpY2VfaWQgPSA/YCxcbiAgICBbZGV2aWNlSWRdLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICkgYXMgQXJyYXk8e3dhbGxldF9pZCwgZGV2aWNlX2lkLCBwdXNoX3Byb3ZpZGVyLCBlbmFibGVfcHVzaCwgZW5hYmxlX3Nob3dfYW1vdW50c30+O1xuXG4gIGlmICghcHVzaERldmljZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3YWxsZXRJZDogcHVzaERldmljZS53YWxsZXRfaWQsXG4gICAgZGV2aWNlSWQ6IHB1c2hEZXZpY2UuZGV2aWNlX2lkLFxuICAgIHB1c2hQcm92aWRlcjogcHVzaERldmljZS5wdXNoX3Byb3ZpZGVyLFxuICAgIGVuYWJsZVB1c2g6ICEhcHVzaERldmljZS5lbmFibGVfcHVzaCxcbiAgICBlbmFibGVTaG93QW1vdW50czogISFwdXNoRGV2aWNlLmVuYWJsZV9zaG93X2Ftb3VudHMsXG4gIH0gYXMgUHVzaERldmljZTtcbn07XG5cbi8qKlxuICogR2V0IGEgcHVzaCBkZXZpY2Ugc2V0dGluZ3MgbGlzdCBnaXZlbiBhIGxpc3Qgb2Ygd2FsbGV0IGlkcy5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gd2FsbGV0SWRMaXN0IC0gQSBsaXN0IG9mIHdhbGxldCBpZHNcbiAqIEByZXR1cm5zIC0gYSBsaXN0IG9mIHB1c2ggZGV2aWNlIHNldHRpbmdzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQdXNoRGV2aWNlU2V0dGluZ3NMaXN0ID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB3YWxsZXRJZExpc3Q6IHN0cmluZ1tdLFxuKSA6IFByb21pc2U8UHVzaERldmljZVNldHRpbmdzW10+ID0+IHtcbiAgY29uc3QgcHVzaERldmljZVNldHRpbmdzUmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFxuICAgIFNFTEVDVCB3YWxsZXRfaWRcbiAgICAgICAgICwgZGV2aWNlX2lkXG4gICAgICAgICAsIGVuYWJsZV9wdXNoXG4gICAgICAgICAsIGVuYWJsZV9zaG93X2Ftb3VudHNcbiAgICAgIEZST00gXFxgcHVzaF9kZXZpY2VzXFxgXG4gICAgIFdIRVJFIHdhbGxldF9pZCBpbiAoPylgLFxuICAgIFt3YWxsZXRJZExpc3RdLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICkgYXMgQXJyYXk8e3dhbGxldF9pZCwgZGV2aWNlX2lkLCBlbmFibGVfcHVzaCwgZW5hYmxlX3Nob3dfYW1vdW50c30+O1xuXG4gIGNvbnN0IHB1c2hEZXZpY2VTZXR0aWduc0xpc3QgPSBwdXNoRGV2aWNlU2V0dGluZ3NSZXN1bHQubWFwKChlYWNoKSA9PiAoe1xuICAgIHdhbGxldElkOiBlYWNoLndhbGxldF9pZCxcbiAgICBkZXZpY2VJZDogZWFjaC5kZXZpY2VfaWQsXG4gICAgZW5hYmxlUHVzaDogISFlYWNoLmVuYWJsZV9wdXNoLFxuICAgIGVuYWJsZVNob3dBbW91bnRzOiAhIWVhY2guZW5hYmxlX3Nob3dfYW1vdW50cyxcbiAgfSBhcyBQdXNoRGV2aWNlU2V0dGluZ3MpKTtcblxuICByZXR1cm4gcHVzaERldmljZVNldHRpZ25zTGlzdDtcbn07XG5cbi8qKlxuICogQ291bnQgdGhlIHF1YW50aXR5IG9mIHN0YWxlIHB1c2ggZGV2aWNlcyBmcm9tIG5vdy5cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKiBAcmV0dXJucyAtIHRvdGFsIG9mIHN0YWxlIGRldmljZSBmcm9tIG5vd1xuICovXG5leHBvcnQgY29uc3QgY291bnRTdGFsZVB1c2hEZXZpY2VzID0gYXN5bmMgKG15c3FsKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgY29uc3QgW3sgY291bnQgfV0gPSBhd2FpdCBteXNxbC5xdWVyeShcbiAgICBgXG4gICAgU0VMRUNUIENPVU5UKGRldmljZV9pZCkgYXMgY291bnRcbiAgICAgIEZST00gXFxgcHVzaF9kZXZpY2VzXFxgXG4gICAgIFdIRVJFIFVOSVhfVElNRVNUQU1QKHVwZGF0ZWRfYXQpIDwgVU5JWF9USU1FU1RBTVAoZGF0ZV9zdWIobm93KCksIGludGVydmFsIDEgbW9udGgpKWAsXG4gICkgYXMgQXJyYXk8eyBjb3VudCB9PjtcbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLyoqXG4gKiBEZWxldGUgc3RhbGUgcHVzaCBkZXZpY2VzIGZyb20gbm93LlxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZVN0YWxlUHVzaERldmljZXMgPSBhc3luYyAobXlzcWwpID0+IHtcbiAgYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgYFxuICAgIERFTEVURVxuICAgICAgRlJPTSBcXGBwdXNoX2RldmljZXNcXGBcbiAgICAgV0hFUkUgVU5JWF9USU1FU1RBTVAodXBkYXRlZF9hdCkgPCBVTklYX1RJTUVTVEFNUChkYXRlX3N1Yihub3coKSwgaW50ZXJ2YWwgMSBtb250aCkpYCxcbiAgKTtcbn07XG5cbi8qKlxuICogR2V0IHRva2VuIHN5bWJvbCBtYXAsIGNvcnJlbGF0aW5nIHRva2VuIGlkIHRvIGl0cyBzeW1ib2wuXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHRva2VuSWRMaXN0IC0gQSBsaXN0IG9mIHRva2VuIGlkXG4gKiBAcmV0dXJucyBUaGUgdG9rZW4gaW5mb3JtYXRpb24gKG9yIG51bGwgaWYgaWQgaXMgbm90IGZvdW5kKVxuICovXG5leHBvcnQgY29uc3QgZ2V0VG9rZW5TeW1ib2xzID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB0b2tlbklkTGlzdDogc3RyaW5nW10sXG4pOiBQcm9taXNlPFN0cmluZ01hcDxzdHJpbmc+PiA9PiB7XG4gIGlmICh0b2tlbklkTGlzdC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0ID0gYXdhaXQgbXlzcWwucXVlcnkoXG4gICAgJ1NFTEVDVCBgaWRgLCBgc3ltYm9sYCBGUk9NIGB0b2tlbmAgV0hFUkUgYGlkYCBJTiAoPyknLFxuICAgIFt0b2tlbklkTGlzdF0sXG4gICk7XG5cbiAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChwcmV2OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCB0b2tlbjogeyBpZDogc3RyaW5nLCBzeW1ib2w6IHN0cmluZ30pID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBwcmV2W3Rva2VuLmlkXSA9IHRva2VuLnN5bWJvbDtcbiAgICByZXR1cm4gcHJldjtcbiAgfSwge30pIGFzIHVua25vd24gYXMgU3RyaW5nTWFwPHN0cmluZz47XG59O1xuXG4vKipcbiAqIEZldGNoZXMgYWxsIHR4UHJvcG9zYWxzIHRoYXQgYXJlIGVpdGhlciBpbiB0aGUgT1BFTiwgU0VORF9FUlJPUiBvciBDQU5DRUxMRUQgc3RhdHVzXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgdHhQcm9wb3NhbHMgYmVmb3JlIGEgZ2l2ZW4gZGF0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0VW5zZW50VHhQcm9wb3NhbHMgPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4gIHR4UHJvcG9zYWxzQmVmb3JlOiBudW1iZXIsXG4pOiBQcm9taXNlPHN0cmluZ1tdPiA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15c3FsLnF1ZXJ5PHsgaWQ6IHN0cmluZyB9W10+KFxuICAgIGBcbiAgICBTRUxFQ1QgaWRcbiAgICAgIEZST00gXFxgdHhfcHJvcG9zYWxcXGBcbiAgICAgV0hFUkUgY3JlYXRlZF9hdCA8ID9cbiAgICAgICBBTkQgc3RhdHVzIElOICg/KWAsXG4gICAgW3R4UHJvcG9zYWxzQmVmb3JlLCBbXG4gICAgICBUeFByb3Bvc2FsU3RhdHVzLk9QRU4sXG4gICAgICBUeFByb3Bvc2FsU3RhdHVzLlNFTkRfRVJST1IsXG4gICAgICBUeFByb3Bvc2FsU3RhdHVzLkNBTkNFTExFRCxcbiAgICBdXSxcbiAgKTtcblxuICByZXR1cm4gcmVzdWx0Lm1hcCgocm93KSA9PiByb3cuaWQpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc3BlY2lmaWMgYWRkcmVzcyBmcm9tIGFuIGluZGV4IGFuZCBhIHdhbGxldElkXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICogQHBhcmFtIHdhbGxldElkIC0gVGhlIHdhbGxldCBpZCB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0gaW5kZXggLSBUaGUgYWRkcmVzcyBpbmRleCB0byBzZWFyY2ggZm9yXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGFkZHJlc3MsIGl0cyBpbmRleCBhbmQgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFkZHJlc3NBdEluZGV4ID0gYXN5bmMgKFxuICBteXNxbDogU2VydmVybGVzc015c3FsLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICBpbmRleDogbnVtYmVyLFxuKTogUHJvbWlzZTxBZGRyZXNzSW5mbyB8IG51bGw+ID0+IHtcbiAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgbXlzcWwucXVlcnk8QWRkcmVzc0luZm9bXT4oXG4gICAgYFxuICAgIFNFTEVDVCBcXGBhZGRyZXNzXFxgLCBcXGBpbmRleFxcYCwgXFxgdHJhbnNhY3Rpb25zXFxgXG4gICAgICBGUk9NIFxcYGFkZHJlc3NcXGAgcGRcbiAgICAgV0hFUkUgXFxgaW5kZXhcXGAgPSA/XG4gICAgICAgQU5EIFxcYHdhbGxldF9pZFxcYCA9ID9cbiAgICAgTElNSVQgMWAsXG4gICAgW3dhbGxldElkLCBpbmRleF0sXG4gICk7XG5cbiAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZGRyZXNzOiBhZGRyZXNzZXNbMF0uYWRkcmVzcyBhcyBzdHJpbmcsXG4gICAgaW5kZXg6IGFkZHJlc3Nlc1swXS5pbmRleCBhcyBudW1iZXIsXG4gICAgdHJhbnNhY3Rpb25zOiBhZGRyZXNzZXNbMF0udHJhbnNhY3Rpb25zIGFzIG51bWJlcixcbiAgfSBhcyBBZGRyZXNzSW5mbztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/db/index.ts\n");

/***/ }),

/***/ "./src/db/utils.ts":
/*!*************************!*\
  !*** ./src/db/utils.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringMapIterator = exports.WalletBalanceMapConverter = exports.sortBalanceValueByAbsTotal = exports.FromTokenBalanceMapToBalanceValueList = exports.getTxFromDBResult = exports.getTxsFromDBResult = exports.getWalletFromDbEntry = exports.transactionDecorator = exports.rollbackTransaction = exports.commitTransaction = exports.beginTransaction = void 0;\nconst utils_1 = __webpack_require__(/*! @src/utils */ \"./src/utils.ts\");\nconst beginTransaction = async (mysql) => {\n    await mysql.query('START TRANSACTION');\n};\nexports.beginTransaction = beginTransaction;\nconst commitTransaction = async (mysql) => {\n    await mysql.query('COMMIT');\n};\nexports.commitTransaction = commitTransaction;\nconst rollbackTransaction = async (mysql) => {\n    await mysql.query('ROLLBACK');\n};\nexports.rollbackTransaction = rollbackTransaction;\nasync function transactionDecorator(_mysql, wrapped) {\n    return async function wrapper(...args) {\n        try {\n            await (0, exports.beginTransaction)(_mysql);\n            await wrapped.apply(this, args);\n            await (0, exports.commitTransaction)(_mysql);\n        }\n        catch (e) {\n            await (0, exports.rollbackTransaction)(_mysql);\n            throw e;\n        }\n    };\n}\nexports.transactionDecorator = transactionDecorator;\nconst getWalletFromDbEntry = (entry) => ({\n    walletId: (0, utils_1.getWalletId)(entry.xpubkey),\n    xpubkey: entry.xpubkey,\n    authXpubkey: entry.auth_xpubkey,\n    status: entry.status,\n    retryCount: entry.retry_count,\n    maxGap: entry.max_gap,\n    createdAt: entry.created_at,\n    readyAt: entry.ready_at,\n});\nexports.getWalletFromDbEntry = getWalletFromDbEntry;\nconst getTxsFromDBResult = (results) => {\n    const transactions = [];\n    for (const result of results) {\n        const tx = _mapTxRecord2Tx(result);\n        transactions.push(tx);\n    }\n    return transactions;\n};\nexports.getTxsFromDBResult = getTxsFromDBResult;\nconst getTxFromDBResult = (result) => {\n    const { 0: row } = result;\n    return _mapTxRecord2Tx(row);\n};\nexports.getTxFromDBResult = getTxFromDBResult;\nconst _mapTxRecord2Tx = (record) => ({\n    txId: record.tx_id,\n    timestamp: record.timestamp,\n    version: record.version,\n    voided: record.voided === 1,\n    height: record.height,\n    weight: record.weight,\n});\nclass FromTokenBalanceMapToBalanceValueList {\n    static convert(tokenBalanceMap, tokenSymbolsMap) {\n        const entryBalances = Object.entries(tokenBalanceMap.map);\n        const balances = entryBalances.map(([tokenId, balance]) => ({\n            tokenId,\n            tokenSymbol: tokenSymbolsMap[tokenId],\n            lockedAmount: balance.lockedAmount,\n            lockedAuthorities: balance.lockedAuthorities.toJSON(),\n            lockExpires: balance.lockExpires,\n            unlockedAmount: balance.unlockedAmount,\n            unlockedAuthorities: balance.unlockedAuthorities.toJSON(),\n            totalAmountSent: balance.totalAmountSent,\n            total: balance.total(),\n        }));\n        return balances;\n    }\n}\nexports.FromTokenBalanceMapToBalanceValueList = FromTokenBalanceMapToBalanceValueList;\nconst sortBalanceValueByAbsTotal = (balanceA, balanceB) => {\n    if (Math.abs(balanceA.total) - Math.abs(balanceB.total) >= 0)\n        return -1;\n    return 0;\n};\nexports.sortBalanceValueByAbsTotal = sortBalanceValueByAbsTotal;\nclass WalletBalanceMapConverter {\n    static toValue(walletBalanceMap, tokenSymbolsMap) {\n        const walletBalanceEntries = Object.entries(walletBalanceMap);\n        const walletBalanceValueMap = {};\n        for (const [walletId, walletBalance] of walletBalanceEntries) {\n            const sortedTokenBalanceList = FromTokenBalanceMapToBalanceValueList\n                .convert(walletBalance.walletBalanceForTx, tokenSymbolsMap)\n                .sort(exports.sortBalanceValueByAbsTotal);\n            walletBalanceValueMap[walletId] = {\n                addresses: walletBalance.addresses,\n                txId: walletBalance.txId,\n                walletId: walletBalance.walletId,\n                walletBalanceForTx: sortedTokenBalanceList,\n            };\n        }\n        return walletBalanceValueMap;\n    }\n}\nexports.WalletBalanceMapConverter = WalletBalanceMapConverter;\nconst stringMapIterator = (stringMap) => (Object.entries(stringMap));\nexports.stringMapIterator = stringMapIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGIvdXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7O0FBU0E7QUFrQkE7QUFHQTtBQUNBO0FBSkE7QUFXQTtBQUdBO0FBQ0E7QUFKQTtBQVdBO0FBR0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBaUJBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFWQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBNUJBO0FBOEJBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93YWxsZXQtc2VydmljZS8uL3NyYy9kYi91dGlscy50cz82ZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBIYXRob3IgTGFicyBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbmltcG9ydCB7IFNlcnZlcmxlc3NNeXNxbCB9IGZyb20gJ3NlcnZlcmxlc3MtbXlzcWwnO1xuaW1wb3J0IHsgZ2V0V2FsbGV0SWQgfSBmcm9tICdAc3JjL3V0aWxzJztcbmltcG9ydCB7XG4gIFdhbGxldFN0YXR1cyxcbiAgV2FsbGV0LFxuICBUeCxcbiAgRGJTZWxlY3RSZXN1bHQsXG4gIFRva2VuQmFsYW5jZU1hcCxcbiAgVG9rZW5CYWxhbmNlVmFsdWUsXG4gIFdhbGxldEJhbGFuY2VWYWx1ZSxcbiAgU3RyaW5nTWFwLFxuICBXYWxsZXRCYWxhbmNlLFxufSBmcm9tICdAc3JjL3R5cGVzJztcblxuLyoqXG4gKiBCZWdpbnMgYSB0cmFuc2FjdGlvbiBvbiB0aGUgY3VycmVudCBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIG15c3FsIC0gRGF0YWJhc2UgY29ubmVjdGlvblxuICovXG5leHBvcnQgY29uc3QgYmVnaW5UcmFuc2FjdGlvbiA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBteXNxbC5xdWVyeSgnU1RBUlQgVFJBTlNBQ1RJT04nKTtcbn07XG5cbi8qKlxuICogQ29tbWl0cyB0aGUgdHJhbnNhY3Rpb24gb3BlbmVkIG9uIHRoZSBjdXJyZW50IGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0gbXlzcWwgLSBEYXRhYmFzZSBjb25uZWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjb21taXRUcmFuc2FjdGlvbiA9IGFzeW5jIChcbiAgbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBteXNxbC5xdWVyeSgnQ09NTUlUJyk7XG59O1xuXG4vKipcbiAqIFJvbGxiYWNrIHRoZSB0cmFuc2FjdGlvbiBvcGVuZWQgb24gdGhlIGN1cnJlbnQgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSBteXNxbCAtIERhdGFiYXNlIGNvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJvbGxiYWNrVHJhbnNhY3Rpb24gPSBhc3luYyAoXG4gIG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgbXlzcWwucXVlcnkoJ1JPTExCQUNLJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXMgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFuc2FjdGlvbkRlY29yYXRvcihfbXlzcWw6IFNlcnZlcmxlc3NNeXNxbCwgd3JhcHBlZDogRnVuY3Rpb24pOiBQcm9taXNlPEZ1bmN0aW9uPiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYmVnaW5UcmFuc2FjdGlvbihfbXlzcWwpO1xuICAgICAgYXdhaXQgd3JhcHBlZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIGF3YWl0IGNvbW1pdFRyYW5zYWN0aW9uKF9teXNxbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgcm9sbGJhY2tUcmFuc2FjdGlvbihfbXlzcWwpO1xuXG4gICAgICAvLyBwcm9wYWdhdGUgdGhlIGVycm9yXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgV2FsbGV0IG9iamVjdCBmcm9tIGEgZGIgcmVzdWx0IHJvd1xuICpcbiAqIEBwYXJhbSByZXN1bHQgLSBUaGUgcmVzdWx0IHJvdyB0byBtYXAgdG8gYSBXYWxsZXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRXYWxsZXRGcm9tRGJFbnRyeSA9IChlbnRyeTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBXYWxsZXQgPT4gKHtcbiAgd2FsbGV0SWQ6IGdldFdhbGxldElkKGVudHJ5LnhwdWJrZXkgYXMgc3RyaW5nKSxcbiAgeHB1YmtleTogZW50cnkueHB1YmtleSBhcyBzdHJpbmcsXG4gIGF1dGhYcHVia2V5OiBlbnRyeS5hdXRoX3hwdWJrZXkgYXMgc3RyaW5nLFxuICBzdGF0dXM6IGVudHJ5LnN0YXR1cyBhcyBXYWxsZXRTdGF0dXMsXG4gIHJldHJ5Q291bnQ6IGVudHJ5LnJldHJ5X2NvdW50IGFzIG51bWJlcixcbiAgbWF4R2FwOiBlbnRyeS5tYXhfZ2FwIGFzIG51bWJlcixcbiAgY3JlYXRlZEF0OiBlbnRyeS5jcmVhdGVkX2F0IGFzIG51bWJlcixcbiAgcmVhZHlBdDogZW50cnkucmVhZHlfYXQgYXMgbnVtYmVyLFxufSk7XG5cbi8qKlxuICogUmVjZWl2ZSBhIERiU2VsZWN0UmVzdWx0IHdpdGggbXVsdGlwbGUgcmVjb3JkcyBhbmQgdHJhbnNmb3JtIGl0IGluIGFuIGFycmF5IG9mIFR4XG4gKlxuICogQHBhcmFtIHJlc3VsdHNcbiAqIEByZXR1cm5zIFR4cyBjb252ZXJ0ZWQgZnJvbSBEYlNlbGVjdFJlc3VsdFxuICovXG5leHBvcnQgY29uc3QgZ2V0VHhzRnJvbURCUmVzdWx0ID0gKHJlc3VsdHM6IERiU2VsZWN0UmVzdWx0KTogVHhbXSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBjb25zdCB0eDogVHggPSBfbWFwVHhSZWNvcmQyVHgocmVzdWx0KTtcblxuICAgIHRyYW5zYWN0aW9ucy5wdXNoKHR4KTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdGlvbnM7XG59O1xuXG4vKipcbiAqIFJlY2VpdmUgYSBEYlNlbGVjdFJlc3VsdCB3aXRoIG9uZSByZWNvcmQgYW5kIHRyYW5zZm9ybSBpdCBpbiBhIFR4XG4gKlxuICogQHBhcmFtIHJlc3VsdHNcbiAqIEByZXR1cm5zIFR4IGNvbnZlcnRlZCBmcm9tIERiU2VsZWN0UmVzdWx0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUeEZyb21EQlJlc3VsdCA9IChyZXN1bHQ6IERiU2VsZWN0UmVzdWx0KTogVHggPT4ge1xuICBjb25zdCB7IDA6IHJvdyB9ID0gcmVzdWx0O1xuICByZXR1cm4gX21hcFR4UmVjb3JkMlR4KHJvdyk7XG59O1xuXG5jb25zdCBfbWFwVHhSZWNvcmQyVHggPSAocmVjb3JkOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFR4ID0+IChcbiAge1xuICAgIHR4SWQ6IHJlY29yZC50eF9pZCBhcyBzdHJpbmcsXG4gICAgdGltZXN0YW1wOiByZWNvcmQudGltZXN0YW1wIGFzIG51bWJlcixcbiAgICB2ZXJzaW9uOiByZWNvcmQudmVyc2lvbiBhcyBudW1iZXIsXG4gICAgdm9pZGVkOiByZWNvcmQudm9pZGVkID09PSAxLFxuICAgIGhlaWdodDogcmVjb3JkLmhlaWdodCBhcyBudW1iZXIsXG4gICAgd2VpZ2h0OiByZWNvcmQud2VpZ2h0IGFzIG51bWJlcixcbiAgfVxuKTtcblxuZXhwb3J0IGNsYXNzIEZyb21Ub2tlbkJhbGFuY2VNYXBUb0JhbGFuY2VWYWx1ZUxpc3Qge1xuICAvKipcbiAgICogQ29udmVydCB0aGUgbWFwIG9mIHRva2VuIGJhbGFuY2UgaW5zdGFuY2UgaW50byBhIG1hcCBvZiB0b2tlbiBiYWxhbmNlIHZhbHVlLlxuICAgKiBJdCBhbHNvIGh5ZHJhdGUgZWFjaCB0b2tlbiBiYWxhbmNlIHZhbHVlIHdpdGggdG9rZW4gc3ltYm9sLlxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW5CYWxhbmNlTWFwIC0gTWFwIG9mIHRva2VuIGJhbGFuY2UgaW5zdGFuY2VcbiAgICogQHBhcmFtIHRva2VuU3ltYm9sc01hcCAtIE1hcCB0b2tlbidzIGlkIHRvIGl0cyBzeW1ib2xcbiAgICogQHJldHVybnMgYSBtYXAgb2YgdG9rZW4gYmFsYW5jZSB2YWx1ZVxuICAgKi9cbiAgc3RhdGljIGNvbnZlcnQodG9rZW5CYWxhbmNlTWFwOiBUb2tlbkJhbGFuY2VNYXAsIHRva2VuU3ltYm9sc01hcDogU3RyaW5nTWFwPHN0cmluZz4pOiBUb2tlbkJhbGFuY2VWYWx1ZVtdIHtcbiAgICBjb25zdCBlbnRyeUJhbGFuY2VzID0gT2JqZWN0LmVudHJpZXModG9rZW5CYWxhbmNlTWFwLm1hcCk7XG4gICAgY29uc3QgYmFsYW5jZXMgPSBlbnRyeUJhbGFuY2VzLm1hcCgoW3Rva2VuSWQsIGJhbGFuY2VdKSA9PiAoe1xuICAgICAgdG9rZW5JZCxcbiAgICAgIHRva2VuU3ltYm9sOiB0b2tlblN5bWJvbHNNYXBbdG9rZW5JZF0sXG4gICAgICBsb2NrZWRBbW91bnQ6IGJhbGFuY2UubG9ja2VkQW1vdW50LFxuICAgICAgbG9ja2VkQXV0aG9yaXRpZXM6IGJhbGFuY2UubG9ja2VkQXV0aG9yaXRpZXMudG9KU09OKCksXG4gICAgICBsb2NrRXhwaXJlczogYmFsYW5jZS5sb2NrRXhwaXJlcyxcbiAgICAgIHVubG9ja2VkQW1vdW50OiBiYWxhbmNlLnVubG9ja2VkQW1vdW50LFxuICAgICAgdW5sb2NrZWRBdXRob3JpdGllczogYmFsYW5jZS51bmxvY2tlZEF1dGhvcml0aWVzLnRvSlNPTigpLFxuICAgICAgdG90YWxBbW91bnRTZW50OiBiYWxhbmNlLnRvdGFsQW1vdW50U2VudCxcbiAgICAgIHRvdGFsOiBiYWxhbmNlLnRvdGFsKCksXG4gICAgfSBhcyBUb2tlbkJhbGFuY2VWYWx1ZSkpO1xuICAgIHJldHVybiBiYWxhbmNlcztcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc29ydEJhbGFuY2VWYWx1ZUJ5QWJzVG90YWwgPSAoYmFsYW5jZUE6IFRva2VuQmFsYW5jZVZhbHVlLCBiYWxhbmNlQjogVG9rZW5CYWxhbmNlVmFsdWUpOiBudW1iZXIgPT4ge1xuICBpZiAoTWF0aC5hYnMoYmFsYW5jZUEudG90YWwpIC0gTWF0aC5hYnMoYmFsYW5jZUIudG90YWwpID49IDApIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnQgY2xhc3MgV2FsbGV0QmFsYW5jZU1hcENvbnZlcnRlciB7XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBtYXAgb2Ygd2FsbGV0IGJhbGFuY2UgaW5zdGFuY2UgaW50byBhIG1hcCBvZiB3YWxsZXQgYmFsYW5jZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHdhbGxldEJhbGFuY2VNYXAgLSBNYXAgd2FsbGV0J3MgaWQgdG8gaXRzIGJhbGFuY2VcbiAgICogQHBhcmFtIHRva2VuU3ltYm9sc01hcCAtIE1hcCB0b2tlbidzIGlkIHRvIGl0cyBzeW1ib2xcbiAgICogQHJldHVybnMgYSBtYXAgb2Ygd2FsbGV0IGlkIHRvIGl0cyBiYWxhbmNlIHZhbHVlXG4gICAqL1xuICBzdGF0aWMgdG9WYWx1ZSh3YWxsZXRCYWxhbmNlTWFwOiBTdHJpbmdNYXA8V2FsbGV0QmFsYW5jZT4sIHRva2VuU3ltYm9sc01hcDogU3RyaW5nTWFwPHN0cmluZz4pOiBTdHJpbmdNYXA8V2FsbGV0QmFsYW5jZVZhbHVlPiB7XG4gICAgY29uc3Qgd2FsbGV0QmFsYW5jZUVudHJpZXMgPSBPYmplY3QuZW50cmllcyh3YWxsZXRCYWxhbmNlTWFwKTtcblxuICAgIGNvbnN0IHdhbGxldEJhbGFuY2VWYWx1ZU1hcDogU3RyaW5nTWFwPFdhbGxldEJhbGFuY2VWYWx1ZT4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFt3YWxsZXRJZCwgd2FsbGV0QmFsYW5jZV0gb2Ygd2FsbGV0QmFsYW5jZUVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHNvcnRlZFRva2VuQmFsYW5jZUxpc3QgPSBGcm9tVG9rZW5CYWxhbmNlTWFwVG9CYWxhbmNlVmFsdWVMaXN0XG4gICAgICAgIC8vIGh5ZHJhdGUgdG9rZW4gYmFsYW5jZSB2YWx1ZSB3aXRoIHRva2VuIHN5bWJvbCB3aGlsZSBjb252ZXJ0IHRvIHZhbHVlXG4gICAgICAgIC5jb252ZXJ0KHdhbGxldEJhbGFuY2Uud2FsbGV0QmFsYW5jZUZvclR4LCB0b2tlblN5bWJvbHNNYXApXG4gICAgICAgIC5zb3J0KHNvcnRCYWxhbmNlVmFsdWVCeUFic1RvdGFsKTtcblxuICAgICAgd2FsbGV0QmFsYW5jZVZhbHVlTWFwW3dhbGxldElkXSA9IHtcbiAgICAgICAgYWRkcmVzc2VzOiB3YWxsZXRCYWxhbmNlLmFkZHJlc3NlcyxcbiAgICAgICAgdHhJZDogd2FsbGV0QmFsYW5jZS50eElkLFxuICAgICAgICB3YWxsZXRJZDogd2FsbGV0QmFsYW5jZS53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0QmFsYW5jZUZvclR4OiBzb3J0ZWRUb2tlbkJhbGFuY2VMaXN0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2FsbGV0QmFsYW5jZVZhbHVlTWFwO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdNYXBJdGVyYXRvciA9IChzdHJpbmdNYXA6IFN0cmluZ01hcDx1bmtub3duPik6IFtzdHJpbmcsIHVua25vd25dW10gPT4gKE9iamVjdC5lbnRyaWVzKHN0cmluZ01hcCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/db/utils.ts\n");

/***/ }),

/***/ "./src/fullnode.ts":
/*!*************************!*\
  !*** ./src/fullnode.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.create = exports.TIMEOUT = exports.BASE_URL = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"axios\"));\nexports.BASE_URL = process.env.DEFAULT_SERVER;\nexports.TIMEOUT = 10000;\nconst create = (baseURL = exports.BASE_URL) => {\n    const api = axios_1.default.create({\n        baseURL,\n        headers: {},\n        timeout: exports.TIMEOUT,\n    });\n    const downloadTx = async (txId) => {\n        const response = await api.get(`transaction?id=${txId}`, {\n            data: null,\n            headers: { 'content-type': 'application/json' },\n        });\n        return response.data;\n    };\n    const getConfirmationData = async (txId) => {\n        const response = await api.get(`transaction_acc_weight?id=${txId}`, {\n            data: null,\n            headers: { 'content-type': 'application/json' },\n        });\n        return response.data;\n    };\n    const queryGraphvizNeighbours = async (txId, graphType, maxLevel) => {\n        const url = `graphviz/neighbours.dot/?tx=${txId}&graph_type=${graphType}&max_level=${maxLevel}`;\n        const response = await api.get(url, {\n            data: null,\n            headers: { 'content-type': 'application/json' },\n        });\n        return response.data;\n    };\n    return {\n        api,\n        downloadTx,\n        getConfirmationData,\n        queryGraphvizNeighbours,\n    };\n};\nexports.create = create;\nexports[\"default\"] = (0, exports.create)();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZnVsbG5vZGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdDQTtBQStDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1zZXJ2aWNlLy4vc3JjL2Z1bGxub2RlLnRzPzhjNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEhhdGhvciBMYWJzIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5leHBvcnQgY29uc3QgQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ERUZBVUxUX1NFUlZFUjtcbmV4cG9ydCBjb25zdCBUSU1FT1VUID0gMTAwMDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhbmRsZXIgZm9yIHJlcXVlc3RpbmcgZGF0YSBmcm9tIHRoZSBmdWxsbm9kZVxuICpcbiAqIEBwYXJhbSBiYXNlVVJMIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgZnVsbC1ub2RlLiBEZWZhdWx0cyB0byBgZW52LkRFRkFVTFRfU0VSVkVSYFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKGJhc2VVUkwgPSBCQVNFX1VSTCk6IGFueSA9PiB7XG4gIGNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgYmFzZVVSTCxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICB0aW1lb3V0OiBUSU1FT1VULFxuICB9KTtcblxuICBjb25zdCBkb3dubG9hZFR4ID0gYXN5bmMgKHR4SWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgdHJhbnNhY3Rpb24/aWQ9JHt0eElkfWAsIHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBoZWFkZXJzOiB7ICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9O1xuXG4gIGNvbnN0IGdldENvbmZpcm1hdGlvbkRhdGEgPSBhc3luYyAodHhJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGB0cmFuc2FjdGlvbl9hY2Nfd2VpZ2h0P2lkPSR7dHhJZH1gLCB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgaGVhZGVyczogeyAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfTtcblxuICBjb25zdCBxdWVyeUdyYXBodml6TmVpZ2hib3VycyA9IGFzeW5jIChcbiAgICB0eElkOiBzdHJpbmcsXG4gICAgZ3JhcGhUeXBlOiBzdHJpbmcsXG4gICAgbWF4TGV2ZWw6IG51bWJlcixcbiAgKSA9PiB7XG4gICAgY29uc3QgdXJsID0gYGdyYXBodml6L25laWdoYm91cnMuZG90Lz90eD0ke3R4SWR9JmdyYXBoX3R5cGU9JHtncmFwaFR5cGV9Jm1heF9sZXZlbD0ke21heExldmVsfWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KHVybCwge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhcGksIC8vIGV4cG9ydGVkIHNvIHdlIGNhbiBtb2NrIGl0IG9uIHRoZSB0ZXN0c1xuICAgIGRvd25sb2FkVHgsXG4gICAgZ2V0Q29uZmlybWF0aW9uRGF0YSxcbiAgICBxdWVyeUdyYXBodml6TmVpZ2hib3VycyxcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/fullnode.ts\n");

/***/ }),

/***/ "./src/logger.ts":
/*!***********************!*\
  !*** ./src/logger.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst winston_1 = __webpack_require__(/*! winston */ \"winston\");\nconst createDefaultLogger = () => (0, winston_1.createLogger)({\n    level: process.env.LOG_LEVEL || 'info',\n    format: winston_1.format.json(),\n    transports: [\n        new winston_1.transports.Console(),\n    ],\n});\nexports[\"default\"] = createDefaultLogger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbG9nZ2VyLnRzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FsbGV0LXNlcnZpY2UvLi9zcmMvbG9nZ2VyLnRzP2Q4M2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlTG9nZ2VyLCBmb3JtYXQsIHRyYW5zcG9ydHMsIExvZ2dlciB9IGZyb20gJ3dpbnN0b24nO1xuXG5jb25zdCBjcmVhdGVEZWZhdWx0TG9nZ2VyID0gKCk6IExvZ2dlciA9PiBjcmVhdGVMb2dnZXIoe1xuICBsZXZlbDogcHJvY2Vzcy5lbnYuTE9HX0xFVkVMIHx8ICdpbmZvJyxcbiAgZm9ybWF0OiBmb3JtYXQuanNvbigpLFxuICB0cmFuc3BvcnRzOiBbXG4gICAgbmV3IHRyYW5zcG9ydHMuQ29uc29sZSgpLFxuICBdLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZURlZmF1bHRMb2dnZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/logger.ts\n");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Severity = exports.PushProvider = exports.InputSelectionAlgo = exports.TokenBalanceMap = exports.WalletTokenBalance = exports.Balance = exports.Authorities = exports.TokenInfo = exports.WalletStatus = exports.TxProposalStatus = void 0;\nconst wallet_lib_1 = __importDefault(__webpack_require__(/*! @hathor/wallet-lib */ \"@hathor/wallet-lib\"));\nconst utils_1 = __webpack_require__(/*! @src/utils */ \"./src/utils.ts\");\nvar TxProposalStatus;\n(function (TxProposalStatus) {\n    TxProposalStatus[\"OPEN\"] = \"open\";\n    TxProposalStatus[\"SENT\"] = \"sent\";\n    TxProposalStatus[\"SEND_ERROR\"] = \"send_error\";\n    TxProposalStatus[\"CANCELLED\"] = \"cancelled\";\n})(TxProposalStatus = exports.TxProposalStatus || (exports.TxProposalStatus = {}));\nvar WalletStatus;\n(function (WalletStatus) {\n    WalletStatus[\"CREATING\"] = \"creating\";\n    WalletStatus[\"READY\"] = \"ready\";\n    WalletStatus[\"ERROR\"] = \"error\";\n})(WalletStatus = exports.WalletStatus || (exports.WalletStatus = {}));\nclass TokenInfo {\n    constructor(id, name, symbol, transactions) {\n        this.id = id;\n        this.name = name;\n        this.symbol = symbol;\n        this.transactions = transactions || 0;\n        const hathorConfig = wallet_lib_1.default.constants.HATHOR_TOKEN_CONFIG;\n        if (this.id === hathorConfig.uid) {\n            this.name = hathorConfig.name;\n            this.symbol = hathorConfig.symbol;\n        }\n    }\n    toJSON() {\n        return {\n            id: this.id,\n            name: this.name,\n            symbol: this.symbol,\n        };\n    }\n}\nexports.TokenInfo = TokenInfo;\nclass Authorities {\n    constructor(authorities) {\n        let tmp = [];\n        if (authorities instanceof Array) {\n            tmp = authorities;\n        }\n        else if (authorities != null) {\n            tmp = Authorities.intToArray(authorities);\n        }\n        this.array = new Array(Authorities.LENGTH - tmp.length).fill(0).concat(tmp);\n    }\n    toInteger() {\n        let n = 0;\n        for (let i = 0; i < this.array.length; i++) {\n            if (this.array[i] === 0)\n                continue;\n            n += this.array[i] * (2 ** (this.array.length - i - 1));\n        }\n        return n;\n    }\n    toUnsignedInteger() {\n        return Math.abs(this.toInteger());\n    }\n    clone() {\n        return new Authorities(this.array);\n    }\n    toNegative() {\n        const finalAuthorities = this.array.map((value) => {\n            if (value === 0)\n                return 0;\n            return (-1) * value;\n        });\n        return new Authorities(finalAuthorities);\n    }\n    hasNegativeValue() {\n        return this.array.some((authority) => authority < 0);\n    }\n    static intToArray(authorities) {\n        const ret = [];\n        for (const c of authorities.toString(2)) {\n            ret.push(parseInt(c, 10));\n        }\n        return ret;\n    }\n    static merge(a1, a2) {\n        return new Authorities(a1.array.map((value, index) => Math.sign(value + a2.array[index])));\n    }\n    toJSON() {\n        const authorities = this.toInteger();\n        return {\n            mint: (authorities & wallet_lib_1.default.constants.TOKEN_MINT_MASK) > 0,\n            melt: (authorities & wallet_lib_1.default.constants.TOKEN_MELT_MASK) > 0,\n        };\n    }\n}\nexports.Authorities = Authorities;\nAuthorities.LENGTH = 8;\nclass Balance {\n    constructor(totalAmountSent = 0, unlockedAmount = 0, lockedAmount = 0, lockExpires = null, unlockedAuthorities = null, lockedAuthorities = null) {\n        this.totalAmountSent = totalAmountSent;\n        this.unlockedAmount = unlockedAmount;\n        this.lockedAmount = lockedAmount;\n        this.lockExpires = lockExpires;\n        this.unlockedAuthorities = unlockedAuthorities || new Authorities();\n        this.lockedAuthorities = lockedAuthorities || new Authorities();\n    }\n    total() {\n        return this.unlockedAmount + this.lockedAmount;\n    }\n    authorities() {\n        return Authorities.merge(this.unlockedAuthorities, this.lockedAuthorities);\n    }\n    clone() {\n        return new Balance(this.totalAmountSent, this.unlockedAmount, this.lockedAmount, this.lockExpires, this.unlockedAuthorities.clone(), this.lockedAuthorities.clone());\n    }\n    static merge(b1, b2) {\n        let lockExpires = null;\n        if (b1.lockExpires === null) {\n            lockExpires = b2.lockExpires;\n        }\n        else if (b2.lockExpires === null) {\n            lockExpires = b1.lockExpires;\n        }\n        else {\n            lockExpires = Math.min(b1.lockExpires, b2.lockExpires);\n        }\n        return new Balance(b1.totalAmountSent + b2.totalAmountSent, b1.unlockedAmount + b2.unlockedAmount, b1.lockedAmount + b2.lockedAmount, lockExpires, Authorities.merge(b1.unlockedAuthorities, b2.unlockedAuthorities), Authorities.merge(b1.lockedAuthorities, b2.lockedAuthorities));\n    }\n}\nexports.Balance = Balance;\nclass WalletTokenBalance {\n    constructor(token, balance, transactions) {\n        this.token = token;\n        this.balance = balance;\n        this.transactions = transactions;\n    }\n    toJSON() {\n        return {\n            token: this.token,\n            transactions: this.transactions,\n            balance: {\n                unlocked: this.balance.unlockedAmount,\n                locked: this.balance.lockedAmount,\n            },\n            tokenAuthorities: {\n                unlocked: this.balance.unlockedAuthorities,\n                locked: this.balance.lockedAuthorities,\n            },\n            lockExpires: this.balance.lockExpires,\n        };\n    }\n}\nexports.WalletTokenBalance = WalletTokenBalance;\nclass TokenBalanceMap {\n    constructor() {\n        this.map = {};\n    }\n    get(tokenId) {\n        return this.map[tokenId] || new Balance(0, 0, 0);\n    }\n    set(tokenId, balance) {\n        this.map[tokenId] = balance;\n    }\n    getTokens() {\n        return Object.keys(this.map);\n    }\n    iterator() {\n        return Object.entries(this.map);\n    }\n    clone() {\n        const cloned = new TokenBalanceMap();\n        for (const [token, balance] of this.iterator()) {\n            cloned.set(token, balance.clone());\n        }\n        return cloned;\n    }\n    static fromStringMap(tokenBalanceMap) {\n        const obj = new TokenBalanceMap();\n        for (const [tokenId, balance] of Object.entries(tokenBalanceMap)) {\n            obj.set(tokenId, new Balance(balance.totalSent, balance.unlocked, balance.locked, balance.lockExpires || null, balance.unlockedAuthorities, balance.lockedAuthorities));\n        }\n        return obj;\n    }\n    static merge(balanceMap1, balanceMap2) {\n        if (!balanceMap1)\n            return balanceMap2.clone();\n        if (!balanceMap2)\n            return balanceMap1.clone();\n        const mergedMap = balanceMap1.clone();\n        for (const [token, balance] of balanceMap2.iterator()) {\n            const finalBalance = Balance.merge(mergedMap.get(token), balance);\n            mergedMap.set(token, finalBalance);\n        }\n        return mergedMap;\n    }\n    static fromTxOutput(output) {\n        const token = output.token;\n        const value = output.value;\n        const obj = new TokenBalanceMap();\n        if (output.locked) {\n            if ((0, utils_1.isAuthority)(output.token_data)) {\n                obj.set(token, new Balance(0, 0, 0, output.decoded.timelock, 0, new Authorities(output.value)));\n            }\n            else {\n                obj.set(token, new Balance(value, 0, value, output.decoded.timelock, 0, 0));\n            }\n        }\n        else if ((0, utils_1.isAuthority)(output.token_data)) {\n            obj.set(token, new Balance(0, 0, 0, null, new Authorities(output.value), 0));\n        }\n        else {\n            obj.set(token, new Balance(value, value, 0, null));\n        }\n        return obj;\n    }\n    static fromTxInput(input) {\n        const token = input.token;\n        const obj = new TokenBalanceMap();\n        if ((0, utils_1.isAuthority)(input.token_data)) {\n            const authorities = new Authorities(input.value);\n            obj.set(token, new Balance(0, 0, 0, null, authorities.toNegative(), new Authorities(0)));\n        }\n        else {\n            obj.set(token, new Balance(0, -input.value, 0, null));\n        }\n        return obj;\n    }\n}\nexports.TokenBalanceMap = TokenBalanceMap;\nvar InputSelectionAlgo;\n(function (InputSelectionAlgo) {\n    InputSelectionAlgo[\"USE_LARGER_UTXOS\"] = \"use-larger-utxos\";\n})(InputSelectionAlgo = exports.InputSelectionAlgo || (exports.InputSelectionAlgo = {}));\nvar PushProvider;\n(function (PushProvider) {\n    PushProvider[\"IOS\"] = \"ios\";\n    PushProvider[\"ANDROID\"] = \"android\";\n})(PushProvider = exports.PushProvider || (exports.PushProvider = {}));\nvar Severity;\n(function (Severity) {\n    Severity[\"CRITICAL\"] = \"critical\";\n    Severity[\"MAJOR\"] = \"major\";\n    Severity[\"MEDIUM\"] = \"medium\";\n    Severity[\"MINOR\"] = \"minor\";\n    Severity[\"WARNING\"] = \"warning\";\n    Severity[\"INFO\"] = \"info\";\n})(Severity = exports.Severity || (exports.Severity = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBU0E7QUFFQTtBQXNCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUErQkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlCQTtBQWdDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUtBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkhBO0FBSUE7QUFrSEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQVFBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQXBGQTtBQWtHQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVCQTtBQXNDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUhBO0FBK1JBO0FBQUE7QUFDQTtBQUNBO0FBbUJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE4R0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FsbGV0LXNlcnZpY2UvLi9zcmMvdHlwZXMudHM/YTc2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgSGF0aG9yIExhYnMgYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBoYXRob3JMaWIgZnJvbSAnQGhhdGhvci93YWxsZXQtbGliJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuaW1wb3J0IHsgaXNBdXRob3JpdHkgfSBmcm9tICdAc3JjL3V0aWxzJztcblxuaW1wb3J0IHtcbiAgQVBJR2F0ZXdheVByb3h5RXZlbnQsXG4gIEFQSUdhdGV3YXlQcm94eVJlc3VsdCxcbiAgQ29udGV4dCxcbiAgQ2FsbGJhY2ssXG59IGZyb20gJ2F3cy1sYW1iZGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmluZ01hcDxUPiB7XG4gIFt4OiBzdHJpbmddOiBUO1xufVxuXG5leHBvcnQgdHlwZSBBZGRyZXNzSW5kZXhNYXAgPSBTdHJpbmdNYXA8bnVtYmVyPjtcblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0ZUFkZHJlc3NlcyB7XG4gIGFkZHJlc3Nlczogc3RyaW5nW107XG4gIGV4aXN0aW5nQWRkcmVzc2VzOiBTdHJpbmdNYXA8bnVtYmVyPjtcbiAgbmV3QWRkcmVzc2VzOiBTdHJpbmdNYXA8bnVtYmVyPjtcbiAgbGFzdFVzZWRBZGRyZXNzSW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gVHhQcm9wb3NhbFN0YXR1cyB7XG4gIE9QRU4gPSAnb3BlbicsXG4gIFNFTlQgPSAnc2VudCcsXG4gIFNFTkRfRVJST1IgPSAnc2VuZF9lcnJvcicsXG4gIENBTkNFTExFRCA9ICdjYW5jZWxsZWQnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bGxOb2RlVmVyc2lvbkRhdGEge1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdmVyc2lvbjogc3RyaW5nO1xuICBuZXR3b3JrOiBzdHJpbmc7XG4gIG1pbldlaWdodDogbnVtYmVyO1xuICBtaW5UeFdlaWdodDogbnVtYmVyO1xuICBtaW5UeFdlaWdodENvZWZmaWNpZW50OiBudW1iZXI7XG4gIG1pblR4V2VpZ2h0SzogbnVtYmVyO1xuICB0b2tlbkRlcG9zaXRQZXJjZW50YWdlOiBudW1iZXI7XG4gIHJld2FyZFNwZW5kTWluQmxvY2tzOiBudW1iZXI7XG4gIG1heE51bWJlcklucHV0czogbnVtYmVyO1xuICBtYXhOdW1iZXJPdXRwdXRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhQcm9wb3NhbCB7XG4gIGlkOiBzdHJpbmc7XG4gIHdhbGxldElkOiBzdHJpbmc7XG4gIHN0YXR1czogVHhQcm9wb3NhbFN0YXR1cztcbiAgY3JlYXRlZEF0OiBudW1iZXI7XG4gIHVwZGF0ZWRBdDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBXYWxsZXRTdGF0dXMge1xuICBDUkVBVElORyA9ICdjcmVhdGluZycsXG4gIFJFQURZID0gJ3JlYWR5JyxcbiAgRVJST1IgPSAnZXJyb3InLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldCB7XG4gIHdhbGxldElkOiBzdHJpbmc7XG4gIHhwdWJrZXk6IHN0cmluZztcbiAgYXV0aFhwdWJrZXk6IHN0cmluZyxcbiAgbWF4R2FwOiBudW1iZXI7XG4gIHN0YXR1cz86IFdhbGxldFN0YXR1cztcbiAgcmV0cnlDb3VudD86IG51bWJlcjtcbiAgY3JlYXRlZEF0PzogbnVtYmVyO1xuICByZWFkeUF0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NJbmZvIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBpbmRleDogbnVtYmVyO1xuICB0cmFuc2FjdGlvbnM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaG9ydEFkZHJlc3NJbmZvIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBpbmRleDogbnVtYmVyO1xuICBhZGRyZXNzUGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuQmFsYW5jZSB7XG4gIHRva2VuSWQ6IHN0cmluZztcbiAgYmFsYW5jZTogQmFsYW5jZTtcbiAgdHJhbnNhY3Rpb25zOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBUb2tlbkluZm8ge1xuICBpZDogc3RyaW5nO1xuXG4gIG5hbWU6IHN0cmluZztcblxuICBzeW1ib2w6IHN0cmluZztcblxuICB0cmFuc2FjdGlvbnM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHN5bWJvbDogc3RyaW5nLCB0cmFuc2FjdGlvbnM/OiBudW1iZXIpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICB0aGlzLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucyB8fCAwO1xuXG4gICAgY29uc3QgaGF0aG9yQ29uZmlnID0gaGF0aG9yTGliLmNvbnN0YW50cy5IQVRIT1JfVE9LRU5fQ09ORklHO1xuXG4gICAgaWYgKHRoaXMuaWQgPT09IGhhdGhvckNvbmZpZy51aWQpIHtcbiAgICAgIHRoaXMubmFtZSA9IGhhdGhvckNvbmZpZy5uYW1lO1xuICAgICAgdGhpcy5zeW1ib2wgPSBoYXRob3JDb25maWcuc3ltYm9sO1xuICAgIH1cbiAgfVxuXG4gIHRvSlNPTigpOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3ltYm9sOiB0aGlzLnN5bWJvbCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRob3JpdGllcyB7XG4gIC8qKlxuICAgKiBTdXBwb3J0aW5nIHVwIHRvIDggYXV0aG9yaXRpZXMgKGJ1dCB3ZSBvbmx5IGhhdmUgbWludCBhbmQgbWVsdCBhdCB0aGUgbW9tZW50KVxuICAgKi9cbiAgc3RhdGljIExFTkdUSCA9IDg7XG5cbiAgYXJyYXk6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKGF1dGhvcml0aWVzPzogbnVtYmVyIHwgbnVtYmVyW10pIHtcbiAgICBsZXQgdG1wID0gW107XG4gICAgaWYgKGF1dGhvcml0aWVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRtcCA9IGF1dGhvcml0aWVzO1xuICAgIH0gZWxzZSBpZiAoYXV0aG9yaXRpZXMgIT0gbnVsbCkge1xuICAgICAgdG1wID0gQXV0aG9yaXRpZXMuaW50VG9BcnJheShhdXRob3JpdGllcyk7XG4gICAgfVxuXG4gICAgdGhpcy5hcnJheSA9IG5ldyBBcnJheShBdXRob3JpdGllcy5MRU5HVEggLSB0bXAubGVuZ3RoKS5maWxsKDApLmNvbmNhdCh0bXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGF1dGhvcml0eS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVXNlcyB0aGUgYXJyYXkgdG8gY2FsY3VsYXRlIHRoZSBmaW5hbCBudW1iZXIuIEV4YW1wbGVzOlxuICAgKiBbMCwgMCwgMCwgMCwgMSwgMSwgMCwgMV0gPSAwYjAwMDAxMTAxID0gMTNcbiAgICogWzAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdID0gMGIwMDEwMDAwMSA9IDMzXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICB0b0ludGVnZXIoKTogbnVtYmVyIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5hcnJheVtpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIG4gKz0gdGhpcy5hcnJheVtpXSAqICgyICoqICh0aGlzLmFycmF5Lmxlbmd0aCAtIGkgLSAxKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgdG9VbnNpZ25lZEludGVnZXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy50b0ludGVnZXIoKSk7XG4gIH1cblxuICBjbG9uZSgpOiBBdXRob3JpdGllcyB7XG4gICAgcmV0dXJuIG5ldyBBdXRob3JpdGllcyh0aGlzLmFycmF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgb2JqZWN0IGludmVydGluZyBlYWNoIGF1dGhvcml0eSB2YWx1ZSBzaWduLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiB2YWx1ZSBpcyBzZXQgdG8gMSwgaXQgYmVjb21lcyAtMSBhbmQgdmljZSB2ZXJzYS4gVmFsdWUgMCByZW1haW5zIHVuY2hhbmdlZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgQXV0aG9yaXR5IG9iamVjdCB3aXRoIHRoZSB2YWx1ZXMgaW52ZXJ0ZWRcbiAgICovXG4gIHRvTmVnYXRpdmUoKTogQXV0aG9yaXRpZXMge1xuICAgIGNvbnN0IGZpbmFsQXV0aG9yaXRpZXMgPSB0aGlzLmFycmF5Lm1hcCgodmFsdWUpID0+IHtcbiAgICAgIC8vIFRoaXMgaWYgaXMgbmVlZGVkIGJlY2F1c2UgSmF2YXNjcmlwdCB1c2VzIHRoZSBJRUVFXzc1NCBzdGFuZGFyZCBhbmQgaGFzIG5lZ2F0aXZlIGFuZCBwb3NpdGl2ZSB6ZXJvcyxcbiAgICAgIC8vIHNvICgtMSkgKiAwIHdvdWxkIHJldHVybiAtMC4gIEFwcGFyZW50bHkgLTAgPT09IDAgaXMgdHJ1ZSBvbiBtb3N0IGNhc2VzLCBzbyB0aGVyZSB3b3VsZG4ndCBiZSBhIHByb2JsZW0sXG4gICAgICAvLyBidXQgd2Ugd2lsbCBsZWF2ZSB0aGlzIGhlcmUgdG8gYmUgc2FmZS5cbiAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lFRUVfNzU0XG4gICAgICBpZiAodmFsdWUgPT09IDApIHJldHVybiAwO1xuXG4gICAgICByZXR1cm4gKC0xKSAqIHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQXV0aG9yaXRpZXMoZmluYWxBdXRob3JpdGllcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGlmIGFueSBvZiB0aGUgYXV0aG9yaXRpZXMgaGFzIGEgbmVnYXRpdmUgdmFsdWUuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIE5lZ2F0aXZlIHZhbHVlcyBmb3IgYW4gYXV0aG9yaXR5IG9ubHkgbWFrZSBzZW5zZSB3aGVuIGRlYWxpbmcgd2l0aCBiYWxhbmNlcyBvZiBhXG4gICAqIHRyYW5zYWN0aW9uLiBTbyBpZiB3ZSBjb25zdW1lIGFuIGF1dGhvcml0eSBpbiB0aGUgaW5wdXRzIGJ1dCBkbyBub3QgY3JlYXRlIHRoZSBzYW1lXG4gICAqIG9uZSBpbiB0aGUgb3V0cHV0LCBpdCB3aWxsIGhhdmUgdmFsdWUgLTEuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhbnkgYXV0aG9yaXR5IGlzIGxlc3MgdGhhbiAwOyBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgaGFzTmVnYXRpdmVWYWx1ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheS5zb21lKChhdXRob3JpdHkpID0+IGF1dGhvcml0eSA8IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gYW4gYXJyYXksIGNvbnNpZGVyaW5nIDEgYXJyYXkgZWxlbWVudCBwZXIgYml0LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYXJyYXkgZ2l2ZW4gYW4gaW50ZWdlclxuICAgKi9cbiAgc3RhdGljIGludFRvQXJyYXkoYXV0aG9yaXRpZXM6IG51bWJlcik6IG51bWJlcltdIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgYXV0aG9yaXRpZXMudG9TdHJpbmcoMikpIHtcbiAgICAgIHJldC5wdXNoKHBhcnNlSW50KGMsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIGF1dGhvcml0aWVzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgcHJvY2VzcyBpcyBkb25lIGluZGl2aWR1YWx5IGZvciBlYWNoIGF1dGhvcml0eSB2YWx1ZS4gRWFjaCBhMVtuXSBhbmQgYTJbbl0gYXJlIGNvbXBhcmVkLlxuICAgKiBJZiBib3RoIHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBmaW5hbCB2YWx1ZSBpcyB0aGUgc2FtZS4gSWYgb25lIGlzIDEgYW5kIHRoZSBvdGhlciAtMSwgZmluYWxcbiAgICogdmFsdWUgaXMgMC5cbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgb2JqZWN0IHdpdGggdGhlIG1lcmdlZCB2YWx1ZXNcbiAgICovXG4gIHN0YXRpYyBtZXJnZShhMTogQXV0aG9yaXRpZXMsIGEyOiBBdXRob3JpdGllcyk6IEF1dGhvcml0aWVzIHtcbiAgICByZXR1cm4gbmV3IEF1dGhvcml0aWVzKGExLmFycmF5Lm1hcCgodmFsdWUsIGluZGV4KSA9PiBNYXRoLnNpZ24odmFsdWUgKyBhMi5hcnJheVtpbmRleF0pKSk7XG4gIH1cblxuICB0b0pTT04oKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgIGNvbnN0IGF1dGhvcml0aWVzID0gdGhpcy50b0ludGVnZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWludDogKGF1dGhvcml0aWVzICYgaGF0aG9yTGliLmNvbnN0YW50cy5UT0tFTl9NSU5UX01BU0spID4gMCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG4gICAgICBtZWx0OiAoYXV0aG9yaXRpZXMgJiBoYXRob3JMaWIuY29uc3RhbnRzLlRPS0VOX01FTFRfTUFTSykgPiAwLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYWxhbmNlIHtcbiAgdG90YWxBbW91bnRTZW50OiBudW1iZXI7XG5cbiAgbG9ja2VkQW1vdW50OiBudW1iZXI7XG5cbiAgdW5sb2NrZWRBbW91bnQ6IG51bWJlcjtcblxuICBsb2NrZWRBdXRob3JpdGllczogQXV0aG9yaXRpZXM7XG5cbiAgdW5sb2NrZWRBdXRob3JpdGllczogQXV0aG9yaXRpZXM7XG5cbiAgbG9ja0V4cGlyZXM6IG51bWJlciB8IG51bGw7XG5cbiAgY29uc3RydWN0b3IodG90YWxBbW91bnRTZW50ID0gMCwgdW5sb2NrZWRBbW91bnQgPSAwLCBsb2NrZWRBbW91bnQgPSAwLCBsb2NrRXhwaXJlcyA9IG51bGwsIHVubG9ja2VkQXV0aG9yaXRpZXMgPSBudWxsLCBsb2NrZWRBdXRob3JpdGllcyA9IG51bGwpIHtcbiAgICB0aGlzLnRvdGFsQW1vdW50U2VudCA9IHRvdGFsQW1vdW50U2VudDtcbiAgICB0aGlzLnVubG9ja2VkQW1vdW50ID0gdW5sb2NrZWRBbW91bnQ7XG4gICAgdGhpcy5sb2NrZWRBbW91bnQgPSBsb2NrZWRBbW91bnQ7XG4gICAgdGhpcy5sb2NrRXhwaXJlcyA9IGxvY2tFeHBpcmVzO1xuICAgIHRoaXMudW5sb2NrZWRBdXRob3JpdGllcyA9IHVubG9ja2VkQXV0aG9yaXRpZXMgfHwgbmV3IEF1dGhvcml0aWVzKCk7XG4gICAgdGhpcy5sb2NrZWRBdXRob3JpdGllcyA9IGxvY2tlZEF1dGhvcml0aWVzIHx8IG5ldyBBdXRob3JpdGllcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG90YWwgYmFsYW5jZSwgc3VtIG9mIHVubG9ja2VkIGFuZCBsb2NrZWQgYW1vdW50cy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHRvdGFsIGJhbGFuY2VcbiAgICovXG4gIHRvdGFsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudW5sb2NrZWRBbW91bnQgKyB0aGlzLmxvY2tlZEFtb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGF1dGhvcml0aWVzLCBjb21iaW5hdGlvbiBvZiB1bmxvY2tlZCBhbmQgbG9ja2VkLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgY29tYmluZWQgYXV0aG9yaXRpZXNcbiAgICovXG4gIGF1dGhvcml0aWVzKCk6IEF1dGhvcml0aWVzIHtcbiAgICByZXR1cm4gQXV0aG9yaXRpZXMubWVyZ2UodGhpcy51bmxvY2tlZEF1dGhvcml0aWVzLCB0aGlzLmxvY2tlZEF1dGhvcml0aWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGlzIEJhbGFuY2Ugb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIG5ldyBCYWxhbmNlIG9iamVjdCB3aXRoIHRoZSBzYW1lIGluZm9ybWF0aW9uXG4gICAqL1xuICBjbG9uZSgpOiBCYWxhbmNlIHtcbiAgICByZXR1cm4gbmV3IEJhbGFuY2UoXG4gICAgICB0aGlzLnRvdGFsQW1vdW50U2VudCxcbiAgICAgIHRoaXMudW5sb2NrZWRBbW91bnQsXG4gICAgICB0aGlzLmxvY2tlZEFtb3VudCxcbiAgICAgIHRoaXMubG9ja0V4cGlyZXMsXG4gICAgICB0aGlzLnVubG9ja2VkQXV0aG9yaXRpZXMuY2xvbmUoKSxcbiAgICAgIHRoaXMubG9ja2VkQXV0aG9yaXRpZXMuY2xvbmUoKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBiYWxhbmNlcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogSW4gY2FzZSBsb2NrRXhwaXJlcyBpcyBzZXQsIGl0IHJldHVybnMgdGhlIGxvd2VzdCBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSBiMSAtIEZpcnN0IGJhbGFuY2VcbiAgICogQHBhcmFtIGIyIC0gU2Vjb25kIGJhbGFuY2VcbiAgICogQHJldHVybnMgVGhlIHN1bSBvZiBib3RoIGJhbGFuY2VzIGFuZCBhdXRob3JpdGllc1xuICAgKi9cbiAgc3RhdGljIG1lcmdlKGIxOiBCYWxhbmNlLCBiMjogQmFsYW5jZSk6IEJhbGFuY2Uge1xuICAgIGxldCBsb2NrRXhwaXJlcyA9IG51bGw7XG4gICAgaWYgKGIxLmxvY2tFeHBpcmVzID09PSBudWxsKSB7XG4gICAgICBsb2NrRXhwaXJlcyA9IGIyLmxvY2tFeHBpcmVzO1xuICAgIH0gZWxzZSBpZiAoYjIubG9ja0V4cGlyZXMgPT09IG51bGwpIHtcbiAgICAgIGxvY2tFeHBpcmVzID0gYjEubG9ja0V4cGlyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2tFeHBpcmVzID0gTWF0aC5taW4oYjEubG9ja0V4cGlyZXMsIGIyLmxvY2tFeHBpcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCYWxhbmNlKFxuICAgICAgYjEudG90YWxBbW91bnRTZW50ICsgYjIudG90YWxBbW91bnRTZW50LFxuICAgICAgYjEudW5sb2NrZWRBbW91bnQgKyBiMi51bmxvY2tlZEFtb3VudCxcbiAgICAgIGIxLmxvY2tlZEFtb3VudCArIGIyLmxvY2tlZEFtb3VudCxcbiAgICAgIGxvY2tFeHBpcmVzLFxuICAgICAgQXV0aG9yaXRpZXMubWVyZ2UoYjEudW5sb2NrZWRBdXRob3JpdGllcywgYjIudW5sb2NrZWRBdXRob3JpdGllcyksXG4gICAgICBBdXRob3JpdGllcy5tZXJnZShiMS5sb2NrZWRBdXRob3JpdGllcywgYjIubG9ja2VkQXV0aG9yaXRpZXMpLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVG9rZW5CYWxhbmNlVmFsdWUgPSB7XG4gIHRva2VuSWQ6IHN0cmluZyxcbiAgdG9rZW5TeW1ib2w6IHN0cmluZyxcbiAgdG90YWxBbW91bnRTZW50OiBudW1iZXI7XG4gIGxvY2tlZEFtb3VudDogbnVtYmVyO1xuICB1bmxvY2tlZEFtb3VudDogbnVtYmVyO1xuICBsb2NrZWRBdXRob3JpdGllczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIHVubG9ja2VkQXV0aG9yaXRpZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICBsb2NrRXhwaXJlczogbnVtYmVyIHwgbnVsbDtcbiAgdG90YWw6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFdhbGxldFRva2VuQmFsYW5jZSB7XG4gIHRva2VuOiBUb2tlbkluZm87XG5cbiAgYmFsYW5jZTogQmFsYW5jZTtcblxuICB0cmFuc2FjdGlvbnM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcih0b2tlbjogVG9rZW5JbmZvLCBiYWxhbmNlOiBCYWxhbmNlLCB0cmFuc2FjdGlvbnM6IG51bWJlcikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmJhbGFuY2UgPSBiYWxhbmNlO1xuICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xuICB9XG5cbiAgdG9KU09OKCk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IHRoaXMudG9rZW4sXG4gICAgICB0cmFuc2FjdGlvbnM6IHRoaXMudHJhbnNhY3Rpb25zLFxuICAgICAgYmFsYW5jZToge1xuICAgICAgICB1bmxvY2tlZDogdGhpcy5iYWxhbmNlLnVubG9ja2VkQW1vdW50LFxuICAgICAgICBsb2NrZWQ6IHRoaXMuYmFsYW5jZS5sb2NrZWRBbW91bnQsXG4gICAgICB9LFxuICAgICAgdG9rZW5BdXRob3JpdGllczoge1xuICAgICAgICB1bmxvY2tlZDogdGhpcy5iYWxhbmNlLnVubG9ja2VkQXV0aG9yaXRpZXMsXG4gICAgICAgIGxvY2tlZDogdGhpcy5iYWxhbmNlLmxvY2tlZEF1dGhvcml0aWVzLFxuICAgICAgfSxcbiAgICAgIGxvY2tFeHBpcmVzOiB0aGlzLmJhbGFuY2UubG9ja0V4cGlyZXMsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4VG9rZW5CYWxhbmNlIHtcbiAgdHhJZDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdm9pZGVkOiBib29sZWFuO1xuICBiYWxhbmNlOiBCYWxhbmNlO1xuICB2ZXJzaW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBUb2tlbkJhbGFuY2VNYXAge1xuICBtYXA6IFN0cmluZ01hcDxCYWxhbmNlPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICB9XG5cbiAgZ2V0KHRva2VuSWQ6IHN0cmluZyk6IEJhbGFuY2Uge1xuICAgIC8vIGlmIHRoZSB0b2tlbiBpcyBub3QgcHJlc2VudCwgcmV0dXJuIDAgaW5zdGVhZCBvZiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5tYXBbdG9rZW5JZF0gfHwgbmV3IEJhbGFuY2UoMCwgMCwgMCk7XG4gIH1cblxuICBzZXQodG9rZW5JZDogc3RyaW5nLCBiYWxhbmNlOiBCYWxhbmNlKTogdm9pZCB7XG4gICAgdGhpcy5tYXBbdG9rZW5JZF0gPSBiYWxhbmNlO1xuICB9XG5cbiAgZ2V0VG9rZW5zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApO1xuICB9XG5cbiAgaXRlcmF0b3IoKTogW3N0cmluZywgQmFsYW5jZV1bXSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMubWFwKTtcbiAgfVxuXG4gIGNsb25lKCk6IFRva2VuQmFsYW5jZU1hcCB7XG4gICAgY29uc3QgY2xvbmVkID0gbmV3IFRva2VuQmFsYW5jZU1hcCgpO1xuICAgIGZvciAoY29uc3QgW3Rva2VuLCBiYWxhbmNlXSBvZiB0aGlzLml0ZXJhdG9yKCkpIHtcbiAgICAgIGNsb25lZC5zZXQodG9rZW4sIGJhbGFuY2UuY2xvbmUoKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgVG9rZW5CYWxhbmNlTWFwIGZyb20ganMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBKcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgZm9ybWF0OlxuICAgKiBgYGBcbiAgICoge1xuICAgKiAgIHRva2VuMToge3VubG9ja2VkOiBuLCBsb2NrZWQ6IG19LFxuICAgKiAgIHRva2VuMjoge3VubG9ja2VkOiBhLCBsb2NrZWQ6IGIsIGxvY2tFeHBpcmVzOiBjfSxcbiAgICogICB0b2tlbjM6IHt1bmxvY2tlZDogeCwgbG9ja2VkOiB5LCB1bmxvY2tlZEF1dGhvcml0aWVzOiB6LCBsb2NrZWRBdXRob3JpdGllczogd30sXG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbkJhbGFuY2VNYXAgLSBUaGUganMgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYSBUb2tlbkJhbGFuY2VNYXBcbiAgICogQHJldHVybnMgLSBUaGUgbmV3IFRva2VuQmFsYW5jZU1hcCBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nTWFwKHRva2VuQmFsYW5jZU1hcDogU3RyaW5nTWFwPFN0cmluZ01hcDxudW1iZXIgfCBBdXRob3JpdGllcz4+KTogVG9rZW5CYWxhbmNlTWFwIHtcbiAgICBjb25zdCBvYmogPSBuZXcgVG9rZW5CYWxhbmNlTWFwKCk7XG4gICAgZm9yIChjb25zdCBbdG9rZW5JZCwgYmFsYW5jZV0gb2YgT2JqZWN0LmVudHJpZXModG9rZW5CYWxhbmNlTWFwKSkge1xuICAgICAgb2JqLnNldCh0b2tlbklkLCBuZXcgQmFsYW5jZShiYWxhbmNlLnRvdGFsU2VudCBhcyBudW1iZXIsIGJhbGFuY2UudW5sb2NrZWQgYXMgbnVtYmVyLCBiYWxhbmNlLmxvY2tlZCBhcyBudW1iZXIsIGJhbGFuY2UubG9ja0V4cGlyZXMgfHwgbnVsbCxcbiAgICAgICAgYmFsYW5jZS51bmxvY2tlZEF1dGhvcml0aWVzLCBiYWxhbmNlLmxvY2tlZEF1dGhvcml0aWVzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIFRva2VuQmFsYW5jZU1hcCBvYmplY3RzLCBtZXJnaW5nIHRoZSBiYWxhbmNlcyBmb3IgZWFjaCB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIGJhbGFuY2VNYXAxIC0gRmlyc3QgVG9rZW5CYWxhbmNlTWFwXG4gICAqIEBwYXJhbSBiYWxhbmNlTWFwMiAtIFNlY29uZCBUb2tlbkJhbGFuY2VNYXBcbiAgICogQHJldHVybnMgVGhlIG1lcmdlZCBUb2tlbkJhbGFuY2VNYXBcbiAgICovXG4gIHN0YXRpYyBtZXJnZShiYWxhbmNlTWFwMTogVG9rZW5CYWxhbmNlTWFwLCBiYWxhbmNlTWFwMjogVG9rZW5CYWxhbmNlTWFwKTogVG9rZW5CYWxhbmNlTWFwIHtcbiAgICBpZiAoIWJhbGFuY2VNYXAxKSByZXR1cm4gYmFsYW5jZU1hcDIuY2xvbmUoKTtcbiAgICBpZiAoIWJhbGFuY2VNYXAyKSByZXR1cm4gYmFsYW5jZU1hcDEuY2xvbmUoKTtcbiAgICBjb25zdCBtZXJnZWRNYXAgPSBiYWxhbmNlTWFwMS5jbG9uZSgpO1xuICAgIGZvciAoY29uc3QgW3Rva2VuLCBiYWxhbmNlXSBvZiBiYWxhbmNlTWFwMi5pdGVyYXRvcigpKSB7XG4gICAgICBjb25zdCBmaW5hbEJhbGFuY2UgPSBCYWxhbmNlLm1lcmdlKG1lcmdlZE1hcC5nZXQodG9rZW4pLCBiYWxhbmNlKTtcbiAgICAgIG1lcmdlZE1hcC5zZXQodG9rZW4sIGZpbmFsQmFsYW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRNYXA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVG9rZW5CYWxhbmNlTWFwIGZyb20gYSBUeE91dHB1dC5cbiAgICpcbiAgICogQHBhcmFtIG91dHB1dCAtIFRoZSB0cmFuc2FjdGlvbiBvdXRwdXRcbiAgICogQHJldHVybnMgVGhlIFRva2VuQmFsYW5jZU1hcCBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBmcm9tVHhPdXRwdXQob3V0cHV0OiBUeE91dHB1dCk6IFRva2VuQmFsYW5jZU1hcCB7XG4gICAgLy8gVE9ETyBjaGVjayBpZiBvdXRwdXQuZGVjb2RlZCBleGlzdHMsIGVsc2UgcmV0dXJuIG51bGxcbiAgICBjb25zdCB0b2tlbiA9IG91dHB1dC50b2tlbjtcbiAgICBjb25zdCB2YWx1ZSA9IG91dHB1dC52YWx1ZTtcbiAgICBjb25zdCBvYmogPSBuZXcgVG9rZW5CYWxhbmNlTWFwKCk7XG5cbiAgICBpZiAob3V0cHV0LmxvY2tlZCkge1xuICAgICAgaWYgKGlzQXV0aG9yaXR5KG91dHB1dC50b2tlbl9kYXRhKSkge1xuICAgICAgICBvYmouc2V0KHRva2VuLCBuZXcgQmFsYW5jZSgwLCAwLCAwLCBvdXRwdXQuZGVjb2RlZC50aW1lbG9jaywgMCwgbmV3IEF1dGhvcml0aWVzKG91dHB1dC52YWx1ZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5zZXQodG9rZW4sIG5ldyBCYWxhbmNlKHZhbHVlLCAwLCB2YWx1ZSwgb3V0cHV0LmRlY29kZWQudGltZWxvY2ssIDAsIDApKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXV0aG9yaXR5KG91dHB1dC50b2tlbl9kYXRhKSkge1xuICAgICAgb2JqLnNldCh0b2tlbiwgbmV3IEJhbGFuY2UoMCwgMCwgMCwgbnVsbCwgbmV3IEF1dGhvcml0aWVzKG91dHB1dC52YWx1ZSksIDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLnNldCh0b2tlbiwgbmV3IEJhbGFuY2UodmFsdWUsIHZhbHVlLCAwLCBudWxsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUb2tlbkJhbGFuY2VNYXAgZnJvbSBhIFR4SW5wdXQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEl0IHdpbGwgaGF2ZSBvbmx5IG9uZSB0b2tlbiBlbnRyeSBhbmQgYmFsYW5jZSB3aWxsIGJlIG5lZ2F0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgdHJhbnNhY3Rpb24gaW5wdXRcbiAgICogQHJldHVybnMgVGhlIFRva2VuQmFsYW5jZU1hcCBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBmcm9tVHhJbnB1dChpbnB1dDogVHhJbnB1dCk6IFRva2VuQmFsYW5jZU1hcCB7XG4gICAgY29uc3QgdG9rZW4gPSBpbnB1dC50b2tlbjtcbiAgICBjb25zdCBvYmogPSBuZXcgVG9rZW5CYWxhbmNlTWFwKCk7XG5cbiAgICBpZiAoaXNBdXRob3JpdHkoaW5wdXQudG9rZW5fZGF0YSkpIHtcbiAgICAgIC8vIGZvciBpbnB1dHMsIHRoZSBhdXRob3JpdGllcyB3aWxsIGhhdmUgYSB2YWx1ZSBvZiAtMSB3aGVuIHNldFxuICAgICAgY29uc3QgYXV0aG9yaXRpZXMgPSBuZXcgQXV0aG9yaXRpZXMoaW5wdXQudmFsdWUpO1xuICAgICAgb2JqLnNldCh0b2tlbiwgbmV3IEJhbGFuY2UoMCwgMCwgMCwgbnVsbCwgYXV0aG9yaXRpZXMudG9OZWdhdGl2ZSgpLCBuZXcgQXV0aG9yaXRpZXMoMCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLnNldCh0b2tlbiwgbmV3IEJhbGFuY2UoMCwgLWlucHV0LnZhbHVlLCAwLCBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdHlwZSBmcm9tIFNlcnZlcmxlc3NNeXNxbCNxdWVyeSBhZnRlciBwZXJmb3JtaW5nIGEgU1FMIFNFTEVDVFxuICogKEFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIHRhYmxlIGZpZWxkcy4pXG4gKi9cbmV4cG9ydCB0eXBlIERiU2VsZWN0UmVzdWx0ID0gQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+O1xuXG4vKipcbiAqIEhhdGhvciB0eXBlc1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVjb2RlZE91dHB1dCB7XG4gIHR5cGU6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICB0aW1lbG9jazogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeE91dHB1dCB7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHNjcmlwdDogc3RyaW5nO1xuICB0b2tlbjogc3RyaW5nO1xuICBkZWNvZGVkOiBEZWNvZGVkT3V0cHV0O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHNwZW50X2J5OiBzdHJpbmcgfCBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRva2VuX2RhdGE6IG51bWJlcjtcbiAgbG9ja2VkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeE91dHB1dFdpdGhJbmRleCBleHRlbmRzIFR4T3V0cHV0IHtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeElucHV0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICB0eF9pZDogc3RyaW5nO1xuICBpbmRleDogbnVtYmVyO1xuICB2YWx1ZTogbnVtYmVyO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRva2VuX2RhdGE6IG51bWJlcjtcbiAgc2NyaXB0OiBzdHJpbmc7XG4gIHRva2VuOiBzdHJpbmc7XG4gIGRlY29kZWQ6IERlY29kZWRPdXRwdXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb24ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHR4X2lkOiBzdHJpbmc7XG4gIG5vbmNlOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHNpZ25hbF9iaXRzOiBudW1iZXI7XG4gIHZlcnNpb246IG51bWJlcjtcbiAgd2VpZ2h0OiBudW1iZXI7XG4gIHBhcmVudHM6IHN0cmluZ1tdO1xuICBpbnB1dHM6IFR4SW5wdXRbXTtcbiAgb3V0cHV0czogVHhPdXRwdXRbXTtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRva2VuX25hbWU/OiBzdHJpbmc7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgdG9rZW5fc3ltYm9sPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElXYWxsZXRPdXRwdXQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHRva2VuOiBzdHJpbmc7XG4gIHRva2VuRGF0YTogbnVtYmVyO1xuICB0aW1lbG9jazogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElXYWxsZXRJbnB1dCB7XG4gIHR4SWQ6IHN0cmluZztcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcGlSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgV3NDb25uZWN0aW9uSW5mbyA9IHtcbiAgaWQ6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFJlZGlzQ29uZmlnID0ge1xuICB1cmw6IHN0cmluZztcbiAgcGFzc3dvcmQ/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFR4IHtcbiAgdHhJZDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdmVyc2lvbjogbnVtYmVyO1xuICB2b2lkZWQ6IGJvb2xlYW47XG4gIGhlaWdodD86IG51bWJlciB8IG51bGw7XG4gIHdlaWdodDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NCYWxhbmNlIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICB0b2tlbklkOiBzdHJpbmc7XG4gIHVubG9ja2VkQmFsYW5jZTogbnVtYmVyO1xuICBsb2NrZWRCYWxhbmNlOiBudW1iZXI7XG4gIHVubG9ja2VkQXV0aG9yaXRpZXM6IG51bWJlcjtcbiAgbG9ja2VkQXV0aG9yaXRpZXM6IG51bWJlcjtcbiAgdGltZWxvY2tFeHBpcmVzOiBudW1iZXI7XG4gIHRyYW5zYWN0aW9uczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NUb3RhbEJhbGFuY2Uge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIHRva2VuSWQ6IHN0cmluZztcbiAgYmFsYW5jZTogbnVtYmVyO1xuICB0cmFuc2FjdGlvbnM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYlR4T3V0cHV0IHtcbiAgdHhJZDogc3RyaW5nO1xuICBpbmRleDogbnVtYmVyO1xuICB0b2tlbklkOiBzdHJpbmc7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgdmFsdWU6IG51bWJlcjtcbiAgYXV0aG9yaXRpZXM6IG51bWJlcjtcbiAgdGltZWxvY2s6IG51bWJlciB8IG51bGw7XG4gIGhlaWdodGxvY2s6IG51bWJlciB8IG51bGw7XG4gIGxvY2tlZDogYm9vbGVhbjtcbiAgc3BlbnRCeT86IHN0cmluZyB8IG51bGw7XG4gIHR4UHJvcG9zYWxJZD86IHN0cmluZztcbiAgdHhQcm9wb3NhbEluZGV4PzogbnVtYmVyO1xuICB2b2lkZWQ/OiBib29sZWFuIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCbG9jayB7XG4gIHR4SWQ6IHN0cmluZztcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG4vLyBtYXliZSB1c2UgdGVtcGxhdGVzIDxURXZlbnQgPSBhbnksIFRSZXN1bHQgPSBhbnk+XG5leHBvcnQgdHlwZSBXYWxsZXRQcm94eUhhbmRsZXIgPSAoXG4gIHdhbGxldElkOiBzdHJpbmcsXG4gIGV2ZW50PzogQVBJR2F0ZXdheVByb3h5RXZlbnQsXG4gIGNvbnRleHQ/OiBDb250ZXh0LFxuICBjYWxsYmFjaz86IENhbGxiYWNrPEFQSUdhdGV3YXlQcm94eVJlc3VsdD5cbikgPT4gUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIElGaWx0ZXJUeE91dHB1dCB7XG4gIGFkZHJlc3Nlczogc3RyaW5nW107XG4gIHRva2VuSWQ/OiBzdHJpbmc7XG4gIGF1dGhvcml0eT86IG51bWJlcjtcbiAgaWdub3JlTG9ja2VkPzogYm9vbGVhbjtcbiAgYmlnZ2VyVGhhbj86IG51bWJlcjtcbiAgc21hbGxlclRoYW4/OiBudW1iZXI7XG4gIG1heE91dHB1dHM/OiBudW1iZXI7XG4gIHNraXBTcGVudD86IGJvb2xlYW47XG4gIHR4SWQ/OiBzdHJpbmc7XG4gIGluZGV4PzogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBJbnB1dFNlbGVjdGlvbkFsZ28ge1xuICBVU0VfTEFSR0VSX1VUWE9TID0gJ3VzZS1sYXJnZXItdXR4b3MnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElXYWxsZXRJbnN1ZmZpY2llbnRGdW5kcyB7XG4gIHRva2VuSWQ6IHN0cmluZztcbiAgcmVxdWVzdGVkOiBudW1iZXI7XG4gIGF2YWlsYWJsZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERiVHhPdXRwdXRXaXRoUGF0aCBleHRlbmRzIERiVHhPdXRwdXQge1xuICBhZGRyZXNzUGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1pbmVyIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBmaXJzdEJsb2NrOiBzdHJpbmc7XG4gIGxhc3RCbG9jazogc3RyaW5nO1xuICBjb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBQdXNoUHJvdmlkZXIge1xuICBJT1MgPSAnaW9zJyxcbiAgQU5EUk9JRCA9ICdhbmRyb2lkJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1c2hSZWdpc3RlciB7XG4gIHB1c2hQcm92aWRlcjogUHVzaFByb3ZpZGVyLFxuICBkZXZpY2VJZDogc3RyaW5nLFxuICBlbmFibGVQdXNoPzogYm9vbGVhbixcbiAgZW5hYmxlU2hvd0Ftb3VudHM/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaFVwZGF0ZSB7XG4gIGRldmljZUlkOiBzdHJpbmcsXG4gIGVuYWJsZVB1c2g/OiBib29sZWFuLFxuICBlbmFibGVTaG93QW1vdW50cz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQdXNoRGVsZXRlIHtcbiAgZGV2aWNlSWQ6IHN0cmluZyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRyZXNzQXRJbmRleFJlcXVlc3Qge1xuICBpbmRleD86IG51bWJlcixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeEJ5SWRSZXF1ZXN0IHtcbiAgdHhJZDogc3RyaW5nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4QnlJZFRva2VuIHtcbiAgdHhJZDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdmVyc2lvbjogbnVtYmVyO1xuICB2b2lkZWQ6IGJvb2xlYW47XG4gIHdlaWdodDogbnVtYmVyO1xuICBiYWxhbmNlOiBCYWxhbmNlO1xuICB0b2tlbklkOiBzdHJpbmc7XG4gIHRva2VuTmFtZTogc3RyaW5nO1xuICB0b2tlblN5bWJvbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmFtVmFsaWRhdGlvblJlc3VsdDxWYWx1ZVR5cGU+IHtcbiAgZXJyb3I6IGJvb2xlYW47XG4gIGRldGFpbHM/OiB7IG1lc3NhZ2U6IHN0cmluZywgcGF0aDogKHN0cmluZyB8IG51bWJlcilbXSB9W10sXG4gIHZhbHVlPzogVmFsdWVUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBodml6UGFyYW1zIHtcbiAgdHhJZDogc3RyaW5nO1xuICBncmFwaFR5cGU6IHN0cmluZztcbiAgbWF4TGV2ZWw6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRUeEJ5SWRQYXJhbXMge1xuICB0eElkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0Q29uZmlybWF0aW9uRGF0YVBhcmFtcyB7XG4gIHR4SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kTm90aWZpY2F0aW9uVG9EZXZpY2Uge1xuICBkZXZpY2VJZDogc3RyaW5nLFxuICAvKipcbiAgICogQSBzdHJpbmcgbWFwIHVzZWQgdG8gc2VuZCBkYXRhIGluIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZS5cbiAgICogQHNlZSBMb2NhbGl6ZU1ldGFkYXRhTm90aWZpY2F0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHtcbiAgICogICAgXCJ0aXRsZUxvY0tleVwiOiBcIm5ld190cmFuc2FjdGlvbl9yZWNlaXZlZF90aXRsZVwiLFxuICAgKiAgICBcImJvZHlMb2NLZXlcIjogXCJuZXdfdHJhbnNhY3Rpb25fcmVjZWl2ZWRfZGVzY3JpcHRpb25fd2l0aF90b2tlbnNcIixcbiAgICogICAgXCJib2R5TG9jQXJnc1wiOiBcIlsnMTMgSFRSJywgJzggVE5UJywgJzInXVwiXG4gICAqIH1cbiAgICovXG4gIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxufVxuXG5leHBvcnQgdHlwZSBMb2NhbGl6ZU1ldGFkYXRhTm90aWZpY2F0aW9uID0ge1xuICB0aXRsZUxvY0tleTogc3RyaW5nLFxuICB0aXRsZUxvY0FyZ3M6IHN0cmluZyxcbiAgYm9keUxvY0tleTogc3RyaW5nLFxuICBib2R5TG9jQXJnczogc3RyaW5nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1c2hEZXZpY2Uge1xuICB3YWxsZXRJZDogc3RyaW5nLFxuICBkZXZpY2VJZDogc3RyaW5nLFxuICBwdXNoUHJvdmlkZXI6IFB1c2hQcm92aWRlcixcbiAgZW5hYmxlUHVzaDogYm9vbGVhbixcbiAgZW5hYmxlU2hvd0Ftb3VudHM6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUHVzaERldmljZVNldHRpbmdzID0gT21pdDxQdXNoRGV2aWNlLCAncHVzaFByb3ZpZGVyJz47XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0QmFsYW5jZSB7XG4gIHR4SWQ6IHN0cmluZyxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgYWRkcmVzc2VzOiBzdHJpbmdbXSxcbiAgd2FsbGV0QmFsYW5jZUZvclR4OiBUb2tlbkJhbGFuY2VNYXAsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0QmFsYW5jZVZhbHVlIHtcbiAgdHhJZDogc3RyaW5nLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICBhZGRyZXNzZXM6IHN0cmluZ1tdLFxuICB3YWxsZXRCYWxhbmNlRm9yVHg6IFRva2VuQmFsYW5jZVZhbHVlW10sXG59XG5cbi8qKlxuICogQWxlcnRzIHNob3VsZCBmb2xsb3cgdGhlIG9uLWNhbGwgZ3VpZGUgZm9yIGFsZXJ0aW5nLCBzZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9IYXRob3JOZXR3b3JrL29wcy10b29scy9ibG9iL21hc3Rlci9kb2NzL29uLWNhbGwvZ3VpZGUubWQjYWxlcnQtc2V2ZXJpdHlwcmlvcml0eVxuICovXG5leHBvcnQgZW51bSBTZXZlcml0eSB7XG4gIENSSVRJQ0FMID0gJ2NyaXRpY2FsJyxcbiAgTUFKT1IgPSAnbWFqb3InLFxuICBNRURJVU0gPSAnbWVkaXVtJyxcbiAgTUlOT1IgPSAnbWlub3InLFxuICBXQVJOSU5HID0gJ3dhcm5pbmcnLFxuICBJTkZPID0gJ2luZm8nLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/types.ts\n");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertEnvVariablesExistence = exports.getAddressFromXpub = exports.verifySignature = exports.xpubDeriveChild = exports.getAddresses = exports.getAddressAtIndex = exports.validateAuthTimestamp = exports.AUTH_MAX_TIMESTAMP_SHIFT_IN_SECONDS = exports.confirmFirstAddress = exports.getAddressPath = exports.fetchBlockHeight = exports.isTxVoided = exports.arrayShuffle = exports.isAuthority = exports.closeDbConnection = exports.getDbConnection = exports.getUnixTimestamp = exports.getWalletId = exports.sha256d = exports.CustomStorage = void 0;\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst serverless_mysql_1 = __importDefault(__webpack_require__(/*! serverless-mysql */ \"serverless-mysql\"));\nconst wallet_lib_1 = __importDefault(__webpack_require__(/*! @hathor/wallet-lib */ \"@hathor/wallet-lib\"));\nconst fullnode_1 = __importDefault(__webpack_require__(/*! @src/fullnode */ \"./src/fullnode.ts\"));\nconst bitcoin = __importStar(__webpack_require__(/*! bitcoinjs-lib */ \"bitcoinjs-lib\"));\nconst bitcoinMessage = __importStar(__webpack_require__(/*! bitcoinjs-message */ \"bitcoinjs-message\"));\nconst ecc = __importStar(__webpack_require__(/*! tiny-secp256k1 */ \"tiny-secp256k1\"));\nconst bip32_1 = __importDefault(__webpack_require__(/*! bip32 */ \"bip32\"));\nconst bip32 = (0, bip32_1.default)(ecc);\nclass CustomStorage {\n    constructor() {\n        this.preStart();\n    }\n    getItem(key) {\n        return this.store[key];\n    }\n    setItem(key, value) {\n        this.store[key] = value;\n        return value;\n    }\n    removeItem(key) {\n        delete this.store[key];\n        return key;\n    }\n    clear() {\n        this.store = {};\n    }\n    preStart() {\n        this.store = {\n            'wallet:server': process.env.DEFAULT_SERVER || wallet_lib_1.default.constants.DEFAULT_SERVER,\n            'wallet:defaultServer': process.env.DEFAULT_SERVER || wallet_lib_1.default.constants.DEFAULT_SERVER,\n        };\n    }\n}\nexports.CustomStorage = CustomStorage;\nwallet_lib_1.default.network.setNetwork(process.env.NETWORK);\nwallet_lib_1.default.storage.setStore(new CustomStorage());\nconst libNetwork = wallet_lib_1.default.network.getNetwork();\nconst hathorNetwork = {\n    messagePrefix: '\\x18Hathor Signed Message:\\n',\n    bech32: wallet_lib_1.default.network.bech32prefix,\n    bip32: {\n        public: libNetwork.xpubkey,\n        private: libNetwork.xprivkey,\n    },\n    pubKeyHash: libNetwork.pubkeyhash,\n    scriptHash: libNetwork.scripthash,\n    wif: libNetwork.privatekey,\n};\nconst sha256d = (data, encoding) => {\n    const hash1 = (0, crypto_1.createHash)('sha256');\n    hash1.update(data);\n    const hash2 = (0, crypto_1.createHash)('sha256');\n    hash2.update(hash1.digest());\n    return hash2.digest(encoding);\n};\nexports.sha256d = sha256d;\nconst getWalletId = (xpubkey) => ((0, exports.sha256d)(xpubkey, 'hex'));\nexports.getWalletId = getWalletId;\nconst getUnixTimestamp = () => (Math.round((new Date()).getTime() / 1000));\nexports.getUnixTimestamp = getUnixTimestamp;\nconst getDbConnection = () => ((0, serverless_mysql_1.default)({\n    config: {\n        host: process.env.DB_ENDPOINT,\n        database: process.env.DB_NAME,\n        user: process.env.DB_USER,\n        port: parseInt(process.env.DB_PORT, 10),\n        password: process.env.DB_PASS,\n    },\n}));\nexports.getDbConnection = getDbConnection;\nconst closeDbConnection = async (mysql) => {\n    if (process.env.STAGE === 'local') {\n        await mysql.quit();\n    }\n    else {\n        await mysql.end();\n    }\n};\nexports.closeDbConnection = closeDbConnection;\nconst isAuthority = (tokenData) => ((tokenData & wallet_lib_1.default.constants.TOKEN_AUTHORITY_MASK) > 0);\nexports.isAuthority = isAuthority;\nconst arrayShuffle = (array) => {\n    let j;\n    let x;\n    let i;\n    for (i = array.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = array[i];\n        array[i] = array[j];\n        array[j] = x;\n    }\n    return array;\n};\nexports.arrayShuffle = arrayShuffle;\nconst isTxVoided = async (txId) => {\n    const transaction = await fullnode_1.default.downloadTx(txId);\n    if (!transaction.meta.voided_by || transaction.meta.voided_by.length === 0) {\n        return [false, transaction];\n    }\n    return [true, transaction];\n};\nexports.isTxVoided = isTxVoided;\nconst fetchBlockHeight = async (txId, logger) => {\n    const transaction = await fullnode_1.default.downloadTx(txId);\n    if (!transaction.tx.height) {\n        logger.error(JSON.stringify(transaction));\n        throw new Error(`Block ${txId} has no height.`);\n    }\n    return [transaction.tx.height, transaction];\n};\nexports.fetchBlockHeight = fetchBlockHeight;\nconst getAddressPath = (index) => (`m/44'/${wallet_lib_1.default.constants.HATHOR_BIP44_CODE}'/0'/0/${index}`);\nexports.getAddressPath = getAddressPath;\nconst confirmFirstAddress = (expectedFirstAddress, xpubkey) => {\n    const derivedXpub = (0, exports.xpubDeriveChild)(xpubkey, 0);\n    const firstAddress = (0, exports.getAddressAtIndex)(derivedXpub, 0);\n    return [\n        firstAddress === expectedFirstAddress,\n        firstAddress,\n    ];\n};\nexports.confirmFirstAddress = confirmFirstAddress;\nexports.AUTH_MAX_TIMESTAMP_SHIFT_IN_SECONDS = 30;\nconst validateAuthTimestamp = (timestamp, now) => {\n    const timestampShiftInSeconds = Math.floor(Math.abs(now - timestamp));\n    return [timestampShiftInSeconds < exports.AUTH_MAX_TIMESTAMP_SHIFT_IN_SECONDS, timestampShiftInSeconds];\n};\nexports.validateAuthTimestamp = validateAuthTimestamp;\nconst getAddressAtIndex = (xpubkey, addressIndex) => {\n    const node = bip32.fromBase58(xpubkey).derive(addressIndex);\n    return bitcoin.payments.p2pkh({\n        pubkey: node.publicKey,\n        network: hathorNetwork,\n    }).address;\n};\nexports.getAddressAtIndex = getAddressAtIndex;\nconst getAddresses = (xpubkey, startIndex, quantity) => {\n    const addrMap = {};\n    for (let index = startIndex; index < startIndex + quantity; index++) {\n        const address = (0, exports.getAddressAtIndex)(xpubkey, index);\n        addrMap[address] = index;\n    }\n    return addrMap;\n};\nexports.getAddresses = getAddresses;\nconst xpubDeriveChild = (xpubkey, index) => (bip32.fromBase58(xpubkey).derive(index).toBase58());\nexports.xpubDeriveChild = xpubDeriveChild;\nconst verifySignature = (signature, timestamp, address, walletId) => {\n    try {\n        const message = String(timestamp).concat(walletId).concat(address);\n        return bitcoinMessage.verify(message, address, Buffer.from(signature, 'base64'), '\\u0017Hathor Signed Message:\\n');\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.verifySignature = verifySignature;\nconst getAddressFromXpub = (xpubkey) => {\n    const node = bip32.fromBase58(xpubkey);\n    return bitcoin.payments.p2pkh({\n        pubkey: node.publicKey,\n        network: hathorNetwork,\n    }).address;\n};\nexports.getAddressFromXpub = getAddressFromXpub;\nconst assertEnvVariablesExistence = (envVariables) => {\n    const missingList = [];\n    for (const envVariable of envVariables) {\n        if (!(envVariable in process.env) || process.env[envVariable].length === 0) {\n            missingList.push(envVariable);\n        }\n    }\n    if (missingList.length > 0) {\n        throw new Error(`Env missing the following variables ${missingList.join(', ')}`);\n    }\n};\nexports.assertEnvVariablesExistence = assertEnvVariablesExistence;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQW1DQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQWNBO0FBQUE7QUFTQTtBQUFBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBWEE7QUFjQTtBQUNBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUFBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBYkE7QUF1QkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFSQTtBQWtCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBVEE7QUFnQkE7QUFBQTtBQWFBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQWVBO0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFKQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUE2QkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVRBO0FBbUJBO0FBQUE7QUFjQTtBQU1BO0FBQ0E7QUFFQTtBQVVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUF4QkE7QUFpQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFYQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldC1zZXJ2aWNlLy4vc3JjL3V0aWxzLnRzPzdkZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEhhdGhvciBMYWJzIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBCaW5hcnlUb1RleHRFbmNvZGluZywgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5cbmltcG9ydCBzZXJ2ZXJsZXNzTXlzcWwsIHsgU2VydmVybGVzc015c3FsIH0gZnJvbSAnc2VydmVybGVzcy1teXNxbCc7XG5pbXBvcnQgaGF0aG9yTGliIGZyb20gJ0BoYXRob3Ivd2FsbGV0LWxpYic7XG5pbXBvcnQgZnVsbG5vZGUgZnJvbSAnQHNyYy9mdWxsbm9kZSc7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ2JpdGNvaW5qcy1saWInO1xuaW1wb3J0ICogYXMgYml0Y29pbk1lc3NhZ2UgZnJvbSAnYml0Y29pbmpzLW1lc3NhZ2UnO1xuaW1wb3J0ICogYXMgZWNjIGZyb20gJ3Rpbnktc2VjcDI1NmsxJztcbmltcG9ydCBCSVAzMkZhY3RvcnkgZnJvbSAnYmlwMzInO1xuXG5jb25zdCBiaXAzMiA9IEJJUDMyRmFjdG9yeShlY2MpO1xuXG4vKiBUT0RPOiBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgYXMgc29vbiBhcyB0aGUgd2FsbGV0LWxpYiBpcyByZWZhY3RvcmVkXG4qICAoaHR0cHM6Ly9naXRodWIuY29tL0hhdGhvck5ldHdvcmsvaGF0aG9yLXdhbGxldC1saWIvaXNzdWVzLzEyMilcbiovXG5leHBvcnQgY2xhc3MgQ3VzdG9tU3RvcmFnZSB7XG4gIHN0b3JlOiB1bmtub3duO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJlU3RhcnQoKTtcbiAgfVxuXG4gIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0b3JlW2tleV07XG4gIH1cblxuICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB0aGlzLnN0b3JlW2tleV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2tleV07XG5cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5zdG9yZSA9IHt9O1xuICB9XG5cbiAgcHJlU3RhcnQoKTogdm9pZCB7XG4gICAgdGhpcy5zdG9yZSA9IHtcbiAgICAgICd3YWxsZXQ6c2VydmVyJzogcHJvY2Vzcy5lbnYuREVGQVVMVF9TRVJWRVIgfHwgaGF0aG9yTGliLmNvbnN0YW50cy5ERUZBVUxUX1NFUlZFUixcbiAgICAgICd3YWxsZXQ6ZGVmYXVsdFNlcnZlcic6IHByb2Nlc3MuZW52LkRFRkFVTFRfU0VSVkVSIHx8IGhhdGhvckxpYi5jb25zdGFudHMuREVGQVVMVF9TRVJWRVIsXG4gICAgfTtcbiAgfVxufVxuXG5oYXRob3JMaWIubmV0d29yay5zZXROZXR3b3JrKHByb2Nlc3MuZW52Lk5FVFdPUkspO1xuaGF0aG9yTGliLnN0b3JhZ2Uuc2V0U3RvcmUobmV3IEN1c3RvbVN0b3JhZ2UoKSk7XG5cbmNvbnN0IGxpYk5ldHdvcmsgPSBoYXRob3JMaWIubmV0d29yay5nZXROZXR3b3JrKCk7XG5jb25zdCBoYXRob3JOZXR3b3JrID0ge1xuICBtZXNzYWdlUHJlZml4OiAnXFx4MThIYXRob3IgU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgYmVjaDMyOiBoYXRob3JMaWIubmV0d29yay5iZWNoMzJwcmVmaXgsXG4gIGJpcDMyOiB7XG4gICAgcHVibGljOiBsaWJOZXR3b3JrLnhwdWJrZXksXG4gICAgcHJpdmF0ZTogbGliTmV0d29yay54cHJpdmtleSxcbiAgfSxcbiAgcHViS2V5SGFzaDogbGliTmV0d29yay5wdWJrZXloYXNoLFxuICBzY3JpcHRIYXNoOiBsaWJOZXR3b3JrLnNjcmlwdGhhc2gsXG4gIHdpZjogbGliTmV0d29yay5wcml2YXRla2V5LFxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRvdWJsZSBzaGEyNTYgaGFzaCBvZiB0aGUgZGF0YS5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgZW5jb2RpbmcgaXMgcHJvdmlkZWQgYSBzdHJpbmcgd2lsbCBiZSByZXR1cm5lZDsgb3RoZXJ3aXNlIGEgQnVmZmVyIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBiZSBoYXNoZWRcbiAqIEBwYXJhbSBlbmNvZGluZyAtIFRoZSBlbmNvZGluZyBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBAcmV0dXJucyBUaGUgc2hhMjU2ZCBoYXNoIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTZkID0gKGRhdGE6IHN0cmluZywgZW5jb2Rpbmc6IEJpbmFyeVRvVGV4dEVuY29kaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaGFzaDEgPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgaGFzaDEudXBkYXRlKGRhdGEpO1xuICBjb25zdCBoYXNoMiA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuICBoYXNoMi51cGRhdGUoaGFzaDEuZGlnZXN0KCkpO1xuICByZXR1cm4gaGFzaDIuZGlnZXN0KGVuY29kaW5nKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB3YWxsZXQgaWQgZ2l2ZW4gdGhlIHhwdWJrZXkuXG4gKlxuICogQHBhcmFtIHhwdWJrZXkgLSBUaGUgeHB1YmtleVxuICogQHJldHVybnMgVGhlIHdhbGxldCBpZFxuICovXG5leHBvcnQgY29uc3QgZ2V0V2FsbGV0SWQgPSAoeHB1YmtleTogc3RyaW5nKTogc3RyaW5nID0+IChcbiAgc2hhMjU2ZCh4cHVia2V5LCAnaGV4Jylcbik7XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IFVuaXggdGltZXN0YW1wLCBpbiBzZWNvbmRzLlxuICpcbiAqIEByZXR1cm5zIFRoZSBjdXJyZW50IFVuaXggdGltZXN0YW1wIGluIHNlY29uZHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVuaXhUaW1lc3RhbXAgPSAoKTogbnVtYmVyID0+IChcbiAgTWF0aC5yb3VuZCgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMClcbik7XG5cbi8qKlxuICogR2V0IGEgZGF0YWJhc2UgY29ubmVjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0YWJhc2UgY29ubmVjdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0RGJDb25uZWN0aW9uID0gKCk6IFNlcnZlcmxlc3NNeXNxbCA9PiAoXG4gIHNlcnZlcmxlc3NNeXNxbCh7XG4gICAgY29uZmlnOiB7XG4gICAgICBob3N0OiBwcm9jZXNzLmVudi5EQl9FTkRQT0lOVCxcbiAgICAgIGRhdGFiYXNlOiBwcm9jZXNzLmVudi5EQl9OQU1FLFxuICAgICAgdXNlcjogcHJvY2Vzcy5lbnYuREJfVVNFUixcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHByb2Nlc3MuZW52LkRCX1BPUlQsIDEwKSxcbiAgICAgIC8vIFRPRE8gaWYgbm90IG9uIGxvY2FsIGVudiwgZ2V0IElBTSB0b2tlblxuICAgICAgLy8gaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9ibG9ncy9kYXRhYmFzZS9pYW0tcm9sZS1iYXNlZC1hdXRoZW50aWNhdGlvbi10by1hbWF6b24tYXVyb3JhLWZyb20tc2VydmVybGVzcy1hcHBsaWNhdGlvbnMvXG4gICAgICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuREJfUEFTUyxcbiAgICB9LFxuICB9KVxuKTtcblxuZXhwb3J0IGNvbnN0IGNsb3NlRGJDb25uZWN0aW9uID0gYXN5bmMgKG15c3FsOiBTZXJ2ZXJsZXNzTXlzcWwpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52LlNUQUdFID09PSAnbG9jYWwnKSB7XG4gICAgLy8gbXlzcWwuZW5kKCkgbGVhdmVzIHRoZSBmdW5jdGlvbiBoYW5naW5nIGluIHRoZSBsb2NhbCBlbnZpcm9ubWVudC4gU29tZSBpc3N1ZXM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2plcmVteWRhbHkvc2VydmVybGVzcy1teXNxbC9pc3N1ZXMvNjFcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vamVyZW15ZGFseS9zZXJ2ZXJsZXNzLW15c3FsL2lzc3Vlcy83OVxuICAgIC8vXG4gICAgLy8gSXQgc2VlbXMgdGhhdCdzIHRoZSBleHBlY3RlZCBiZWhhdmlvciBmb3IgbG9jYWwgZW52aXJvbm1lbnQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlcnZlcmxlc3Mvc2VydmVybGVzcy9pc3N1ZXMvNDcwI2lzc3VlY29tbWVudC0yMDUzNzIwMDZcbiAgICBhd2FpdCBteXNxbC5xdWl0KCk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgbXlzcWwuZW5kKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc0F1dGhvcml0eSA9ICh0b2tlbkRhdGE6IG51bWJlcik6IGJvb2xlYW4gPT4gKFxuICAodG9rZW5EYXRhICYgaGF0aG9yTGliLmNvbnN0YW50cy5UT0tFTl9BVVRIT1JJVFlfTUFTSykgPiAwICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuKTtcblxuLyoqXG4gKiBTaHVmZmxlIGFuIGFycmF5IGluIHBsYWNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBHb3QgaXQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjI3NDM4MS5cbiAqXG4gKiBAcGFyYW0gYXJyYXkgLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpdGVtc1xuICovXG5leHBvcnQgY29uc3QgYXJyYXlTaHVmZmxlID0gPFQgZXh0ZW5kcyB1bmtub3duPihhcnJheTogVFtdKTogVFtdID0+IHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgbGV0IGo7XG4gIGxldCB4O1xuICBsZXQgaTtcbiAgZm9yIChpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICB4ID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICBhcnJheVtqXSA9IHg7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBmdWxsbm9kZSBmb3IgdGhlIHJlcXVlc3RlZCB0cmFuc2FjdGlvbiBpbmZvcm1hdGlvbiBhbmQgcmV0dXJuc1xuICogaWYgaXQgaXMgdm9pZGVkIG9yIG5vdCBhbmQgdGhlIGRvd25sb2FkZWQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHR4SWQgLSBUaGUgdHJhbnNhY3Rpb24gaWRcbiAqXG4gKiBAcmV0dXJucyBBIHR1cGxlIHdpdGggdGhlIHJlc3VsdCBhbmQgdGhlIGRvd25sb2FkZWQgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVHhWb2lkZWQgPSBhc3luYyAodHhJZDogc3RyaW5nKTogUHJvbWlzZTxbYm9vbGVhbiwgYW55XT4gPT4ge1xuICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IGZ1bGxub2RlLmRvd25sb2FkVHgodHhJZCk7XG5cbiAgaWYgKCF0cmFuc2FjdGlvbi5tZXRhLnZvaWRlZF9ieSB8fCB0cmFuc2FjdGlvbi5tZXRhLnZvaWRlZF9ieS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW2ZhbHNlLCB0cmFuc2FjdGlvbl07XG4gIH1cblxuICByZXR1cm4gW3RydWUsIHRyYW5zYWN0aW9uXTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIGZ1bGxub2RlIGZvciBhIGJsb2NrIGFuZCByZXR1cm5zIGEgdHVwbGUgd2l0aCB0aGUgaGVpZ2h0IGFuZCB0aGVcbiAqIGRvd25sb2FkZWQgYmxvY2tcbiAqXG4gKiBAcGFyYW0gdHhJZCAtIFRoZSB0cmFuc2FjdGlvbiBpZFxuICpcbiAqIEByZXR1cm5zIEEgdHVwbGUgd2l0aCB0aGUgcmVzdWx0IGFuZCB0aGUgZG93bmxvYWRlZCB0cmFuc2FjdGlvblxuICovXG5leHBvcnQgY29uc3QgZmV0Y2hCbG9ja0hlaWdodCA9IGFzeW5jICh0eElkOiBzdHJpbmcsIGxvZ2dlcjogTG9nZ2VyKTogUHJvbWlzZTxbbnVtYmVyLCBhbnldPiA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgZnVsbG5vZGUuZG93bmxvYWRUeCh0eElkKTtcblxuICBpZiAoIXRyYW5zYWN0aW9uLnR4LmhlaWdodCkge1xuICAgIGxvZ2dlci5lcnJvcihKU09OLnN0cmluZ2lmeSh0cmFuc2FjdGlvbikpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgJHt0eElkfSBoYXMgbm8gaGVpZ2h0LmApO1xuICB9XG5cbiAgcmV0dXJuIFt0cmFuc2FjdGlvbi50eC5oZWlnaHQsIHRyYW5zYWN0aW9uXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBkZWZhdWx0IGFkZHJlc3MgcGF0aCBmcm9tIGFkZHJlc3MgaW5kZXhcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyBwYXRoXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBZGRyZXNzUGF0aCA9IChpbmRleDogbnVtYmVyKTogc3RyaW5nID0+IChcbiAgYG0vNDQnLyR7aGF0aG9yTGliLmNvbnN0YW50cy5IQVRIT1JfQklQNDRfQ09ERX0nLzAnLzAvJHtpbmRleH1gXG4pO1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIGV4cGVjdGVkIGZpcnN0IGFkZHJlc3MgKHJlY2VpdmVkIGFzIGEgcGFyYW0pIGlzIHRoZSBzYW1lIGFzIG9uZVxuICogZGVyaXZlZCBmcm9tIHRoZSB4cHVia2V5IHBhcmFtIG9uIHRoZSBjaGFuZ2UgMCBwYXRoXG4gKlxuICogQHBhcmFtIGV4cGVjdGVkRmlyc3RBZGRyZXNzIC0gVGhlIGV4cGVjdGVkIGZpcnN0IGFkZHJlc3NcbiAqIEBwYXJhbSB4cHVia2V5IC0gVGhlIHhwdWJrZXkgdG8gZGVyaXZlIHRoZSBjaGFuZ2UgMCBwYXRoXG4gKlxuICogQHJldHVybnMgQSB0dXBsZSB3aXRoIHRoZSBmaXJzdCB2YWx1ZSBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZSBjb21wYXJpc29uIGFuZCB0aGUgc2Vjb25kIHZhbHVlIHRoZSBmaXJzdEFkZHJlc3MgZGVyaXZlZFxuICovXG5leHBvcnQgY29uc3QgY29uZmlybUZpcnN0QWRkcmVzcyA9IChleHBlY3RlZEZpcnN0QWRkcmVzczogc3RyaW5nLCB4cHVia2V5OiBzdHJpbmcpOiBbYm9vbGVhbiwgc3RyaW5nXSA9PiB7XG4gIC8vIEZpcnN0IGRlcml2ZSB4cHViIHRvIGNoYW5nZSAwIHBhdGhcbiAgY29uc3QgZGVyaXZlZFhwdWIgPSB4cHViRGVyaXZlQ2hpbGQoeHB1YmtleSwgMCk7XG4gIC8vIFRoZW4gZ2V0IGZpcnN0IGFkZHJlc3NcbiAgY29uc3QgZmlyc3RBZGRyZXNzID0gZ2V0QWRkcmVzc0F0SW5kZXgoZGVyaXZlZFhwdWIsIDApO1xuXG4gIHJldHVybiBbXG4gICAgZmlyc3RBZGRyZXNzID09PSBleHBlY3RlZEZpcnN0QWRkcmVzcyxcbiAgICBmaXJzdEFkZHJlc3MsXG4gIF07XG59O1xuXG4vKipcbiAqIEEgY29uc3RhbnQgZm9yIHRoZSBtYXggc2hpZnQgZm9yIHRoZSB0aW1lc3RhbXAgdXNlZCBpbiBhdXRoXG4gKi9cbmV4cG9ydCBjb25zdCBBVVRIX01BWF9USU1FU1RBTVBfU0hJRlRfSU5fU0VDT05EUyA9IDMwO1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIHRpbWVzdGFtcCBoYXMgbm90IHNoaWZ0ZWQgZm9yIG1vcmUgdGhhbiBBVVRIX01BWF9USU1FU1RBTVBfU0hJRlRfSU5fU0VDT05EU1xuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBUaGUgdGltZXN0YW1wIHRvIGNoZWNrLCBpbiAqKnNlY29uZHMqKlxuICogQHBhcmFtIG5vdyAtIFRoZSBjdXJyZW50IHRpbWVzdGFtcFxuICpcbiAqIEByZXR1cm5zIEEgdHVwbGUgd2l0aCB0aGUgZmlyc3QgdmFsdWUgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY29tcGFyaXNvbiBhbmQgdGhlIHNlY29uZCB2YWx1ZSB0aGUgZmlyc3RBZGRyZXNzIGRlcml2ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQXV0aFRpbWVzdGFtcCA9ICh0aW1lc3RhbXA6IG51bWJlciwgbm93OiBudW1iZXIpOiBbYm9vbGVhbiwgbnVtYmVyXSA9PiB7XG4gIGNvbnN0IHRpbWVzdGFtcFNoaWZ0SW5TZWNvbmRzID0gTWF0aC5mbG9vcihNYXRoLmFicyhub3cgLSB0aW1lc3RhbXApKTtcblxuICByZXR1cm4gW3RpbWVzdGFtcFNoaWZ0SW5TZWNvbmRzIDwgQVVUSF9NQVhfVElNRVNUQU1QX1NISUZUX0lOX1NFQ09ORFMsIHRpbWVzdGFtcFNoaWZ0SW5TZWNvbmRzXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhZGRyZXNzIGZyb20gYSB4cHVia2V5IG9uIGEgc3BlY2lmaWMgaW5kZXhcbiAqXG4gKiBAcGFyYW0geHB1YmtleSAtIFRoZSB4cHVia2V5XG4gKiBAcGFyYW0gaW5kZXggLSBUaGUgYWRkcmVzcyBpbmRleCB0byBkZXJpdmVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGVyaXZlZCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBZGRyZXNzQXRJbmRleCA9ICh4cHVia2V5OiBzdHJpbmcsIGFkZHJlc3NJbmRleDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgY29uc3Qgbm9kZSA9IGJpcDMyLmZyb21CYXNlNTgoeHB1YmtleSkuZGVyaXZlKGFkZHJlc3NJbmRleCk7XG4gIHJldHVybiBiaXRjb2luLnBheW1lbnRzLnAycGtoKHtcbiAgICBwdWJrZXk6IG5vZGUucHVibGljS2V5LFxuICAgIG5ldHdvcms6IGhhdGhvck5ldHdvcmssXG4gIH0pLmFkZHJlc3M7XG59O1xuXG4vKipcbiAqIEdldCBIYXRob3IgYWRkcmVzc2VzIGluIGJ1bGssIHBhc3NpbmcgdGhlIHN0YXJ0IGluZGV4IGFuZCBxdWFudGl0eSBvZiBhZGRyZXNzZXMgdG8gYmUgZ2VuZXJhdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogZ2V0QWRkcmVzc2VzKCdteXhwdWInLCAyLCAzKSA9PiB7XG4gKiAgICdhZGRyZXNzMic6IDIsXG4gKiAgICdhZGRyZXNzMyc6IDMsXG4gKiAgICdhZGRyZXNzNCc6IDQsXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geHB1YmtleSBUaGUgeHB1YmtleVxuICogQHBhcmFtIHN0YXJ0SW5kZXggR2VuZXJhdGUgYWRkcmVzc2VzIHN0YXJ0aW5nIGZyb20gdGhpcyBpbmRleFxuICogQHBhcmFtIHF1YW50aXR5IEFtb3VudCBvZiBhZGRyZXNzZXMgdG8gZ2VuZXJhdGVcbiAqXG4gKiBAcmV0dXJuIEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgYWRkcmVzc2VzIGFuZCBjb3JyZXNwb25kaW5nIGluZGV4IChzdHJpbmcgPT4gbnVtYmVyKVxuICpcbiAqIEBtZW1iZXJvZiBXYWxsZXRcbiAqIEBpbm5lclxuICovXG5leHBvcnQgY29uc3QgZ2V0QWRkcmVzc2VzID0gKHhwdWJrZXk6IHN0cmluZywgc3RhcnRJbmRleDogbnVtYmVyLCBxdWFudGl0eTogbnVtYmVyKToge1trZXk6IHN0cmluZ106IG51bWJlcn0gPT4ge1xuICBjb25zdCBhZGRyTWFwID0ge307XG5cbiAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IHN0YXJ0SW5kZXggKyBxdWFudGl0eTsgaW5kZXgrKykge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzQXRJbmRleCh4cHVia2V5LCBpbmRleCk7XG4gICAgYWRkck1hcFthZGRyZXNzXSA9IGluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGFkZHJNYXA7XG59O1xuXG4vKipcbiAqIERlcml2ZXMgYSB4cHVia2V5IGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAqXG4gKiBAcGFyYW0geHB1YmtleSAtIFRoZSB4cHVia2V5XG4gKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdG8gZGVyaXZlXG4gKlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQgeHB1YmtleVxuICovXG5leHBvcnQgY29uc3QgeHB1YkRlcml2ZUNoaWxkID0gKHhwdWJrZXk6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IHN0cmluZyA9PiAoXG4gIGJpcDMyLmZyb21CYXNlNTgoeHB1YmtleSkuZGVyaXZlKGluZGV4KS50b0Jhc2U1OCgpXG4pO1xuXG4vKipcbiAqIFZlcmlmeSBhIHNpZ25hdHVyZSBmb3IgYSBnaXZlbiB0aW1lc3RhbXAgYW5kIHhwdWJrZXlcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBkb25lIGJ5IHRoZSB4cHJpdiBvZiB0aGUgd2FsbGV0XG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gVW5peCBUaW1lc3RhbXAgb2YgdGhlIHNpZ25hdHVyZVxuICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgeHB1YmtleSB1c2VkIHRvIGNyZWF0ZSB0aGUgd2FsbGV0SWRcbiAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXRJZCwgYSBzaGE1MTJkIG9mIHRoZSB4cHVia2V5XG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMgdGhlIG90aGVyIHBhcmFtc1xuICovXG5leHBvcnQgY29uc3QgdmVyaWZ5U2lnbmF0dXJlID0gKFxuICBzaWduYXR1cmU6IHN0cmluZyxcbiAgdGltZXN0YW1wOiBudW1iZXIsXG4gIGFkZHJlc3M6IHN0cmluZyxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbik6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBTdHJpbmcodGltZXN0YW1wKS5jb25jYXQod2FsbGV0SWQpLmNvbmNhdChhZGRyZXNzKTtcblxuICAgIHJldHVybiBiaXRjb2luTWVzc2FnZS52ZXJpZnkoXG4gICAgICBtZXNzYWdlLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgJ2Jhc2U2NCcpLFxuICAgICAgLy8gRGlmZmVyZW50IGZyb20gYml0Y29yZS1saWIsIGJpdGNvaW5qcy1saWIgZG9lcyBub3QgcHJlZml4IHRoZSBtZXNzYWdlUHJlZml4XG4gICAgICAvLyBsZW5ndGggb24gdGhlIG1lc3NhZ2UsIHNvIHdlIG5lZWQgdG8gZG8gdGhpcyBieSB1c2luZyBhIFwiRW5kIG9mIFRyYW5zbWlzc2lvblxuICAgICAgLy8gQmxvY2tcIiB3aXRoIHRoZSBsZW5ndGggKDIyKSBpbiBoZXggKDE3KS4gVGhpcyBpcyB0aGUgc2FtZSB0aGluZyB0aGF0IGlzIGRvbmVcbiAgICAgIC8vIGZvciB0aGUgZGVmYXVsdCBCaXRjb2luIG1lc3NhZ2UgKFxcdTAwMThCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbikuXG4gICAgICAnXFx1MDAxN0hhdGhvciBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBTaW5jZSB0aGlzIHdpbGwgdHJ5IHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlIHBhc3NpbmcgdXNlciBpbnB1dCwgdGhlIHZlcmlmeSBtZXRob2QgbWlnaHRcbiAgICAvLyB0aHJvdywgd2UgY2FuIGp1c3QgcmV0dXJuIGZhbHNlIGluIHRoaXMgY2FzZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhZGRyZXNzIChhcyBhIHN0cmluZykgZnJvbSBhIHN0cmluZyB4cHVia2V5XG4gKlxuICogQHBhcmFtIHhwdWJrZXkgLSBUaGUgeHB1YmtleVxuICpcbiAqIEByZXR1cm5zIHRoZSBhZGRyZXNzIGRlcml2ZWQgZnJvbSB0aGUgeHB1YmtleVxuICovXG5leHBvcnQgY29uc3QgZ2V0QWRkcmVzc0Zyb21YcHViID0gKHhwdWJrZXk6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IG5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KHhwdWJrZXkpO1xuXG4gIHJldHVybiBiaXRjb2luLnBheW1lbnRzLnAycGtoKHtcbiAgICBwdWJrZXk6IG5vZGUucHVibGljS2V5LFxuICAgIG5ldHdvcms6IGhhdGhvck5ldHdvcmssXG4gIH0pLmFkZHJlc3M7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIGxpc3Qgb2YgZW52IHZhcmlhYmxlcyBhcmUgc2V0IGluIHRoZSBlbnZpcm9ubWVudC4gVGhyb3cgaWYgYXQgbGVhc3RcbiAqIG9uZSBvZiB0aGVtIGlzIG1pc3NpbmdcbiAqXG4gKiBAcGFyYW0gZW52VmFyaWFibGVzIC0gQSBsaXN0IG9mIHZhcmlhYmxlcyB0byBjaGVja1xuICovXG5leHBvcnQgY29uc3QgYXNzZXJ0RW52VmFyaWFibGVzRXhpc3RlbmNlID0gKGVudlZhcmlhYmxlczogc3RyaW5nW10pOiB2b2lkID0+IHtcbiAgY29uc3QgbWlzc2luZ0xpc3QgPSBbXTtcbiAgZm9yIChjb25zdCBlbnZWYXJpYWJsZSBvZiBlbnZWYXJpYWJsZXMpIHtcbiAgICBpZiAoIShlbnZWYXJpYWJsZSBpbiBwcm9jZXNzLmVudikgfHwgcHJvY2Vzcy5lbnZbZW52VmFyaWFibGVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbWlzc2luZ0xpc3QucHVzaChlbnZWYXJpYWJsZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1pc3NpbmdMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVudiBtaXNzaW5nIHRoZSBmb2xsb3dpbmcgdmFyaWFibGVzICR7bWlzc2luZ0xpc3Quam9pbignLCAnKX1gKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils.ts\n");

/***/ }),

/***/ "./src/utils/alerting.utils.ts":
/*!*************************************!*\
  !*** ./src/utils/alerting.utils.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addAlert = void 0;\nconst aws_sdk_1 = __importDefault(__webpack_require__(/*! aws-sdk */ \"aws-sdk\"));\nconst utils_1 = __webpack_require__(/*! @src/utils */ \"./src/utils.ts\");\nconst logger_1 = __importDefault(__webpack_require__(/*! @src/logger */ \"./src/logger.ts\"));\n(0, utils_1.assertEnvVariablesExistence)([\n    'NETWORK',\n    'APPLICATION_NAME',\n    'ACCOUNT_ID',\n    'ALERT_MANAGER_REGION',\n    'ALERT_MANAGER_TOPIC',\n]);\nconst addAlert = async (title, message, severity, metadata) => {\n    const logger = (0, logger_1.default)();\n    const preparedMessage = {\n        title,\n        message,\n        severity,\n        metadata,\n        environment: process.env.NETWORK,\n        application: process.env.APPLICATION_NAME,\n    };\n    const sqs = new aws_sdk_1.default.SQS({ apiVersion: '2015-03-31' });\n    const { ACCOUNT_ID, ALERT_MANAGER_REGION, ALERT_MANAGER_TOPIC, } = process.env;\n    const QUEUE_URL = `https://sqs.${ALERT_MANAGER_REGION}.amazonaws.com/${ACCOUNT_ID}/${ALERT_MANAGER_TOPIC}`;\n    const params = {\n        MessageBody: JSON.stringify(preparedMessage),\n        QueueUrl: QUEUE_URL,\n        MessageAttributes: {\n            None: {\n                DataType: 'String',\n                StringValue: '--',\n            },\n        },\n    };\n    await new Promise((resolve) => {\n        sqs.sendMessage(params, (err) => {\n            if (err) {\n                logger.error('[ALERT] Erroed while sending message to the alert sqs queue', err);\n            }\n            resolve();\n        });\n    });\n};\nexports.addAlert = addAlert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvYWxlcnRpbmcudXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBNUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FsbGV0LXNlcnZpY2UvLi9zcmMvdXRpbHMvYWxlcnRpbmcudXRpbHMudHM/YWE2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgSGF0aG9yIExhYnMgYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBTZXZlcml0eSB9IGZyb20gJ0BzcmMvdHlwZXMnO1xuaW1wb3J0IHsgYXNzZXJ0RW52VmFyaWFibGVzRXhpc3RlbmNlIH0gZnJvbSAnQHNyYy91dGlscyc7XG5pbXBvcnQgY3JlYXRlRGVmYXVsdExvZ2dlciBmcm9tICdAc3JjL2xvZ2dlcic7XG5cbmFzc2VydEVudlZhcmlhYmxlc0V4aXN0ZW5jZShbXG4gICdORVRXT1JLJyxcbiAgJ0FQUExJQ0FUSU9OX05BTUUnLFxuICAnQUNDT1VOVF9JRCcsXG4gICdBTEVSVF9NQU5BR0VSX1JFR0lPTicsXG4gICdBTEVSVF9NQU5BR0VSX1RPUElDJyxcbl0pO1xuXG4vKipcbiAqIEFkZHMgYSBtZXNzYWdlIHRvIHRoZSBTUVMgYWxlcnRpbmcgcXVldWVcbiAqXG4gKiBAcGFyYW0gZm5OYW1lIC0gVGhlIGxhbWJkYSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIHRvIGJlIHNlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEFsZXJ0ID0gYXN5bmMgKFxuICB0aXRsZTogc3RyaW5nLFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIHNldmVyaXR5OiBTZXZlcml0eSxcbiAgbWV0YWRhdGE/OiB1bmtub3duLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZURlZmF1bHRMb2dnZXIoKTtcbiAgY29uc3QgcHJlcGFyZWRNZXNzYWdlID0ge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2UsXG4gICAgc2V2ZXJpdHksXG4gICAgbWV0YWRhdGEsXG4gICAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk5FVFdPUkssXG4gICAgYXBwbGljYXRpb246IHByb2Nlc3MuZW52LkFQUExJQ0FUSU9OX05BTUUsXG4gIH07XG5cbiAgY29uc3Qgc3FzID0gbmV3IEFXUy5TUVMoeyBhcGlWZXJzaW9uOiAnMjAxNS0wMy0zMScgfSk7XG4gIGNvbnN0IHtcbiAgICBBQ0NPVU5UX0lELFxuICAgIEFMRVJUX01BTkFHRVJfUkVHSU9OLFxuICAgIEFMRVJUX01BTkFHRVJfVE9QSUMsXG4gIH0gPSBwcm9jZXNzLmVudjtcblxuICBjb25zdCBRVUVVRV9VUkwgPSBgaHR0cHM6Ly9zcXMuJHtBTEVSVF9NQU5BR0VSX1JFR0lPTn0uYW1hem9uYXdzLmNvbS8ke0FDQ09VTlRfSUR9LyR7QUxFUlRfTUFOQUdFUl9UT1BJQ31gO1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgTWVzc2FnZUJvZHk6IEpTT04uc3RyaW5naWZ5KHByZXBhcmVkTWVzc2FnZSksXG4gICAgUXVldWVVcmw6IFFVRVVFX1VSTCxcbiAgICBNZXNzYWdlQXR0cmlidXRlczoge1xuICAgICAgTm9uZToge1xuICAgICAgICBEYXRhVHlwZTogJ1N0cmluZycsXG4gICAgICAgIFN0cmluZ1ZhbHVlOiAnLS0nLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuXG4gIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgc3FzLnNlbmRNZXNzYWdlKHBhcmFtcywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ1tBTEVSVF0gRXJyb2VkIHdoaWxlIHNlbmRpbmcgbWVzc2FnZSB0byB0aGUgYWxlcnQgc3FzIHF1ZXVlJywgZXJyKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/alerting.utils.ts\n");

/***/ }),

/***/ "@hathor/wallet-lib":
/*!*************************************!*\
  !*** external "@hathor/wallet-lib" ***!
  \*************************************/
/***/ ((module) => {

module.exports = require("@hathor/wallet-lib");

/***/ }),

/***/ "@middy/core":
/*!******************************!*\
  !*** external "@middy/core" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("@middy/core");

/***/ }),

/***/ "@middy/http-cors":
/*!***********************************!*\
  !*** external "@middy/http-cors" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("@middy/http-cors");

/***/ }),

/***/ "aws-sdk":
/*!**************************!*\
  !*** external "aws-sdk" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("aws-sdk");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = require("axios");

/***/ }),

/***/ "bip32":
/*!************************!*\
  !*** external "bip32" ***!
  \************************/
/***/ ((module) => {

module.exports = require("bip32");

/***/ }),

/***/ "bitcoinjs-lib":
/*!********************************!*\
  !*** external "bitcoinjs-lib" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("bitcoinjs-lib");

/***/ }),

/***/ "bitcoinjs-message":
/*!************************************!*\
  !*** external "bitcoinjs-message" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("bitcoinjs-message");

/***/ }),

/***/ "joi":
/*!**********************!*\
  !*** external "joi" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("joi");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("lodash");

/***/ }),

/***/ "serverless-mysql":
/*!***********************************!*\
  !*** external "serverless-mysql" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("serverless-mysql");

/***/ }),

/***/ "source-map-support/register":
/*!**********************************************!*\
  !*** external "source-map-support/register" ***!
  \**********************************************/
/***/ ((module) => {

module.exports = require("source-map-support/register");

/***/ }),

/***/ "tiny-secp256k1":
/*!*********************************!*\
  !*** external "tiny-secp256k1" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("tiny-secp256k1");

/***/ }),

/***/ "winston":
/*!**************************!*\
  !*** external "winston" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("winston");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/api/txProposalDestroy.ts");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;